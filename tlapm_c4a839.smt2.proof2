(assume a0 (! (forall ((smt__x Idv) (smt__y Idv)) (! (=> (forall ((smt__z Idv)) (= (smt__TLA__Mem smt__z smt__x) (smt__TLA__Mem smt__z smt__y))) (= smt__x smt__y)) :pattern ((smt__TLA__SetExtTrigger smt__x smt__y)))) :named @p_15))
(assume a1 (! (forall ((smt__x Idv) (smt__y Idv)) (! (=> (forall ((smt__z Idv)) (=> (smt__TLA__Mem smt__z smt__x) (smt__TLA__Mem smt__z smt__y))) (smt__TLA__SubsetEq smt__x smt__y)) :pattern ((smt__TLA__SubsetEq smt__x smt__y)))) :named @p_14))
(assume a2 (! (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (! (=> (and (smt__TLA__SubsetEq smt__x smt__y) (smt__TLA__Mem smt__z smt__x)) (smt__TLA__Mem smt__z smt__y)) :pattern ((smt__TLA__SubsetEq smt__x smt__y) (smt__TLA__Mem smt__z smt__x)))) :named @p_13))
(assume a3 (! (forall ((smt__a Idv) (smt__x Idv)) (! (= (smt__TLA__Mem smt__x (smt__TLA__Subset smt__a)) (smt__TLA__SubsetEq smt__x smt__a)) :pattern ((smt__TLA__Mem smt__x (smt__TLA__Subset smt__a))) :pattern ((smt__TLA__SubsetEq smt__x smt__a) (smt__TLA__Subset smt__a)))) :named @p_12))
(assume a4 (! (forall ((smt__f Idv) (smt__g Idv)) (! (=> (and (smt__TLA__FunIsafcn smt__f) (smt__TLA__FunIsafcn smt__g) (= (smt__TLA__FunDom smt__f) (smt__TLA__FunDom smt__g)) (forall ((smt__x Idv)) (=> (smt__TLA__Mem smt__x (smt__TLA__FunDom smt__f)) (= (smt__TLA__FunApp smt__f smt__x) (smt__TLA__FunApp smt__g smt__x))))) (= smt__f smt__g)) :pattern ((smt__TLA__FunIsafcn smt__f) (smt__TLA__FunIsafcn smt__g)))) :named @p_11))
(assume a5 (! (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (! (=> (and (smt__TLA__FunIsafcn smt__f) (= (smt__TLA__FunDom smt__f) smt__a) (forall ((smt__x Idv)) (=> (smt__TLA__Mem smt__x smt__a) (smt__TLA__Mem (smt__TLA__FunApp smt__f smt__x) smt__b)))) (smt__TLA__Mem smt__f (smt__TLA__FunSet smt__a smt__b))) :pattern ((smt__TLA__Mem smt__f (smt__TLA__FunSet smt__a smt__b))))) :named @p_10))
(assume a6 (! (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (! (=> (smt__TLA__Mem smt__f (smt__TLA__FunSet smt__a smt__b)) (and (smt__TLA__FunIsafcn smt__f) (= (smt__TLA__FunDom smt__f) smt__a))) :pattern ((smt__TLA__Mem smt__f (smt__TLA__FunSet smt__a smt__b))))) :named @p_9))
(assume a7 (! (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv) (smt__x Idv)) (! (=> (and (smt__TLA__Mem smt__f (smt__TLA__FunSet smt__a smt__b)) (smt__TLA__Mem smt__x smt__a)) (smt__TLA__Mem (smt__TLA__FunApp smt__f smt__x) smt__b)) :pattern ((smt__TLA__Mem smt__f (smt__TLA__FunSet smt__a smt__b)) (smt__TLA__Mem smt__x smt__a)) :pattern ((smt__TLA__Mem smt__f (smt__TLA__FunSet smt__a smt__b)) (smt__TLA__FunApp smt__f smt__x)))) :named @p_8))
(assume a8 (! (forall ((smt__x Idv)) (! (not (smt__TLA__Mem smt__x smt__TLA__SetEnum_0)) :pattern ((smt__TLA__Mem smt__x smt__TLA__SetEnum_0)))) :named @p_7))
(assume a9 (! (smt__TLA__Mem smt__CONSTANT_f_ (smt__TLA__FunSet smt__CONSTANT_S_ (smt__TLA__Subset smt__CONSTANT_S_))) :named @p_6))
(assume a10 (! (smt__TLA__Mem smt__CONSTANT_x_ smt__CONSTANT_S_) :named @p_5))
(assume a11 (! (forall ((smt__a Idv) (smt__x Idv)) (! (= (smt__TLA__Mem smt__x (smt__TLA__SetSt_flatnd_1 smt__a)) (and (smt__TLA__Mem smt__x smt__a) (not (smt__TLA__Mem smt__x (smt__TLA__FunApp smt__CONSTANT_f_ smt__x))))) :pattern ((smt__TLA__Mem smt__x (smt__TLA__SetSt_flatnd_1 smt__a))) :pattern ((smt__TLA__Mem smt__x smt__a) (smt__TLA__SetSt_flatnd_1 smt__a)))) :named @p_4))
(assume a12 (! (not (or (! (smt__TLA__Mem smt__CONSTANT_x_ (smt__TLA__SetSt_flatnd_1 smt__CONSTANT_S_)) :named @p_1) (! (not @p_1) :named @p_2))) :named @p_3))
(step t1 (cl (not (! (not @p_2) :named @p_16)) @p_1) :rule not_not)
(step t2 (cl @p_16) :rule not_or :premises (a12))
(step t3 (cl @p_1) :rule resolution :premises (t1 t2))
(step t4 (cl @p_2) :rule not_or :premises (a12))
(step t5 (cl) :rule resolution :premises (t3 t4))

