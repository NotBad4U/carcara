require open Stdlib.Prop;
require open Stdlib.FOL;
require open Stdlib.Set;
require open Stdlib.Nat;
require open Stdlib.Eq;
require open Stdlib.Bool;

// testing symbols
symbol a: Prop;
symbol b: Prop;
symbol c: Prop;
symbol d: Prop;
symbol e: Prop;

symbol o: Set;
rule Ï„ o â†ª Prop;

// # Clause
// Clauses are encoded with list Ã  la Church Encoding.
// This encoding is necessary because Inductive type in Lambdapi
// could not live in Prop.
constant symbol Clause : TYPE;

// Nil
symbol â–¡ : Clause;
// Cons
injective symbol âŸ‡: Prop â†’ Clause â†’ Clause;
notation âŸ‡ infix right 2;
// Append of two clause list
sequential symbol ++ : Clause â†’ Clause â†’ Clause; notation ++ infix right 3;

rule â–¡ ++ $m â†ª $m
with ($x âŸ‡ $l) ++ $m â†ª $x âŸ‡ ($l ++ $m);

constant symbol Clause_ind:  Î  P: (Clause â†’ Prop), Î  l,
  Ï€ (P â–¡) â†’
  (Î  x: Prop, Î  l: Clause, Ï€ (P l) â†’ Ï€ (P (x âŸ‡ l))) â†’
  Ï€ (P l);

// some sanity checks
assert x y z âŠ¢ x ++ y ++ z â‰¡ x ++ (y ++ z);
assert x l m âŠ¢ x âŸ‡ l ++ m â‰¡ x âŸ‡ (l ++ m);

injective symbol Â¬á¶œ : Prop â†’ Prop; notation Â¬á¶œ prefix 8;

// FIXME: 
constant symbol Â¬á¶œâ‚‘ [p q] : Ï€ (Â¬á¶œ p) â†’ Ï€ p â†’ Ï€ q;

injective symbol âˆ¨á¶œ : Prop â†’ Prop â†’ Prop; notation âˆ¨á¶œ infix right 12;

unif_rule âŠ¥ âˆ¨á¶œ $x â‰¡ $y â†ª [ $x â‰¡ $y ];

// Introduction and elimination for classical or
constant symbol âˆ¨á¶œáµ¢â‚ [p q] : Ï€ p â†’ Ï€ (p âˆ¨á¶œ q);
constant symbol âˆ¨á¶œáµ¢â‚‚ [p q] : Ï€ q â†’ Ï€ (p âˆ¨á¶œ q);
symbol âˆ¨á¶œâ‚‘ [p q r] : Ï€ (p âˆ¨á¶œ q) â†’ (Ï€ p â†’ Ï€ r) â†’ (Ï€ q â†’ Ï€ r) â†’ Ï€ r;

symbol âˆ¨á¶œ_com [x y] : Ï€ (x âˆ¨á¶œ y) â†’ Ï€ (y âˆ¨á¶œ x) â‰”
begin
  assume x y hxy;
  apply âˆ¨á¶œâ‚‘ hxy
  { assume hx; apply âˆ¨á¶œáµ¢â‚‚; apply hx }
  { assume hy; apply âˆ¨á¶œáµ¢â‚; apply hy }
end;


sequential symbol âˆ¨á¶œ_to_âŸ‡_rw: Prop â†’ Clause;
rule âˆ¨á¶œ_to_âŸ‡_rw ($x âˆ¨á¶œ $y) â†ª $x âŸ‡ (âˆ¨á¶œ_to_âŸ‡_rw $y)
with âˆ¨á¶œ_to_âŸ‡_rw âŠ¥ â†ª  â–¡;

sequential symbol âŸ‡_to_âˆ¨á¶œ_rw: Clause â†’ Prop;
rule âŸ‡_to_âˆ¨á¶œ_rw ($x âŸ‡ $y) â†ª $x âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw $y)
with âŸ‡_to_âˆ¨á¶œ_rw â–¡ â†ª âŠ¥;

assert âŠ¢ âŸ‡_to_âˆ¨á¶œ_rw (a âŸ‡ b âŸ‡ â–¡) â‰¡ a âˆ¨á¶œ b âˆ¨á¶œ âŠ¥;
assert âŠ¢ âˆ¨á¶œ_to_âŸ‡_rw (a âˆ¨á¶œ b âˆ¨á¶œ âŠ¥ âˆ¨á¶œ c âˆ¨á¶œ âŠ¥) â‰¡ (a âŸ‡ b âŸ‡ âŠ¥ âŸ‡ c âŸ‡ â–¡);

injective symbol Ï€Ì‡ c: TYPE â‰” Ï€ (âŸ‡_to_âˆ¨á¶œ_rw c);

opaque symbol Ï€Ì‡â‚— [a] : Ï€Ì‡ (a âŸ‡ â–¡)  â†’ Ï€ a â‰”
begin
  assume a Hcl_a;
  apply @âˆ¨á¶œâ‚‘ a âŠ¥ a
  { apply Hcl_a }
  { assume Ha; apply Ha }
  { assume False; apply âŠ¥â‚‘ False };
end;

// opaque injective symbol Ï€á¶œ p : TYPE â‰” Ï€ (Â¬ (Â¬ p));

// Introduction rule for Clause
// construct `p âŸ‡ q` from a clause with only `p`
opaque symbol âŸ‡áµ¢â‚ [p q] : Ï€Ì‡ (p âŸ‡ â–¡) â†’ Ï€Ì‡ (p âŸ‡ q) â‰”
begin
  assume p q Hp;
  apply âˆ¨á¶œâ‚‘ Hp
  { assume Hpi_p; apply âˆ¨á¶œáµ¢â‚;  apply Hpi_p }
  { assume Hbot; apply âŠ¥â‚‘; apply Hbot }
end;

// construct `p âŸ‡ q` from a proof of `p`
opaque symbol âŸ‡áµ¢â‚' [p q] : Ï€ p â†’ Ï€Ì‡ (p âŸ‡ q) â‰”
begin 
  assume p q Hp; apply âˆ¨á¶œáµ¢â‚; apply Hp
end;

opaque symbol âŸ‡áµ¢â‚‚ [p q] : Ï€Ì‡ q â†’ Ï€Ì‡ (p âŸ‡ q) â‰”
begin
  assume p q Hq; apply âˆ¨á¶œáµ¢â‚‚; apply Hq
end;

// Elimination rule for clause
opaque symbol âŸ‡â‚‘ [p q r] : Ï€Ì‡ (p âŸ‡ q) â†’ (Ï€Ì‡ (p âŸ‡ â–¡) â†’ Ï€Ì‡ r) â†’ (Ï€Ì‡ q â†’ Ï€Ì‡ r) â†’ Ï€Ì‡ r â‰”
begin
  assume p q r Hpq Hpr Hqr;
  apply âˆ¨á¶œâ‚‘ Hpq
  { assume Hp; apply Hpr (âˆ¨á¶œáµ¢â‚ Hp) }
  { assume Hq; apply Hqr Hq }
end;

opaque  symbol âˆ¨á¶œ_assoc [x y z] : Ï€ ((x âˆ¨á¶œ (y âˆ¨á¶œ z)) â‡” ((x âˆ¨á¶œ y) âˆ¨á¶œ z)) â‰”
begin
  assume x y z;
  simplify;
  apply âˆ§áµ¢
  {
    assume Hxyz;
    apply âˆ¨á¶œâ‚‘ Hxyz
    { assume Hx;  apply âˆ¨á¶œáµ¢â‚; apply âˆ¨á¶œáµ¢â‚; apply Hx }
    {
      assume Hyz; apply âˆ¨á¶œâ‚‘ Hyz
      { assume Hy;  apply âˆ¨á¶œáµ¢â‚;  apply âˆ¨á¶œáµ¢â‚‚; apply Hy }
      { assume Hz;  apply âˆ¨á¶œáµ¢â‚‚; apply Hz }
    }
  }
  {
    assume Hxyz;
    apply âˆ¨á¶œâ‚‘ Hxyz
    {
      assume Hxy; apply âˆ¨á¶œâ‚‘ Hxy
      { assume Hx; apply âˆ¨á¶œáµ¢â‚; apply Hx }
      { assume Hy; apply âˆ¨á¶œáµ¢â‚‚; apply âˆ¨á¶œáµ¢â‚; apply Hy }
    }
    { assume Hz; apply âˆ¨á¶œáµ¢â‚‚; apply âˆ¨á¶œáµ¢â‚‚; apply Hz }
  }
end;

opaque symbol ++_to_âˆ¨á¶œ a b : Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) â‡” ((âŸ‡_to_âˆ¨á¶œ_rw a) âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw b))) â‰”
begin
  assume a b;
  apply Clause_ind (Î» u, (âŸ‡_to_âˆ¨á¶œ_rw (u ++ b)) â‡” ((âŸ‡_to_âˆ¨á¶œ_rw u) âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw b))) a
    {
      simplify;
      apply âˆ§áµ¢
        { assume H; apply âˆ¨á¶œáµ¢â‚‚; apply H }
        {
          assume H;
          apply âˆ¨á¶œâ‚‘ H { assume HâŠ¥; apply âŠ¥â‚‘; apply HâŠ¥ } { assume H1;  apply H1}
        }
    }
    {
      simplify;
      assume x l Hir;
      apply âˆ§áµ¢
      { assume H; apply âˆ¨á¶œâ‚‘ H
        {
          assume Hx;
          apply âˆ¨á¶œáµ¢â‚;
          apply âˆ¨á¶œáµ¢â‚;
          apply Hx;
        }
        {
          assume Hl++b;
          have tmp: Ï€ ((x âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b))  â‡’ ((x âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw l) âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)) {
            refine âˆ§â‚‘â‚ âˆ¨á¶œ_assoc;
          };
          apply tmp;
          apply âˆ¨á¶œâ‚‘ H
          {
            assume Hx;  apply âˆ¨á¶œáµ¢â‚; apply Hx
          }
          {
            assume Hl_or_b;
            apply âˆ¨á¶œáµ¢â‚‚;
            have HirLeft: Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw (l ++ b) â‡’ (âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b))) {
                refine (âˆ§â‚‘â‚ Hir);
            };
            apply HirLeft;
            apply Hl++b
          }
        }
      }
      {
        assume H;
        apply âˆ¨á¶œâ‚‘ H {
            assume H1;
            apply âˆ¨á¶œâ‚‘ H1 {
              assume Hx;
              apply âˆ¨á¶œáµ¢â‚;
              apply Hx;
            } {
              assume H2;
              apply âˆ¨á¶œáµ¢â‚‚;
              have tmp: Ï€ (((âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b) â‡’ âŸ‡_to_âˆ¨á¶œ_rw (l ++ b))) {
                refine (âˆ§â‚‘â‚‚ Hir);
              };
              apply tmp;
              apply âˆ¨á¶œáµ¢â‚;
              apply H2
            }
        } {
          assume H1;
          apply âˆ¨á¶œáµ¢â‚‚;
          have tmp: Ï€ (((âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b) â‡’ âŸ‡_to_âˆ¨á¶œ_rw (l ++ b))) {
                refine (âˆ§â‚‘â‚‚ Hir);
              };
              apply tmp;
              apply âˆ¨á¶œáµ¢â‚‚;
              apply H1
        }        
      }
    }
end;
 
injective symbol âˆ§á¶œ : Prop â†’ Prop â†’ Prop; notation âˆ§á¶œ infix right 10;
constant symbol âˆ§á¶œáµ¢ [p q] : Ï€ p â†’ Ï€ q â†’ Ï€ (p âˆ§á¶œ q);
symbol âˆ§á¶œâ‚‘â‚ [p q] : Ï€ (p âˆ§á¶œ q) â†’ Ï€ p;
symbol âˆ§á¶œâ‚‘â‚‚ [p q] : Ï€ (p âˆ§á¶œ q) â†’ Ï€ q;

injective symbol âŸ¹á¶œ: Prop â†’ Prop â†’ Prop;
notation âŸ¹á¶œ infix right 7;

constant symbol âŸ¹á¶œ_right [a b] : (Ï€ a â†’ Ï€ b) â†’ Ï€ (a âŸ¹á¶œ b);

constant symbol âŸ¹á¶œ_to_âˆ¨á¶œ [a b] : Ï€ (a âŸ¹á¶œ b) â†’ Ï€ ((Â¬á¶œ a) âˆ¨á¶œ b);

constant symbol âˆ¨á¶œ_to_âŸ¹á¶œ [a b] : (Ï€ a â†’ Ï€ b) â†’ Ï€ (a âŸ¹á¶œ b);

injective symbol âŸºá¶œ: Prop â†’ Prop â†’ Prop;
notation âŸºá¶œ infix right 6;

constant symbol âŸºá¶œáµ¢ [p q] : (Ï€ p â†’ Ï€  q) â†’  (Ï€ q â†’ Ï€ p) â†’ Ï€ (p âŸºá¶œ q);

constant symbol âŸºá¶œâ‚‘ [p q r] : Ï€ (p âŸºá¶œ q) â†’  ((Ï€ p â†’ Ï€ q) â†’ (Ï€ q â†’ Ï€ p) â†’ Ï€ r) â†’ Ï€ r;

constant symbol âŸºá¶œ_refl [p] : Ï€ (p âŸºá¶œ p);

constant symbol âŸºá¶œ_sym [p q] : Ï€ (p âŸºá¶œ q) â†’ Ï€ (q âŸºá¶œ p);

constant symbol âŸºá¶œ_trans [p q r] : Ï€ (p âŸºá¶œ q) â†’ Ï€ (q âŸºá¶œ r) â†’ Ï€ (p âŸºá¶œ r);

opaque symbol cong [x x'] (f: Prop â†’ Prop): Ï€(x âŸºá¶œ x') â†’ Ï€(f x âŸºá¶œ f x) â‰”
begin admit end;

opaque symbol cong2 [x y x' y'] (f: Prop â†’ Prop â†’ Prop): Ï€Ì‡ (x âŸºá¶œ x' âŸ‡ â–¡) â†’ Ï€Ì‡ (y âŸºá¶œ y' âŸ‡ â–¡) â†’ Ï€Ì‡((f x y) âŸºá¶œ (f x' y') âŸ‡ â–¡) â‰”
begin admit end;

// opaque symbol cong2 [x y x' y'] (f: Prop â†’ Prop â†’ Prop): Ï€(x âŸºá¶œ x') â†’ Ï€(y âŸºá¶œ y') â†’ Ï€((f x y) âŸºá¶œ (f x' y')) â‰”
// begin admit end;

opaque symbol cong3 [x y x' y' z z'] (f: Prop â†’ Prop â†’ Prop â†’ Prop): Ï€Ì‡ (x âŸºá¶œ x' âŸ‡ â–¡) â†’ Ï€Ì‡ (y âŸºá¶œ y' âŸ‡ â–¡) â†’  Ï€Ì‡ (z âŸºá¶œ z' âŸ‡ â–¡) â†’ Ï€Ì‡((f x y z) âŸºá¶œ (f x' y' z') âŸ‡ â–¡) â‰”
begin admit end;

// opaque symbol cong3 [x y x' y' z z'] (f: Prop â†’ Prop â†’ Prop â†’ Prop): Ï€(x âŸºá¶œ x') â†’ Ï€(y âŸºá¶œ y') â†’ Ï€(z âŸºá¶œ z') â†’ Ï€((f x y z) âŸºá¶œ (f x' y' z')) â‰”
// begin admit end;

constant symbol âˆ€á¶œ [a] : (Ï„ a â†’ Prop) â†’ Prop; notation âˆ€á¶œ quantifier;
constant symbol âˆ€á¶œáµ¢ [p] : (Î  x, Ï€ (p x)) â†’ Ï€ (âˆ€á¶œ p);
constant symbol âˆ€á¶œâ‚‘ [p x] : Ï€ (âˆ€á¶œ p) â†’ Ï€ (p x);

constant symbol âˆƒá¶œ [a] : (Ï„ a â†’ Prop) â†’ Prop; notation âˆƒá¶œ quantifier;
constant symbol âˆƒá¶œáµ¢ [a] p (x:Ï„ a) : Ï€ (p x) â†’ Ï€ (âˆƒá¶œ p);
symbol âˆƒá¶œâ‚‘ [a] p : Ï€ (âˆƒá¶œ p) â†’ Î  q, (Î  x:Ï„ a, Ï€ (p x) â†’ Ï€ q) â†’ Ï€ q;

rule âˆƒá¶œâ‚‘ _ (âˆƒá¶œáµ¢ _ $x $px) _ $f â†ª $f $x $px;

constant symbol classic [p] : Ï€ (p âˆ¨á¶œ Â¬á¶œ p);

constant symbol nnpp [p] : Ï€ (Â¬á¶œ Â¬á¶œ p) â†’ Ï€ p;

constant symbol âŸ¹á¶œáµ¢ [p q] : (Ï€ p â†’ Ï€ q) â†’ Ï€ (p âŸ¹á¶œ q);

constant symbol âŸ¹á¶œâ‚‘ [p q] : Ï€ (p âŸ¹á¶œ q) â†’ Ï€ p â†’ Ï€ q;

constant symbol imply_to_and [p q] : Ï€ (Â¬á¶œ (p âŸ¹á¶œ q)) â†’ Ï€ (p âˆ§á¶œ (Â¬á¶œ q));

// Hilbert epsilon operator/choice
constant symbol Ïµ  [a]: (Ï„ a â†’ Prop) â†’ Prop; notation âˆ€á¶œ quantifier;

constant symbol Ïµáµ¢ [p x] : Ï€ (p x) â†’ Ï€ (p (Ïµ p));
constant symbol Ïµ_det [p q]: Î  x, Ï€ ((p x) âŸºá¶œ (q x)) â†’ Ï€ (Ïµ p = Ïµ q);

symbol trivial : Ï€ âŠ¤;

symbol neg_true : Ï€ (Â¬á¶œ âŠ¥);

// i â–· ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘n
// j â–· ğœ‘1 , â‹¯ , ğœ‘n
//constant symbol or [a b] : Ï€Ì‡ ((a âˆ¨á¶œ b) âŸ‡ â–¡) â†’ Ï€Ì‡ (âˆ¨á¶œ_to_âŸ‡_rw  (a âˆ¨á¶œ b));

opaque symbol not_not x : Ï€Ì‡ ( (Â¬á¶œ (Â¬á¶œ (Â¬á¶œ x))) âŸ‡ x âŸ‡ â–¡) â‰”
begin
  assume x;
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply âŸ¹á¶œáµ¢;
  assume H;
  apply âˆ¨á¶œáµ¢â‚;
  apply nnpp H
end;

opaque symbol implies [Ï†â‚ Ï†â‚‚] : Ï€ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚) â†’ Ï€Ì‡ (Â¬á¶œ Ï†â‚ âŸ‡ Ï†â‚‚ âŸ‡ â–¡) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ HÏ†â‚âŸ¹á¶œÏ†â‚‚;
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply âŸ¹á¶œáµ¢;
  assume Ï€Ï†â‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply âŸ¹á¶œâ‚‘ HÏ†â‚âŸ¹á¶œÏ†â‚‚ Ï€Ï†â‚
end;

opaque symbol not_implies1 [Ï†â‚ Ï†â‚‚] : Ï€ (Â¬á¶œ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚)) â†’ Ï€Ì‡ (Ï†â‚ âŸ‡ â–¡) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ Hnot_Ï†â‚âŸ¹á¶œÏ†â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply âˆ§á¶œâ‚‘â‚ (imply_to_and Hnot_Ï†â‚âŸ¹á¶œÏ†â‚‚)
end;

opaque symbol not_implies2 [Ï†â‚ Ï†â‚‚] : Ï€ (Â¬á¶œ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚)) â†’  Ï€Ì‡ (Â¬á¶œ Ï†â‚‚ âŸ‡ â–¡) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ Hnot_Ï†â‚âŸ¹á¶œÏ†â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply âˆ§á¶œâ‚‘â‚‚ (imply_to_and Hnot_Ï†â‚âŸ¹á¶œÏ†â‚‚)
end;

opaque symbol implies_neg1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚ âŸ‡ Ï†â‚ âŸ‡ â–¡) â‰”
begin
  assume Ï†â‚ Ï†â‚‚;
  have Hassoc: Ï€ (((Ï†â‚ âŸ¹á¶œ Ï†â‚‚) âˆ¨á¶œ (Ï†â‚ âˆ¨á¶œ âŠ¥)) â‡” (((Ï†â‚ âŸ¹á¶œ Ï†â‚‚) âˆ¨á¶œ Ï†â‚) âˆ¨á¶œ âŠ¥)) {
    apply âˆ¨á¶œ_assoc
  };
  have Lassoc: Ï€ ((((Ï†â‚ âŸ¹á¶œ Ï†â‚‚) âˆ¨á¶œ Ï†â‚) âˆ¨á¶œ âŠ¥) â‡’ ((Ï†â‚ âŸ¹á¶œ Ï†â‚‚) âˆ¨á¶œ (Ï†â‚ âˆ¨á¶œ âŠ¥))) {
    apply âˆ§â‚‘â‚‚ Hassoc;
  };
  apply Lassoc;
  apply âˆ¨á¶œáµ¢â‚;
  admit //FIXME: finish the proof with âŸ¹á¶œ_to_âˆ¨á¶œ and EM
end;

constant symbol implies_neg2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚ âŸ‡ Â¬á¶œ Ï†â‚‚ âŸ‡ â–¡);

opaque symbol equiv1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ âŸºá¶œ Ï†â‚‚ âŸ‡ â–¡) â†’ Ï€Ì‡ ((Â¬á¶œ Ï†â‚) âŸ‡ Ï†â‚‚ âŸ‡ â–¡) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ H1;
  apply âˆ¨á¶œâ‚‘ H1
  {
    assume Hequiv;
    apply âŸºá¶œâ‚‘ Hequiv;
    assume H2 H3;
    simplify;
    have Hassoc: Ï€ (((Â¬á¶œ Ï†â‚) âˆ¨á¶œ (Ï†â‚‚ âˆ¨á¶œ âŠ¥)) â‡” (((Â¬á¶œ Ï†â‚) âˆ¨á¶œ Ï†â‚‚) âˆ¨á¶œ âŠ¥)) {
      apply (@âˆ¨á¶œ_assoc (Â¬á¶œ Ï†â‚) Ï†â‚‚ âŠ¥);
    };
    have Hassoc_left: Ï€ ((((Â¬á¶œ Ï†â‚) âˆ¨á¶œ Ï†â‚‚) âˆ¨á¶œ âŠ¥)  â‡’  ((Â¬á¶œ Ï†â‚) âˆ¨á¶œ (Ï†â‚‚ âˆ¨á¶œ âŠ¥))) {
      refine âˆ§â‚‘â‚‚ Hassoc
    };
    apply Hassoc_left;
    apply âˆ¨á¶œáµ¢â‚;
    apply âŸ¹á¶œ_to_âˆ¨á¶œ;
    apply âŸ¹á¶œáµ¢;
    refine H2;
  }
  {
    assume Hbot;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply Hbot;
  }
end;

opaque symbol equiv2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ âŸºá¶œ Ï†â‚‚ âŸ‡ â–¡)  â†’ Ï€Ì‡ (Ï†â‚ âŸ‡ (Â¬á¶œ Ï†â‚‚) âŸ‡ â–¡) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ H1;
  apply âˆ¨á¶œâ‚‘ H1
  {
    assume Hequiv;
    apply âŸºá¶œâ‚‘ Hequiv;
    assume H2 H3;
    simplify;
    have Hassoc: Ï€ ((Ï†â‚ âˆ¨á¶œ ((Â¬á¶œ Ï†â‚‚) âˆ¨á¶œ âŠ¥)) â‡” ((Ï†â‚ âˆ¨á¶œ (Â¬á¶œ Ï†â‚‚)) âˆ¨á¶œ âŠ¥)) {
      apply (@âˆ¨á¶œ_assoc Ï†â‚ (Â¬á¶œ Ï†â‚‚) âŠ¥);
    };
    have Hassoc_left: Ï€ (((Ï†â‚ âˆ¨á¶œ (Â¬á¶œ Ï†â‚‚)) âˆ¨á¶œ âŠ¥)  â‡’  (Ï†â‚ âˆ¨á¶œ ((Â¬á¶œ Ï†â‚‚) âˆ¨á¶œ âŠ¥))) {
      refine âˆ§â‚‘â‚‚ Hassoc
    };
    apply Hassoc_left;
    apply âˆ¨á¶œáµ¢â‚;
    apply âˆ¨á¶œ_com;
    apply âŸ¹á¶œ_to_âˆ¨á¶œ;
    apply âŸ¹á¶œáµ¢;
    refine H3;
  }
  {
    assume Hbot;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply Hbot;
  }
end;

constant symbol equiv_pos1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Â¬á¶œ (Ï†â‚ âŸºá¶œ Ï†â‚‚)) âŸ‡ Ï†â‚ âŸ‡ Â¬á¶œ Ï†â‚‚ âŸ‡ â–¡);

constant symbol equiv_pos2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Â¬á¶œ (Ï†â‚ âŸºá¶œ Ï†â‚‚)) âŸ‡ (Â¬á¶œ Ï†â‚) âŸ‡ Ï†â‚‚ âŸ‡ â–¡);

constant symbol equiv_neg1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Ï†â‚ âŸºá¶œ Ï†â‚‚) âŸ‡ Â¬á¶œ Ï†â‚ âŸ‡ Â¬á¶œ Ï†â‚‚ âŸ‡ â–¡);

constant symbol equiv_neg2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Ï†â‚ âŸºá¶œ Ï†â‚‚) âŸ‡ Ï†â‚ âŸ‡ Ï†â‚‚ âŸ‡ â–¡);

constant symbol implies_pos [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Â¬á¶œ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚)) âŸ‡ Â¬á¶œ Ï†â‚ âŸ‡ Ï†â‚‚ âŸ‡ â–¡);

opaque symbol subproof [Ï†â‚ Ïˆ] : Ï€ Ï†â‚ â†’ Ï€ Ïˆ â†’ Ï€Ì‡ ((Â¬á¶œ Ï†â‚) âŸ‡ Ïˆ âŸ‡ â–¡) â‰”
begin
  assume Ï†â‚ Ïˆ HÏ†â‚ HÏˆ;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply HÏˆ
end;

opaque symbol subproof2 [Ï†â‚ Ï†â‚‚ Ïˆ] : Ï€Ì‡ (Ï†â‚ âŸ‡ â–¡) â†’ Ï€Ì‡ (Ï†â‚‚ âŸ‡ â–¡) â†’ Ï€Ì‡ ( Ïˆ âŸ‡ â–¡) â†’ Ï€Ì‡ ((Â¬á¶œ Ï†â‚) âŸ‡ (Â¬á¶œ Ï†â‚‚) âŸ‡ Ïˆ âŸ‡ â–¡) â‰”
begin
  simplify;
  assume Ï†â‚ Ï†â‚‚ Ïˆ HÏ†â‚ HÏ†â‚‚ HÏˆ_âŠ¥;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply âˆ¨á¶œâ‚‘ HÏˆ_âŠ¥ { assume HÏˆ; apply HÏˆ } { assume HâŠ¥; apply âŠ¥â‚‘; apply HâŠ¥ }
end;

opaque symbol subproof3 Ï†â‚ Ï†â‚‚ Ï†â‚ƒ Ïˆ : Ï€Ì‡ (Ï†â‚ âŸ‡ â–¡) â†’ Ï€Ì‡ (Ï†â‚‚ âŸ‡ â–¡) â†’ Ï€Ì‡ (Ï†â‚ƒ âŸ‡ â–¡) â†’ Ï€Ì‡ (Ïˆ âŸ‡ â–¡) â†’ Ï€Ì‡ ((Â¬á¶œ Ï†â‚) âŸ‡ (Â¬á¶œ Ï†â‚‚) âŸ‡ (Â¬á¶œ Ï†â‚ƒ) âŸ‡ Ïˆ âŸ‡ â–¡) â‰”
begin
  simplify;
  assume Ï†â‚ Ï†â‚‚ Ï†â‚ƒ Ïˆ HÏ†â‚ HÏ†â‚‚ HÏ†â‚ƒ HÏˆ_âŠ¥;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply âˆ¨á¶œâ‚‘ HÏˆ_âŠ¥ { assume HÏˆ; apply HÏˆ } { assume HâŠ¥; apply âŠ¥â‚‘; apply HâŠ¥ }
end;

symbol morgan [p q] : Ï€ (Â¬á¶œ (p âˆ¨á¶œ q)) â†’ Ï€ (Â¬á¶œ p âˆ§á¶œ Â¬á¶œ q);

sequential symbol morgan_l: Prop â†’ Prop;
sequential symbol âˆ§_to_âˆ¨: Prop â†’ Prop;

rule morgan_l  (Â¬á¶œ $hd) âˆ§á¶œ $tl â†ª Â¬á¶œ ( $hd âˆ¨á¶œ (âˆ§_to_âˆ¨  $tl));
rule âˆ§_to_âˆ¨ (Â¬á¶œ $hd) âˆ§á¶œ $tl â†ª $hd âˆ¨á¶œ (âˆ§_to_âˆ¨ $tl)
with âˆ§_to_âˆ¨ âŠ¤ â†ª âŠ¤;

sequential symbol morgan_r: Prop â†’ Prop;
sequential symbol âŸ‡_to_âˆ§: Prop â†’ Prop;

rule morgan_r  Â¬á¶œ ($hd âˆ¨á¶œ $tl) â†ª Â¬á¶œ $hd âˆ§á¶œ (âŸ‡_to_âˆ§ $tl);
rule âŸ‡_to_âˆ§ ($a âˆ¨á¶œ $b) â†ª  Â¬á¶œ $a âˆ§á¶œ (âŸ‡_to_âˆ§ $b)
with âŸ‡_to_âˆ§ âŠ¥ â†ª âŠ¤;

// # In Predicate
// 
// The In predicate works with ğ”¹ instead of Prop to avoid making critical pairs wiht other rules.
// If we use Prop, then we will need a rule
// â–· `$x âŸºá¶œ $x â†ª âŠ¤` to replace `eq $x $h` and, 
// â–· `_ âˆ¨á¶œ âŠ¤ â†ª âŠ¤` for `or _ true â†ª true`. 
//
// This choice will create a critical pair reduction which would make any clause in the goal
// that contain the litteral âŠ¤ unable to compute the predicate In.
//
// To illustrate this case, consider the goal:
// âŠ¢ (ğœ‘1 âˆ¨á¶œ â‹¯ âˆ¨á¶œ âŠ¤ â‹¯ âˆ¨á¶œ ğœ‘ğ‘›), Â¬ğœ‘k
// then we will have
// âŠ¢ In_âˆ¨á¶œ ğœ‘k (ğœ‘1 âˆ¨á¶œ â‹¯ âˆ¨á¶œ âŠ¤ â‹¯ âˆ¨á¶œ ğœ‘ğ‘›)  (apply or_neg)
// âŠ¢ In_âˆ¨á¶œ ğœ‘k âŠ¤  (by simplification)
// we got stuck...

// Decidable equality in ğ”¹.
// Symbol = has been declared constant, it cannot be used as the head of a rewrite rule LHS.
// So we create our own eq symbol.
symbol eq: Prop â†’ Prop â†’ ğ”¹;
rule eq $x $x â†ª true;

sequential symbol In_âˆ§á¶œ: Prop â†’ Prop â†’ ğ”¹;
rule In_âˆ§á¶œ $x ($h âˆ§á¶œ $tl) â†ª (eq $x $h)  Stdlib.Bool.or (In_âˆ§á¶œ $x $tl)
with In_âˆ§á¶œ $x âŠ¤ â†ª false;

sequential symbol In_âˆ¨á¶œ: Prop â†’ Prop â†’ ğ”¹;
rule In_âˆ¨á¶œ $x ($h âˆ¨á¶œ $tl) â†ª (eq $x $h) Stdlib.Bool.or (In_âˆ¨á¶œ $x $tl)
with In_âˆ¨á¶œ _ âŠ¥ â†ª false;

// and_pos: Â¬(ğœ‘1 âˆ§ â€¦ âˆ§ ğœ‘ğ‘›), ğœ‘ğ‘˜
symbol and_pos [Ï†â‚__Ï†â‚™ Ï†â‚–]:  Ï€ ((In_âˆ§á¶œ Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Â¬á¶œ Ï†â‚__Ï†â‚™ âŸ‡ Ï†â‚– âŸ‡ â–¡);

opaque symbol test_and_pos: Ï€Ì‡ ((Â¬á¶œ (a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ d âˆ§á¶œ âŠ¤)) âŸ‡ d âŸ‡ â–¡) â‰”
begin
  apply and_pos;
  reflexivity
end; 

// and_neg:  (ğœ‘1 âˆ§ â‹¯ âˆ§ ğœ‘ğ‘›), Â¬ğœ‘1, â€¦ , Â¬ğœ‘ğ‘›
sequential symbol and_neg_r: Prop â†’ Clause â†’ ğ”¹; 
rule and_neg_r ($x âˆ§á¶œ $tl) (Â¬á¶œ $x âŸ‡ $tl2) â†ª and_neg_r $tl $tl2
with and_neg_r âŠ¤ â–¡ â†ª true; 

symbol and_neg [l1 l2]: Ï€ (and_neg_r l1 l2 = true) â†’ Ï€Ì‡ (l1 âŸ‡ l2);

opaque symbol test_and_neg: Ï€Ì‡ ((a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ d âˆ§á¶œ âŠ¤) âŸ‡ Â¬á¶œ a âŸ‡ Â¬á¶œ b âŸ‡ Â¬á¶œ c âŸ‡ Â¬á¶œ d âŸ‡ â–¡) â‰”
begin
  apply and_neg; reflexivity
end; 

// or_pos:  Â¬(ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›), ğœ‘1 , â€¦ , ğœ‘ğ‘›
sequential symbol or_pos_r: Prop â†’ Clause â†’ ğ”¹; 
rule or_pos_r ($x âˆ¨á¶œ $tl) ($x âŸ‡ $tl2) â†ª or_pos_r $tl $tl2
with or_pos_r âŠ¥ â–¡ â†ª true; 

symbol or_pos [l1 l2]: Ï€ (or_pos_r l1 l2 = true) â†’ Ï€Ì‡ (Â¬á¶œ l1 âŸ‡ l2);

opaque symbol test_or_pos: Ï€Ì‡ (Â¬á¶œ (a âˆ¨á¶œ b âˆ¨á¶œ c âˆ¨á¶œ d âˆ¨á¶œ âŠ¥) âŸ‡ a âŸ‡ b âŸ‡ c âŸ‡ d âŸ‡ â–¡) â‰”
begin
  apply or_pos; reflexivity
end; 

// or_neg:
// i. â–· (ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›), Â¬ğœ‘k
symbol or_neg [Ï†â‚__Ï†â‚™] Ï†â‚–:  Ï€ ((In_âˆ¨á¶œ Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Ï†â‚__Ï†â‚™ âŸ‡ Â¬á¶œ Ï†â‚– âŸ‡ â–¡);

opaque symbol test_or_neg: Ï€Ì‡ (((a âˆ¨á¶œ b âˆ¨á¶œ c âˆ¨á¶œ d âˆ¨á¶œ âŠ¥)) âŸ‡ Â¬á¶œ c âŸ‡ â–¡) â‰”
begin
  apply or_neg; reflexivity
end; 

// not_or:
// i. â–· Â¬(ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›)
// j. â–· Â¬ğœ‘ğ‘˜
symbol not_or [Ï†â‚–] Ï†â‚__Ï†â‚™: Ï€ (Â¬á¶œ Ï†â‚__Ï†â‚™) â†’ Ï€ ((In_âˆ¨á¶œ Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Â¬á¶œ Ï†â‚– âŸ‡ â–¡);

opaque symbol identity_âŠ¥ [x] : Ï€ (x âˆ¨á¶œ âŠ¥) â†’ Ï€ x â‰”
begin
  assume x H;
  apply âˆ¨á¶œâ‚‘ H
  { assume Hx; apply Hx } { assume HâŠ¥; apply âŠ¥â‚‘; apply HâŠ¥ }
end;

opaque symbol test_not_or: Ï€Ì‡ (Â¬á¶œ (a âˆ¨á¶œ b âˆ¨á¶œ c âˆ¨á¶œ d âˆ¨á¶œ âŠ¥) âŸ‡ â–¡) â†’ Ï€Ì‡ (Â¬á¶œ c âŸ‡ â–¡) â‰”
begin
  assume H; // i
  apply not_or (a âˆ¨á¶œ b âˆ¨á¶œ c âˆ¨á¶œ d âˆ¨á¶œ âŠ¥)
    { apply Ï€Ì‡â‚—; apply H }
    { reflexivity }
end;

// not_and:
// i. â–· Â¬(ğœ‘1 âˆ§ â€¦ âˆ§ ğœ‘ğ‘›)
// j. â–· Â¬ğœ‘1, â€¦ , Â¬ğœ‘ğ‘›
sequential symbol not_and_r: Prop â†’ Clause â†’ ğ”¹; 
rule not_and_r ($x âˆ§á¶œ $tl) (Â¬á¶œ $x âŸ‡ $tl2) â†ª not_and_r $tl $tl2
with not_and_r âŠ¤ â–¡ â†ª true; 

symbol not_and [l1 l2]: Ï€ (Â¬á¶œ l1) â†’ Ï€ (not_and_r l1 l2 = true) â†’ Ï€Ì‡ l2;

opaque symbol test_not_and: Ï€Ì‡ (Â¬á¶œ (a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ d âˆ§á¶œ âŠ¤) âŸ‡ â–¡) â†’ Ï€Ì‡ (Â¬á¶œ a âŸ‡ Â¬á¶œ b âŸ‡ Â¬á¶œ c âŸ‡ Â¬á¶œ d âŸ‡ â–¡) â‰”
begin
  assume t1;
  apply not_and (Ï€Ì‡â‚— t1);
  reflexivity
end; 

// and:
// i. â–· (ğœ‘1 âˆ§ â‹¯ âˆ§ ğœ‘ğ‘›)
// j. â–· ğœ‘ğ‘˜
symbol and [Ï†â‚–] Ï†â‚__Ï†â‚™ : Ï€ ((In_âˆ§á¶œ Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Ï†â‚__Ï†â‚™ âŸ‡ â–¡)  â†’ Ï€Ì‡ (Ï†â‚– âŸ‡ â–¡);

opaque symbol test_and:  Ï€Ì‡ ((a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ âŠ¤) âŸ‡ â–¡) â†’  Ï€Ì‡ (c âŸ‡ â–¡) â‰”
begin
  assume t1;
  apply and ((a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ âŠ¤)) { reflexivity } { apply t1  };
end;

opaque symbol resolutionâ‚— x a b: Ï€Ì‡ (x âŸ‡ a) â†’ Ï€Ì‡ ((Â¬á¶œ x) âŸ‡ b) â†’ Ï€Ì‡ (a ++ b) â‰” begin
  assume x a b H1 H2;
  apply âŸ‡â‚‘ H1 {
    assume Hx;
    apply âŸ‡â‚‘ H2 {
      assume Hnx;
      simplify;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œâ‚‘ Hx { assume Hpi_x;  apply âˆ¨á¶œâ‚‘ Hnx { assume Hpi_nx;  apply Â¬á¶œâ‚‘ Hpi_nx Hpi_x }  {  assume Hbot; apply âŠ¥â‚‘;  apply Hbot  } } { assume Hbot; apply âŠ¥â‚‘;  apply Hbot  };
    } {
      assume Hb;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚‚;
      apply Hb;
    }
  } {
    assume Ha;
    apply âŸ‡â‚‘ H2 {
      assume Hnx;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚;
      apply Ha
    } {
      assume Hb;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚;
      apply Ha
    }
  };
end;

opaque symbol resolutionáµ£ x a b: Ï€Ì‡ ((Â¬á¶œ x) âŸ‡ a) â†’ Ï€Ì‡ (x âŸ‡ b) â†’ Ï€Ì‡ (a ++ b) â‰” begin
  assume x a b H1 H2;
  apply âŸ‡â‚‘ H1 {
    assume Hnx;
    apply âŸ‡â‚‘ H2 {
      assume Hx;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œâ‚‘ Hx { assume Hpi_x;  apply âˆ¨á¶œâ‚‘ Hnx { assume Hpi_nx;  apply Â¬á¶œâ‚‘ Hpi_nx Hpi_x }  {  assume Hbot; apply âŠ¥â‚‘;  apply Hbot  } } { assume Hbot; apply âŠ¥â‚‘;  apply Hbot  };
    } {
      assume Hb;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚‚;
      apply Hb;
    }
  } {
    assume Ha;
    apply âŸ‡â‚‘ H2 {
      assume Hnx;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚;
      apply Ha
    } {
      assume Hb;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚;
      apply Ha
    }
  };
end;

opaque symbol bind_âˆƒ [p q]: (Î  x, Ï€ (p x âŸºá¶œ q x))  â†’ Ï€ ((`âˆƒá¶œ x, p x) âŸºá¶œ (`âˆƒá¶œ x, q x)) â‰”
begin
  assume p q H;
  apply âŸºá¶œáµ¢ 
  {
    assume H1;
    apply âˆƒá¶œâ‚‘ _ H1;
    assume x Hpx;
    apply âˆƒá¶œáµ¢ _ x;
    apply âŸºá¶œâ‚‘ (H x);
    assume Hpx_qx Hqx_px;
    apply Hpx_qx Hpx
  }
  {
    assume H1;
    apply âˆƒá¶œâ‚‘ _ H1;
    assume x Hqx;
    apply âˆƒá¶œáµ¢ _ x;
    apply âŸºá¶œâ‚‘ (H x);
    assume Hpx_qx Hqx_px;
    apply Hqx_px Hqx
  };
end;

opaque symbol bind_âˆ€ [p q]: (Î  x, Ï€ (p x âŸºá¶œ q x))  â†’ Ï€ ((`âˆ€á¶œ x, p x) âŸºá¶œ (`âˆ€á¶œ x, q x)) â‰”
begin
  assume p q H;
  apply âŸºá¶œáµ¢ 
  {
    assume H1;
    apply âˆ€á¶œáµ¢ _;
    assume x;
    have Hpx: Ï€ (p x) {
      apply @âˆ€á¶œâ‚‘ (Î» x, p x) x H1
    };
    apply âŸºá¶œâ‚‘ (H x);
    assume Hpx_qx Hqx_px;
    apply Hpx_qx Hpx
  }
  {
    assume H1;
    apply âˆ€á¶œáµ¢ _;
    assume x;
    have Hqx: Ï€ (q x) {
      apply @âˆ€á¶œâ‚‘ (Î» x, q x) x H1
    };
    apply âŸºá¶œâ‚‘ (H x);
    assume Hpx_qx Hqx_px;
    apply Hqx_px Hqx
  };
end;


// Â¬á¶œ (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))
// â‰¡
// smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___ âŸºá¶œ smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___