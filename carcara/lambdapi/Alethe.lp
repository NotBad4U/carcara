require open Stdlib.Prop;
require open Stdlib.FOL;
require open Stdlib.Set;
require open Stdlib.Nat;
require open Stdlib.Eq;
require open Stdlib.Bool;
require open Stdlib.List;

// testing symbols
symbol a: Prop;
symbol b: Prop;
symbol c: Prop;
symbol d: Prop;
symbol e: Prop;

symbol o: Set;
rule Ï„ o â†ª Prop;

// # Clause
// Clauses are encoded with list Ã  la Church Encoding.
// This encoding is necessary because Inductive type in Lambdapi
// could not live in Prop.
constant symbol Clause : TYPE;

constant symbol clause: Set;
rule Ï„ clause â†ª Clause;

// Nil
symbol â–© : Clause; 
// Cons
injective symbol âŸ‡: Prop â†’ Clause â†’ Clause;
notation âŸ‡ infix right 2;
// Append of two clause list
sequential symbol ++ : Clause â†’ Clause â†’ Clause; notation ++ infix right 3;

rule â–© ++ $m â†ª $m
with ($x âŸ‡ $l) ++ $m â†ª $x âŸ‡ ($l ++ $m);

constant symbol Clause_ind:  Î  P: (Clause â†’ Prop), Î  l,
  Ï€ (P â–©) â†’
  (Î  x: Prop, Î  l: Clause, Ï€ (P l) â†’ Ï€ (P (x âŸ‡ l))) â†’
  Ï€ (P l);

// some sanity checks
assert x y z âŠ¢ x ++ y ++ z â‰¡ x ++ (y ++ z);
assert x l m âŠ¢ x âŸ‡ l ++ m â‰¡ x âŸ‡ (l ++ m);

notation Â¬ prefix 8;

// FIXME: 
constant symbol Â¬â‚‘ [p q] : Ï€ (Â¬ p) â†’ Ï€ p â†’ Ï€ q;

injective symbol âˆ¨á¶œ : Prop â†’ Prop â†’ Prop; notation âˆ¨á¶œ infix right 12;

// Introduction and elimination for classical or
constant symbol âˆ¨á¶œáµ¢â‚ [p q] : Ï€ p â†’ Ï€ (p âˆ¨á¶œ q);
constant symbol âˆ¨á¶œáµ¢â‚‚ [p q] : Ï€ q â†’ Ï€ (p âˆ¨á¶œ q);
symbol âˆ¨á¶œâ‚‘ [p q r] : Ï€ (p âˆ¨á¶œ q) â†’ (Ï€ p â†’ Ï€ r) â†’ (Ï€ q â†’ Ï€ r) â†’ Ï€ r;

opaque symbol âˆ¨á¶œ_com [x y] : Ï€ (x âˆ¨á¶œ y) â†’ Ï€ (y âˆ¨á¶œ x) â‰”
begin
  assume x y hxy;
  apply âˆ¨á¶œâ‚‘ hxy
  { assume hx; apply âˆ¨á¶œáµ¢â‚‚; apply hx }
  { assume hy; apply âˆ¨á¶œáµ¢â‚; apply hy }
end;


sequential symbol âˆ¨á¶œ_to_âŸ‡_rw: Prop â†’ Clause;
rule âˆ¨á¶œ_to_âŸ‡_rw ($x âˆ¨á¶œ $y) â†ª $x âŸ‡ (âˆ¨á¶œ_to_âŸ‡_rw $y)
with âˆ¨á¶œ_to_âŸ‡_rw âŠ¥ â†ª  â–©;

sequential symbol âŸ‡_to_âˆ¨á¶œ_rw: Clause â†’ Prop;
rule âŸ‡_to_âˆ¨á¶œ_rw ($x âŸ‡ $y) â†ª $x âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw $y)
with âŸ‡_to_âˆ¨á¶œ_rw â–© â†ª âŠ¥;

assert âŠ¢ âŸ‡_to_âˆ¨á¶œ_rw (a âŸ‡ b âŸ‡ â–©) â‰¡ a âˆ¨á¶œ b âˆ¨á¶œ âŠ¥;
assert âŠ¢ âˆ¨á¶œ_to_âŸ‡_rw (a âˆ¨á¶œ b âˆ¨á¶œ âŠ¥ âˆ¨á¶œ c âˆ¨á¶œ âŠ¥) â‰¡ (a âŸ‡ b âŸ‡ âŠ¥ âŸ‡ c âŸ‡ â–©);

injective symbol Ï€Ì‡ c: TYPE â‰” Ï€ (âŸ‡_to_âˆ¨á¶œ_rw c);

opaque symbol Ï€Ì‡â‚— [a] : Ï€Ì‡ (a âŸ‡ â–©)  â†’ Ï€ a â‰”
begin
  assume a Hcl_a;
  apply @âˆ¨á¶œâ‚‘ a âŠ¥ a
  { apply Hcl_a }
  { assume Ha; apply Ha }
  { assume False; apply âŠ¥â‚‘ False };
end;

// opaque injective symbol Ï€á¶œ p : TYPE â‰” Ï€ (Â¬ (Â¬ p));

// Introduction rule for Clause
// construct `p âŸ‡ q` from a clause with only `p`
opaque symbol âŸ‡áµ¢â‚ [p q] : Ï€Ì‡ (p âŸ‡ â–©) â†’ Ï€Ì‡ (p âŸ‡ q) â‰”
begin
  assume p q Hp;
  apply âˆ¨á¶œâ‚‘ Hp
  { assume Hpi_p; apply âˆ¨á¶œáµ¢â‚;  apply Hpi_p }
  { assume Hbot; apply âŠ¥â‚‘; apply Hbot }
end;

// construct `p âŸ‡ q` from a proof of `p`
opaque symbol âŸ‡áµ¢â‚' [p q] : Ï€ p â†’ Ï€Ì‡ (p âŸ‡ q) â‰”
begin 
  assume p q Hp; apply âˆ¨á¶œáµ¢â‚; apply Hp
end;

opaque symbol âŸ‡áµ¢â‚‚ [p q] : Ï€Ì‡ q â†’ Ï€Ì‡ (p âŸ‡ q) â‰”
begin
  assume p q Hq; apply âˆ¨á¶œáµ¢â‚‚; apply Hq
end;

// Elimination rule for clause
opaque symbol âŸ‡â‚‘ [p q r] : Ï€Ì‡ (p âŸ‡ q) â†’ (Ï€Ì‡ (p âŸ‡ â–©) â†’ Ï€Ì‡ r) â†’ (Ï€Ì‡ q â†’ Ï€Ì‡ r) â†’ Ï€Ì‡ r â‰”
begin
  assume p q r Hpq Hpr Hqr;
  apply âˆ¨á¶œâ‚‘ Hpq
  { assume Hp; apply Hpr (âˆ¨á¶œáµ¢â‚ Hp) }
  { assume Hq; apply Hqr Hq }
end;

opaque  symbol âˆ¨á¶œ_assoc [x y z] : Ï€ ((x âˆ¨á¶œ (y âˆ¨á¶œ z)) â‡” ((x âˆ¨á¶œ y) âˆ¨á¶œ z)) â‰”
begin
  assume x y z;
  apply âˆ§áµ¢
  {
    assume Hxyz;
    apply âˆ¨á¶œâ‚‘ Hxyz
    { assume Hx;  apply âˆ¨á¶œáµ¢â‚; apply âˆ¨á¶œáµ¢â‚; apply Hx }
    {
      assume Hyz; apply âˆ¨á¶œâ‚‘ Hyz
      { assume Hy;  apply âˆ¨á¶œáµ¢â‚;  apply âˆ¨á¶œáµ¢â‚‚; apply Hy }
      { assume Hz;  apply âˆ¨á¶œáµ¢â‚‚; apply Hz }
    }
  }
  {
    assume Hxyz;
    apply âˆ¨á¶œâ‚‘ Hxyz
    {
      assume Hxy; apply âˆ¨á¶œâ‚‘ Hxy
      { assume Hx; apply âˆ¨á¶œáµ¢â‚; apply Hx }
      { assume Hy; apply âˆ¨á¶œáµ¢â‚‚; apply âˆ¨á¶œáµ¢â‚; apply Hy }
    }
    { assume Hz; apply âˆ¨á¶œáµ¢â‚‚; apply âˆ¨á¶œáµ¢â‚‚; apply Hz }
  }
end;

opaque  symbol âˆ¨á¶œ_assoc_eq x y z : Ï€ ((x âˆ¨á¶œ (y âˆ¨á¶œ z)) = ((x âˆ¨á¶œ y) âˆ¨á¶œ z)) â‰”
begin
  assume x y z;
  admit
end;


opaque symbol ++_to_âˆ¨á¶œ a b : Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) â‡” ((âŸ‡_to_âˆ¨á¶œ_rw a) âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw b))) â‰”
begin
  assume a b;
  apply Clause_ind (Î» u, (âŸ‡_to_âˆ¨á¶œ_rw (u ++ b)) â‡” ((âŸ‡_to_âˆ¨á¶œ_rw u) âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw b))) a
    {
      apply âˆ§áµ¢
        { assume H; apply âˆ¨á¶œáµ¢â‚‚; apply H }
        {
          assume H;
          apply âˆ¨á¶œâ‚‘ H { assume HâŠ¥; apply âŠ¥â‚‘; apply HâŠ¥ } { assume H1;  apply H1}
        }
    }
    {
      assume x l Hir;
      apply âˆ§áµ¢
      { assume H; apply âˆ¨á¶œâ‚‘ H
        {
          assume Hx;
          apply âˆ¨á¶œáµ¢â‚;
          apply âˆ¨á¶œáµ¢â‚;
          apply Hx;
        }
        {
          assume Hl++b;
          have tmp: Ï€ ((x âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b))  â‡’ ((x âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw l) âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)) {
            refine âˆ§â‚‘â‚ âˆ¨á¶œ_assoc;
          };
          apply tmp;
          apply âˆ¨á¶œâ‚‘ H
          {
            assume Hx;  apply âˆ¨á¶œáµ¢â‚; apply Hx
          }
          {
            assume Hl_or_b;
            apply âˆ¨á¶œáµ¢â‚‚;
            have HirLeft: Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw (l ++ b) â‡’ (âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b))) {
                refine (âˆ§â‚‘â‚ Hir);
            };
            apply HirLeft;
            apply Hl++b
          }
        }
      }
      {
        assume H;
        apply âˆ¨á¶œâ‚‘ H {
            assume H1;
            apply âˆ¨á¶œâ‚‘ H1 {
              assume Hx;
              apply âˆ¨á¶œáµ¢â‚;
              apply Hx;
            } {
              assume H2;
              apply âˆ¨á¶œáµ¢â‚‚;
              have tmp: Ï€ (((âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b) â‡’ âŸ‡_to_âˆ¨á¶œ_rw (l ++ b))) {
                refine (âˆ§â‚‘â‚‚ Hir);
              };
              apply tmp;
              apply âˆ¨á¶œáµ¢â‚;
              apply H2
            }
        } {
          assume H1;
          apply âˆ¨á¶œáµ¢â‚‚;
          have tmp: Ï€ (((âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b) â‡’ âŸ‡_to_âˆ¨á¶œ_rw (l ++ b))) {
                refine (âˆ§â‚‘â‚‚ Hir);
              };
              apply tmp;
              apply âˆ¨á¶œáµ¢â‚‚;
              apply H1
        }        
      }
    }
end;
 
injective symbol âˆ§á¶œ : Prop â†’ Prop â†’ Prop; notation âˆ§á¶œ infix right 10;
constant symbol âˆ§á¶œáµ¢ [p q] : Ï€ p â†’ Ï€ q â†’ Ï€ (p âˆ§á¶œ q);
symbol âˆ§á¶œâ‚‘â‚ [p q] : Ï€ (p âˆ§á¶œ q) â†’ Ï€ p;
symbol âˆ§á¶œâ‚‘â‚‚ [p q] : Ï€ (p âˆ§á¶œ q) â†’ Ï€ q;

injective symbol âŸ¹á¶œ: Prop â†’ Prop â†’ Prop;
notation âŸ¹á¶œ infix right 7;

constant symbol âŸ¹á¶œ_right [a b] : (Ï€ a â†’ Ï€ b) â†’ Ï€ (a âŸ¹á¶œ b);

constant symbol âŸ¹á¶œ_to_âˆ¨á¶œ [a b] : Ï€ (a âŸ¹á¶œ b) â†’ Ï€ ((Â¬ a) âˆ¨á¶œ b);

constant symbol âˆ¨á¶œ_to_âŸ¹á¶œ [a b] : Ï€ ((Â¬ a) âˆ¨á¶œ b) â†’ Ï€ (a âŸ¹á¶œ b);

constant symbol âˆ€á¶œ [a] : (Ï„ a â†’ Prop) â†’ Prop; notation âˆ€á¶œ quantifier;
constant symbol âˆ€á¶œáµ¢ [a p] : (Î  (x : Ï„ a), Ï€ (p x)) â†’ Ï€ (âˆ€á¶œ p);
constant symbol âˆ€á¶œâ‚‘ [a p] (x: Ï„ a) : Ï€ (âˆ€á¶œ p) â†’ Ï€ (p x);

constant symbol âˆƒá¶œ [a] : (Ï„ a â†’ Prop) â†’ Prop; notation âˆƒá¶œ quantifier;
constant symbol âˆƒá¶œáµ¢ [a] p (x:Ï„ a) : Ï€ (p x) â†’ Ï€ (âˆƒá¶œ p);
symbol âˆƒá¶œâ‚‘ [a] p : Ï€ (âˆƒá¶œ p) â†’ Î  q, (Î  x:Ï„ a, Ï€ (p x) â†’ Ï€ q) â†’ Ï€ q;

rule âˆƒá¶œâ‚‘ _ (âˆƒá¶œáµ¢ _ $x $px) _ $f â†ª $f $x $px;

constant symbol classic [p] : Ï€ (p âˆ¨á¶œ Â¬ p);

constant symbol nnpp [p] : Ï€ (Â¬ Â¬ p) â†’ Ï€ p;

constant symbol nnpp_eq p : Ï€ ((Â¬ Â¬ p) = p);

//TODO: Need classical definition
opaque symbol pnnp [p] : Ï€ p â†’ Ï€ (Â¬ Â¬ p) â‰”
begin admit end;

// We would like to have
// rule Ï€ ($p â‡’á¶œ $q) â†ª Ï€ $p â†’ Ï€ $q;
// However, it is not possible because â‡’á¶œ has a definition.
constant symbol âŸ¹á¶œáµ¢ [p q] : (Ï€ p â†’ Ï€ q) â†’ Ï€ (p âŸ¹á¶œ q);

constant symbol âŸ¹á¶œâ‚‘ [p q] : Ï€ (p âŸ¹á¶œ q) â†’ Ï€ p â†’ Ï€ q;

symbol âŸºá¶œ p q â‰” (p âŸ¹á¶œ q) âˆ§á¶œ (q âŸ¹á¶œ p); notation âŸºá¶œ infix right 6;

constant symbol âŸºá¶œâ‚‘ [p q r] : Ï€ (p âŸºá¶œ q) â†’  ((Ï€ p â†’ Ï€ q) â†’ (Ï€ q â†’ Ï€ p) â†’ Ï€ r) â†’ Ï€ r;

opaque symbol âŸºá¶œ_refl [p] : Ï€ (p âŸºá¶œ p) â‰”
begin
  assume p;
  apply âˆ§á¶œáµ¢
  { apply âŸ¹á¶œáµ¢; assume Hp; apply Hp}
  {apply âŸ¹á¶œáµ¢; assume Hp; apply Hp}
end;

opaque symbol âŸºá¶œ_sym [p q] : Ï€ (p âŸºá¶œ q) â†’ Ï€ (q âŸºá¶œ p) â‰”
begin
  assume p q Hp_equiv_q;
  apply âˆ§á¶œáµ¢
  {
    apply âŸ¹á¶œáµ¢;
    assume Hq;
    apply âŸºá¶œâ‚‘ Hp_equiv_q;
    assume Hpq Hqp;
    apply Hqp;
    apply Hq;
  }
  {
    apply âŸ¹á¶œáµ¢;
    assume Hp;
    apply âŸºá¶œâ‚‘ Hp_equiv_q;
    assume Hpq Hqp;
    apply Hpq;
    apply Hp;
  }
end;

opaque symbol âŸºá¶œ_trans [p q r] : Ï€ (p âŸºá¶œ q) â†’ Ï€ (q âŸºá¶œ r) â†’ Ï€ (p âŸºá¶œ r) â‰”
begin
  assume p q r Hpq Hqr;
  apply âˆ§á¶œáµ¢
  {
    apply âŸ¹á¶œáµ¢;
    assume Hp;
    apply âŸºá¶œâ‚‘ Hpq;
    assume Hp_imp_q Hq_imp_p;
    apply âŸºá¶œâ‚‘ Hqr;
    assume Hq_imp_r Hr_imp_q;
    apply Hq_imp_r (Hp_imp_q Hp );
  }
  {
    apply âŸ¹á¶œáµ¢;
    assume Hr;
    apply âŸºá¶œâ‚‘ Hpq;
    assume Hp_imp_q Hq_imp_p;
    apply âŸºá¶œâ‚‘ Hqr;
    assume Hq_imp_r Hr_imp_q;
    apply Hq_imp_p (Hr_imp_q Hr );
  };
end;

// Axiom propositional_extensionality:
//   forall (P Q : Prop), (P <-> Q) -> P = Q.
constant symbol prop_ext [p q]: Ï€ (p âŸºá¶œ q) â†’ Ï€ (p = q);

opaque symbol âŸº_ext [p q]:  Ï€ (p = q) â†’ Ï€ (p âŸºá¶œ q) â‰”
begin
  assume p q Heq; rewrite Heq; apply âŸºá¶œ_refl
end;

opaque symbol iff_equiv_eq p q: Ï€ ((p âŸºá¶œ q) = (p = q)) â‰”
begin
  assume p q;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  { apply âŸ¹á¶œáµ¢; assume Hiff; apply prop_ext Hiff }
  { apply âŸ¹á¶œáµ¢; assume Heq; rewrite Heq; apply âŸºá¶œ_refl }
end;

//FIXME:  from Classic.lp in Stdlib. 
// Remove this definition when the PR is merged.
constant symbol imply_to_or[p q] : Ï€ (p âŸ¹á¶œ q) â†’ Ï€ ((Â¬ p) âˆ¨á¶œ q);

opaque symbol or_to_imply [p q] : Ï€ ((Â¬ p) âˆ¨á¶œ q) â†’ Ï€ (p âŸ¹á¶œ q) â‰”
begin
  admit
end;

opaque symbol not_or_and [p q] : Ï€ (Â¬ (p âˆ¨á¶œ q)) â†’ Ï€ ((Â¬ p) âˆ§á¶œ Â¬ q) â‰”
begin
  admit
end;

opaque symbol and_not_or [p q] : Ï€ ((Â¬ p) âˆ§á¶œ Â¬ q) â†’ Ï€ (Â¬ (p âˆ¨á¶œ q)) â‰”
begin
  admit
end;


opaque symbol not_and_or [p q] : Ï€ (Â¬ (p âˆ§á¶œ q)) â†’ Ï€ ((Â¬ p) âˆ¨á¶œ (Â¬ q)) â‰”
begin
  admit
end;

opaque symbol or_not_and [p q] : Ï€ ((Â¬ p) âˆ¨á¶œ (Â¬ q)) â†’ Ï€ (Â¬ (p âˆ§á¶œ q)) â‰”
begin
  admit
end;

constant symbol imply_to_and [p q] : Ï€ (Â¬ (p âŸ¹á¶œ q)) â†’ Ï€ (p âˆ§á¶œ (Â¬ q));
// End Classic.lp ===========

opaque symbol morganâ‚ p q : Ï€ ((Â¬ (p âˆ§á¶œ q)) = ((Â¬ p) âˆ¨á¶œ (Â¬ q))) â‰”
begin
  assume p q;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  {
    apply âŸ¹á¶œáµ¢;
    assume H;
    apply  not_and_or H
  }
  {
    apply âŸ¹á¶œáµ¢;
    assume H;
    refine or_not_and H
  }
end;

opaque symbol morganâ‚‚ p q : Ï€ ((Â¬ (p âˆ¨á¶œ q)) = ((Â¬ p) âˆ§á¶œ (Â¬ q))) â‰”
begin
  assume p q;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  {
    apply âŸ¹á¶œáµ¢;
    assume H;
    refine not_or_and H
  }
  {
    apply âŸ¹á¶œáµ¢;
    assume H;
    refine and_not_or H
  }
end;

opaque symbol distributive_or p q r : Ï€ ((p âˆ¨á¶œ (q âˆ§á¶œ r)) = ((p âˆ¨á¶œ q) âˆ§á¶œ (p âˆ¨á¶œ r))) â‰”
begin
  admit
end;

opaque symbol distributive_and p q r : Ï€ ((p âˆ§á¶œ (q âˆ¨á¶œ r)) = ((p âˆ§á¶œ q) âˆ¨á¶œ (p âˆ§á¶œ r))) â‰”
begin
  admit
end;

opaque symbol and_com p q : Ï€ ((p âˆ§á¶œ q) = (q âˆ§á¶œ p)) â‰”
begin
  assume p q;
  admit  
end;

opaque symbol or_com p q : Ï€ ((p âˆ¨á¶œ q) = (q âˆ¨á¶œ p)) â‰”
begin
  admit
end;

opaque symbol or_idempotent p : Ï€ ((p âˆ¨á¶œ p) = p) â‰”
begin
  assume p;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  {
    apply âŸ¹á¶œáµ¢;
    assume Hporp;
    apply âˆ¨á¶œâ‚‘ Hporp
    { assume Hp; refine Hp }
    { assume Hp; refine Hp }
  }
  {
    apply âŸ¹á¶œáµ¢;
    assume Hp;
    apply âˆ¨á¶œáµ¢â‚;
    refine Hp
  }
end;

opaque symbol and_idempotent p : Ï€ ((p âˆ§á¶œ p) = p) â‰”
begin
  assume p;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  { apply âŸ¹á¶œáµ¢; assume Hpandp; apply âˆ§á¶œâ‚‘â‚ Hpandp; }
  {
    apply âŸ¹á¶œáµ¢;
    assume Hp;
    apply âˆ§á¶œáµ¢ { refine Hp } { refine Hp }
  }
end;


// Hilbert epsilon operator/choice
constant symbol Ïµ  [a]: (Ï„ a â†’ Prop) â†’ Ï„ a; notation Ïµ quantifier;

constant symbol Ïµáµ¢ x p : Ï€ (p x) â†’ Ï€ (p (Ïµ p));
constant symbol Ïµ_det [p q]: Î  x, Ï€ ((p x) âŸºá¶œ (q x)) â†’ Ï€ (Ïµ p = Ïµ q);

opaque symbol imp_eq_or p q: Ï€ (((Â¬ p) âˆ¨á¶œ q) =  (p âŸ¹á¶œ q)) â‰”
begin
  assume p q;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  { apply âŸ¹á¶œáµ¢; assume Hor; apply or_to_imply Hor }
  { apply âŸ¹á¶œáµ¢; assume Himp; apply imply_to_or Himp }
end;

opaque  symbol or_identity x : Ï€ ((x âˆ¨á¶œ âŠ¥) = x) â‰”
begin
  assume x;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  { apply âŸ¹á¶œáµ¢; assume Hor; apply âˆ¨á¶œâ‚‘ Hor { assume Hx; refine Hx } { assume Hbot; apply âŠ¥â‚‘; refine Hbot } }
  { apply âŸ¹á¶œáµ¢; assume Hx; apply âˆ¨á¶œáµ¢â‚; refine Hx }
end;

opaque symbol Ïµ_equiv_âˆƒá¶œ' [p] : Ï€ ((`âˆƒá¶œ x, p x) = (p (`Ïµ x, p x))) â‰”
begin
  assume p;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  {
    apply âŸ¹á¶œáµ¢;
    assume Hexist;
    apply âˆƒá¶œâ‚‘ _ Hexist;
    assume x Hpx;
    apply Ïµáµ¢ x (Î» u, p u);
    apply Hpx
  }
  {
    apply âŸ¹á¶œáµ¢;
    assume Heps;
    apply âˆƒá¶œáµ¢ _ (`Ïµ x, p x);
    apply Heps
  } 
end;

opaque symbol Ïµ_equiv_âˆƒá¶œ [p] : Ï€ ((`âˆƒá¶œ x, p x) âŸºá¶œ (p (`Ïµ x, p x))) â‰”
begin
  assume p;
  apply âˆ§á¶œáµ¢
  {
    apply âŸ¹á¶œáµ¢;
    assume Hexist;
    apply âˆƒá¶œâ‚‘ _ Hexist;
    assume x Hpx;
    apply Ïµáµ¢ x (Î» u, p u);
    apply Hpx
  }
  {
    apply âŸ¹á¶œáµ¢;
    assume Heps;
    apply âˆƒá¶œáµ¢ _ (`Ïµ x, p x);
    apply Heps
  } 
end;

symbol ite c t e â‰” (c âŸ¹á¶œ t) âˆ§á¶œ ((Â¬ c) âŸ¹á¶œ e);
constant symbol iteI : Î  c t e p,
                           (Ï€ c â†’ Ï€ (p t))
                         â†’ ((Ï€ c â†’ Ï€ âŠ¥) â†’ Ï€ (p e))
                         â†’ Ï€ (p (ite c t e));                         

opaque symbol âˆ¨á¶œ_to_âŸ‡ a b: Ï€ (a âˆ¨á¶œ b) â†’ Ï€Ì‡ (a âŸ‡ b âŸ‡ â–©) â‰”
begin
  assume a b Haorb;
  apply âˆ¨á¶œâ‚‘ Haorb
  { assume Ha;  apply âˆ¨á¶œáµ¢â‚; apply Ha }
  {  assume Hb; apply âˆ¨á¶œáµ¢â‚‚; apply âˆ¨á¶œáµ¢â‚; apply Hb }
end; 

opaque symbol ite1 [c t e] : Ï€ (ite c t e) â†’ Ï€Ì‡ (c âŸ‡ e âŸ‡ â–©) â‰”
begin
  assume c t e Hite;
  apply âˆ¨á¶œ_to_âŸ‡;
  have H: Ï€ (Â¬ c âŸ¹á¶œ e) { apply âˆ§á¶œâ‚‘â‚‚ Hite }; 
  have tmp: Ï€ (c âˆ¨á¶œ e âŸºá¶œ  (Â¬ Â¬ c) âˆ¨á¶œ e) { 
    apply âˆ§á¶œáµ¢
    {
      apply âŸ¹á¶œáµ¢;
      assume H1;
      apply âˆ¨á¶œâ‚‘ H1
      { assume Hc; apply âˆ¨á¶œáµ¢â‚; simplify; assume Hnc; apply Hnc Hc }
      { assume He; apply âˆ¨á¶œáµ¢â‚‚;  apply He };
    }
    {
      apply âŸ¹á¶œáµ¢;
      assume H1; 
      apply âˆ¨á¶œâ‚‘ H1
      { assume Hc; apply âˆ¨á¶œáµ¢â‚; apply nnpp; refine Hc }
      { assume He; apply âˆ¨á¶œáµ¢â‚‚;  apply He };
    };
  };
  apply âŸºá¶œâ‚‘ tmp;
  assume H1 H2;
  apply H2;
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply H
end;

opaque symbol ite2 [c t e] : Ï€ (ite c t e) â†’ Ï€Ì‡ ((Â¬ c) âŸ‡ t âŸ‡ â–©) â‰”
begin
  assume c t e Hite;
  apply âˆ¨á¶œ_to_âŸ‡;
  have H: Ï€ (c âŸ¹á¶œ t) { apply âˆ§á¶œâ‚‘â‚ Hite };
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply H
end;

opaque symbol ite_pos1 [c t e] : Ï€Ì‡ (Â¬ (ite c t e) âŸ‡ c âŸ‡ e âŸ‡ â–©) â‰”
begin
  assume c t e;
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply âŸ¹á¶œáµ¢;
  assume H;
  apply ite1 H;
end;

opaque symbol ite_pos2 [c t e] : Ï€Ì‡ (Â¬ (ite c t e) âŸ‡ Â¬ c âŸ‡ t âŸ‡ â–©) â‰”
begin
  assume c t e;
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply âŸ¹á¶œáµ¢;
  assume H;
  apply ite2 H;
end;

opaque symbol ite_neg1 [c t e] : Ï€Ì‡ ((ite c t e) âŸ‡ c âŸ‡ Â¬ e âŸ‡ â–©) â‰”
begin
  assume c t e;
  simplify;
  rewrite or_identity;
  rewrite .[c âˆ¨á¶œ ((e â‡’ âŠ¥))] or_com;
  rewrite left .[c âŸ¹á¶œ t] imp_eq_or;
  rewrite left .[(c â‡’ âŠ¥) âŸ¹á¶œ e] imp_eq_or;
  rewrite or_com;
  rewrite distributive_or;
  apply âˆ§á¶œáµ¢
  {
    rewrite âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚;
    rewrite left âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply classic
  }
  {
    rewrite or_com;
    rewrite left âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚‚;
    rewrite âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚;
    apply classic
  };
end;

opaque symbol ite_neg2 [c t e] : Ï€Ì‡ ((ite c t e) âŸ‡ Â¬ c âŸ‡ Â¬ t âŸ‡ â–©) â‰”
begin
  assume c t e;
  simplify;
  rewrite or_identity;
  rewrite left .[c âŸ¹á¶œ t] imp_eq_or;
  rewrite left .[((c â‡’ âŠ¥)) âŸ¹á¶œ e] imp_eq_or;
  rewrite or_com;
  rewrite distributive_or;
  apply âˆ§á¶œáµ¢
  {
    rewrite left âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚‚;
    rewrite or_com;
    rewrite left âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply classic
  }
  {
    rewrite âˆ¨á¶œ_assoc_eq;
    rewrite .[(c â‡’ âŠ¥) âˆ¨á¶œ (t â‡’ âŠ¥)] or_com;
    apply âˆ¨á¶œáµ¢â‚;
    rewrite left âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply classic
  }
end;

opaque symbol not_ite1 [c t e] : Ï€ (Â¬ (ite c t e)) â†’ Ï€Ì‡( c âŸ‡ Â¬ e âŸ‡ â–©) â‰”
begin
  assume c t e H;
  have H1: Ï€ ((Â¬ (c âŸ¹á¶œ t)) âˆ¨á¶œ (Â¬ ((Â¬ c) âŸ¹á¶œ e))) { apply not_and_or H };
  apply âˆ¨á¶œâ‚‘ H1
  {
    assume Hl;
    have Hl': Ï€ (Â¬ ((Â¬ c) âˆ¨á¶œ t)) { rewrite imp_eq_or;  refine Hl };
    have Hl'': Ï€ ((Â¬ Â¬ c) âˆ§á¶œ Â¬ t) {  apply not_or_and Hl' };
    apply âˆ¨á¶œáµ¢â‚;
    apply nnpp;
    apply âˆ§á¶œâ‚‘â‚ Hl'';
  }
  {
    assume Hr;
    have Hr': Ï€ (Â¬ ((Â¬ Â¬ c) âˆ¨á¶œ e)) { rewrite imp_eq_or;  refine Hr };
    have Hr'': Ï€ ((Â¬ Â¬ Â¬ c) âˆ§á¶œ Â¬ e) {  apply not_or_and Hr' };
    apply âˆ¨á¶œáµ¢â‚‚;
    apply âˆ¨á¶œáµ¢â‚;
    apply âˆ§á¶œâ‚‘â‚‚ Hr''
  };
end;

opaque symbol not_ite2 [c t e] : Ï€ (Â¬ (ite c t e)) â†’ Ï€Ì‡(Â¬ c âŸ‡ Â¬ t âŸ‡ â–©) â‰”
begin
  simplify;
  assume c t e H;
  have H1: Ï€ ((Â¬ (c âŸ¹á¶œ t)) âˆ¨á¶œ (Â¬ ((Â¬ c) âŸ¹á¶œ e))) { apply not_and_or H };
  apply âˆ¨á¶œâ‚‘ H1
  {
    assume Hl;
    have Hl': Ï€ (Â¬ ((Â¬ c) âˆ¨á¶œ t)) { rewrite imp_eq_or;  refine Hl };
    have Hl'': Ï€ ((Â¬ Â¬ c) âˆ§á¶œ Â¬ t) {  apply not_or_and Hl' };
    apply âˆ¨á¶œáµ¢â‚‚;
    apply âˆ¨á¶œáµ¢â‚;
    apply âˆ§á¶œâ‚‘â‚‚ Hl''
  }
  {
    assume Hr;
    have Hr': Ï€ (Â¬ ((Â¬ Â¬ c) âˆ¨á¶œ e)) { rewrite imp_eq_or;  refine Hr };
    have Hr'': Ï€ ((Â¬ Â¬ Â¬ c) âˆ§á¶œ Â¬ e) {  apply not_or_and Hr' };
    apply âˆ¨á¶œáµ¢â‚;
    apply nnpp;
    apply âˆ§á¶œâ‚‘â‚ Hr''
  }
end;

symbol xor a b â‰” ((Â¬ a) âˆ§á¶œ b) âˆ¨á¶œ (a âˆ§á¶œ (Â¬ b));

opaque symbol xor_pos1 [a b] : Ï€Ì‡ (Â¬ (xor a b) âŸ‡ a âŸ‡ b âŸ‡ â–©) â‰”
begin
  assume a b;
  simplify;
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply âŸ¹á¶œáµ¢;
  assume H;
  apply âˆ¨á¶œâ‚‘ H
  { assume Hnab; apply âˆ¨á¶œáµ¢â‚‚;  apply âˆ¨á¶œáµ¢â‚; apply âˆ§á¶œâ‚‘â‚‚ Hnab }
  { assume Hnab; apply âˆ¨á¶œáµ¢â‚; apply âˆ§á¶œâ‚‘â‚ Hnab }
end;

opaque symbol xor_pos2 [a b] : Ï€Ì‡ (Â¬ (xor a b) âŸ‡ Â¬ a âŸ‡ Â¬ b âŸ‡ â–©) â‰”
begin
  assume a b;
  simplify;
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply âŸ¹á¶œáµ¢;
  assume H;
  apply âˆ¨á¶œâ‚‘ H
  { assume Hnab; apply âˆ¨á¶œáµ¢â‚; apply âˆ§á¶œâ‚‘â‚ Hnab }
  { assume Hnab; apply âˆ¨á¶œáµ¢â‚‚;  apply âˆ¨á¶œáµ¢â‚; apply âˆ§á¶œâ‚‘â‚‚ Hnab }
end;

opaque symbol xor_neg1 [a b] : Ï€Ì‡ ((xor a b) âŸ‡ a âŸ‡ Â¬ b âŸ‡ â–©) â‰”
begin
  simplify;
  assume a b;
  rewrite left âˆ¨á¶œ_assoc_eq;
  rewrite or_com;
  rewrite distributive_or;
  apply âˆ§á¶œáµ¢
  {
    rewrite or_identity;
    rewrite left âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚‚;
    rewrite or_com;
    rewrite âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚;
    rewrite or_com;
    apply classic
  }
  {
    rewrite left âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚‚;
    rewrite left âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚‚;
    rewrite or_com;
    rewrite âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚;
    apply classic
  }
end;

opaque symbol xor_neg2 [a b] : Ï€Ì‡ ((xor a b) âŸ‡ Â¬ a âŸ‡ b âŸ‡ â–©) â‰”
begin
  simplify;
  assume a b;
  rewrite left âˆ¨á¶œ_assoc_eq;
  rewrite or_com;
  rewrite distributive_or;
  apply âˆ§á¶œáµ¢
  {
    rewrite left âˆ¨á¶œ_assoc_eq;
    rewrite or_com;
    rewrite distributive_or;
    apply âˆ§á¶œáµ¢
    {
      rewrite left âˆ¨á¶œ_assoc_eq;
      apply âˆ¨á¶œáµ¢â‚‚;
      rewrite or_com;
      apply classic
    }
    {
      rewrite or_com;
      rewrite âˆ¨á¶œ_assoc_eq;
      apply âˆ¨á¶œáµ¢â‚;
      rewrite or_com;
      rewrite left âˆ¨á¶œ_assoc_eq;
      apply âˆ¨á¶œáµ¢â‚‚;
      rewrite or_identity;
      apply classic
    }
  }
  {
    rewrite left âˆ¨á¶œ_assoc_eq;
    rewrite or_com;
    rewrite distributive_or;
    apply âˆ§á¶œáµ¢
    {
      rewrite or_com;
      rewrite âˆ¨á¶œ_assoc_eq;
      apply âˆ¨á¶œáµ¢â‚;
      rewrite âˆ¨á¶œ_assoc_eq;
      apply âˆ¨á¶œáµ¢â‚;
      apply classic
    }
    {
      rewrite or_com;
      rewrite âˆ¨á¶œ_assoc_eq;
      rewrite or_identity;
      apply âˆ¨á¶œáµ¢â‚;
      rewrite or_com;
      rewrite left âˆ¨á¶œ_assoc_eq;
      apply âˆ¨á¶œáµ¢â‚‚;
      apply classic
    }
  }
end;

symbol trivial : Ï€ âŠ¤;

symbol neg_true : Ï€ (Â¬ âŠ¥);

// i â–· ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘n
// j â–· ğœ‘1 , â‹¯ , ğœ‘n
//constant symbol or [a b] : Ï€Ì‡ ((a âˆ¨á¶œ b) âŸ‡ â–©) â†’ Ï€Ì‡ (âˆ¨á¶œ_to_âŸ‡_rw  (a âˆ¨á¶œ b));

opaque symbol not_not x : Ï€Ì‡ ( (Â¬ (Â¬ (Â¬ x))) âŸ‡ x âŸ‡ â–©) â‰”
begin
  assume x;
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply âŸ¹á¶œáµ¢;
  assume H;
  apply âˆ¨á¶œáµ¢â‚;
  apply nnpp H
end;

opaque symbol implies [Ï†â‚ Ï†â‚‚] : Ï€ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚) â†’ Ï€Ì‡ (Â¬ Ï†â‚ âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ HÏ†â‚âŸ¹á¶œÏ†â‚‚;
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply âŸ¹á¶œáµ¢;
  assume Ï€Ï†â‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply âŸ¹á¶œâ‚‘ HÏ†â‚âŸ¹á¶œÏ†â‚‚ Ï€Ï†â‚
end;

opaque symbol not_implies1 [Ï†â‚ Ï†â‚‚] : Ï€ (Â¬ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚)) â†’ Ï€Ì‡ (Ï†â‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ Hnot_Ï†â‚âŸ¹á¶œÏ†â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply âˆ§á¶œâ‚‘â‚ (imply_to_and Hnot_Ï†â‚âŸ¹á¶œÏ†â‚‚)
end;

opaque symbol not_implies2 [Ï†â‚ Ï†â‚‚] : Ï€ (Â¬ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚)) â†’  Ï€Ì‡ (Â¬ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ Hnot_Ï†â‚âŸ¹á¶œÏ†â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply âˆ§á¶œâ‚‘â‚‚ (imply_to_and Hnot_Ï†â‚âŸ¹á¶œÏ†â‚‚)
end;

opaque symbol implies_neg1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚ âŸ‡ Ï†â‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚;
  simplify;
  rewrite left imp_eq_or;
  rewrite âˆ¨á¶œ_assoc_eq;
  apply âˆ¨á¶œáµ¢â‚;
  rewrite .[(Â¬ Ï†â‚) âˆ¨á¶œ Ï†â‚‚] or_com;
  rewrite left âˆ¨á¶œ_assoc_eq;
  apply âˆ¨á¶œáµ¢â‚‚;
  rewrite or_com;
  apply classic
end;

opaque symbol implies_neg2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚ âŸ‡ Â¬ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚;
  simplify;
  rewrite left imp_eq_or;
  rewrite âˆ¨á¶œ_assoc_eq;
  apply âˆ¨á¶œáµ¢â‚;
  rewrite left âˆ¨á¶œ_assoc_eq;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply classic
end;

opaque symbol equiv1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ = Ï†â‚‚ âŸ‡ â–©) â†’ Ï€Ì‡ ((Â¬ Ï†â‚) âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ H1;
  apply âˆ¨á¶œâ‚‘ H1
  {
    assume Hequiv;
    have Hequiv':  Ï€ (Ï†â‚ âŸºá¶œ Ï†â‚‚) { apply âŸº_ext; apply Hequiv };
    apply âŸºá¶œâ‚‘ Hequiv';
    assume H2 H3;
    have Hassoc: Ï€ (((Â¬ Ï†â‚) âˆ¨á¶œ (Ï†â‚‚ âˆ¨á¶œ âŠ¥)) â‡” (((Â¬ Ï†â‚) âˆ¨á¶œ Ï†â‚‚) âˆ¨á¶œ âŠ¥)) {
      apply (@âˆ¨á¶œ_assoc (Â¬ Ï†â‚) Ï†â‚‚ âŠ¥);
    };
    have Hassoc_left: Ï€ ((((Â¬ Ï†â‚) âˆ¨á¶œ Ï†â‚‚) âˆ¨á¶œ âŠ¥)  â‡’  ((Â¬ Ï†â‚) âˆ¨á¶œ (Ï†â‚‚ âˆ¨á¶œ âŠ¥))) {
      refine âˆ§â‚‘â‚‚ Hassoc
    };
    apply Hassoc_left;
    apply âˆ¨á¶œáµ¢â‚;
    apply âŸ¹á¶œ_to_âˆ¨á¶œ;
    apply âŸ¹á¶œáµ¢;
    refine H2;
  }
  {
    assume Hbot;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply Hbot;
  }
end;

opaque symbol equiv2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ = Ï†â‚‚ âŸ‡ â–©)  â†’ Ï€Ì‡ (Ï†â‚ âŸ‡ (Â¬ Ï†â‚‚) âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ H1;
  apply âˆ¨á¶œâ‚‘ H1
  {
    assume Hequiv;
    have Hequiv':  Ï€ (Ï†â‚ âŸºá¶œ Ï†â‚‚) { apply âŸº_ext; apply Hequiv };
    apply âŸºá¶œâ‚‘ Hequiv';
    assume H2 H3;
    have Hassoc: Ï€ ((Ï†â‚ âˆ¨á¶œ ((Â¬ Ï†â‚‚) âˆ¨á¶œ âŠ¥)) â‡” ((Ï†â‚ âˆ¨á¶œ (Â¬ Ï†â‚‚)) âˆ¨á¶œ âŠ¥)) {
      apply (@âˆ¨á¶œ_assoc Ï†â‚ (Â¬ Ï†â‚‚) âŠ¥);
    };
    have Hassoc_left: Ï€ (((Ï†â‚ âˆ¨á¶œ (Â¬ Ï†â‚‚)) âˆ¨á¶œ âŠ¥)  â‡’  (Ï†â‚ âˆ¨á¶œ ((Â¬ Ï†â‚‚) âˆ¨á¶œ âŠ¥))) {
      refine âˆ§â‚‘â‚‚ Hassoc
    };
    apply Hassoc_left;
    apply âˆ¨á¶œáµ¢â‚;
    apply âˆ¨á¶œ_com;
    apply âŸ¹á¶œ_to_âˆ¨á¶œ;
    apply âŸ¹á¶œáµ¢;
    refine H3;
  }
  {
    assume Hbot;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply Hbot;
  }
end;

opaque symbol equiv_pos1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Â¬ (Ï†â‚ = Ï†â‚‚)) âŸ‡ Ï†â‚ âŸ‡ Â¬ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  simplify;
  assume p q;
  apply imply_to_or;
  apply âŸ¹á¶œáµ¢;
  assume Heq;
  rewrite Heq;
  rewrite âˆ¨á¶œ_assoc_eq;
  apply âˆ¨á¶œáµ¢â‚;
  apply classic
end;

opaque symbol equiv_pos2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Â¬ (Ï†â‚ = Ï†â‚‚)) âŸ‡ (Â¬ Ï†â‚) âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  simplify;
  assume p q;
  apply imply_to_or;
  apply âŸ¹á¶œáµ¢;
  assume Heq;
  rewrite or_identity;
  apply âˆ¨á¶œ_com;
  rewrite Heq;
  apply classic
end;

opaque symbol equiv_neg1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Ï†â‚ = Ï†â‚‚) âŸ‡ Â¬ Ï†â‚ âŸ‡ Â¬ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  simplify;
  assume p q;
  rewrite or_identity;
  apply âˆ¨á¶œ_com;
  rewrite left âˆ¨á¶œ_assoc_eq;
  apply imply_to_or;
  apply âŸ¹á¶œáµ¢;
  assume Hp;
  apply imply_to_or;
  apply âŸ¹á¶œáµ¢;
  assume Hq;
  apply prop_ext;
  apply âˆ§á¶œáµ¢
  { apply âŸ¹á¶œáµ¢; assume Hp'; apply Hq }
  { apply âŸ¹á¶œáµ¢; assume Hq'; apply Hp }
end;

opaque symbol equiv_neg2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Ï†â‚ = Ï†â‚‚) âŸ‡ Ï†â‚ âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  simplify;
  assume p q;
  rewrite or_identity;
  rewrite left iff_equiv_eq;
  apply âˆ¨á¶œ_com;
  simplify;
  rewrite distributive_or; //(p âˆ¨á¶œ q) (p âŸ¹á¶œ q) (q âŸ¹á¶œ p);
  apply âˆ§á¶œáµ¢
  {
    rewrite left imp_eq_or;
    rewrite left âˆ¨á¶œ_assoc_eq;
    rewrite .[(Â¬ p) âˆ¨á¶œ q] or_com;
    rewrite  .[q âˆ¨á¶œ (q âˆ¨á¶œ Â¬ p)] âˆ¨á¶œ_assoc_eq;
    rewrite or_idempotent;
    rewrite .[q âˆ¨á¶œ (Â¬ p)] or_com;
    rewrite âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚;
    apply classic
  }
  {
    rewrite left imp_eq_or;
    rewrite âˆ¨á¶œ_assoc_eq;
    rewrite .[p âˆ¨á¶œ q] or_com;
    rewrite left .[((q âˆ¨á¶œ p) âˆ¨á¶œ Â¬ q)] âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚;
    rewrite .[p âˆ¨á¶œ Â¬ q] or_com;
    rewrite âˆ¨á¶œ_assoc_eq;
    apply âˆ¨á¶œáµ¢â‚;
    apply classic
  }
end;

opaque symbol implies_pos [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Â¬ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚)) âŸ‡ Â¬ Ï†â‚ âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  simplify;
  assume x y;
  rewrite or_identity;
  rewrite left imp_eq_or;
  apply âˆ¨á¶œ_com;
  apply classic
end;

opaque symbol subproof1 [Ï†â‚ Ïˆ] : Ï€ Ï†â‚ â†’ Ï€ Ïˆ â†’ Ï€Ì‡ ((Â¬ Ï†â‚) âŸ‡ Ïˆ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ïˆ HÏ†â‚ HÏˆ;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply HÏˆ
end;

opaque symbol subproof2 [Ï†â‚ Ï†â‚‚ Ïˆ] : Ï€ Ï†â‚ â†’ Ï€ Ï†â‚‚ â†’ Ï€ Ïˆ â†’ Ï€Ì‡ ((Â¬ Ï†â‚) âŸ‡ (Â¬ Ï†â‚‚) âŸ‡ Ïˆ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ Ïˆ HÏ†â‚ HÏ†â‚‚ HÏˆ;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply HÏˆ;
end;

opaque symbol subproof3 [Ï†â‚ Ï†â‚‚ Ï†â‚ƒ Ïˆ] : Ï€ Ï†â‚ â†’ Ï€ Ï†â‚‚ â†’ Ï€ Ï†â‚ƒ â†’ Ï€ Ïˆ â†’ Ï€Ì‡ ((Â¬ Ï†â‚) âŸ‡ (Â¬ Ï†â‚‚) âŸ‡ (Â¬ Ï†â‚ƒ) âŸ‡ Ïˆ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ Ï†â‚ƒ Ïˆ HÏ†â‚ HÏ†â‚‚ HÏ†â‚ƒ HÏˆ;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply HÏˆ;
end;

opaque symbol subproof4 [Ï†â‚ Ï†â‚‚ Ï†â‚ƒ Ï†â‚„ Ïˆ] : Ï€ Ï†â‚ â†’ Ï€ Ï†â‚‚ â†’ Ï€ Ï†â‚ƒ â†’ Ï€ Ï†â‚„ â†’ Ï€ Ïˆ â†’ Ï€Ì‡ ((Â¬ Ï†â‚) âŸ‡ (Â¬ Ï†â‚‚) âŸ‡ (Â¬ Ï†â‚ƒ) âŸ‡ (Â¬ Ï†â‚„) âŸ‡ Ïˆ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ Ï†â‚ƒ Ï†â‚„ Ïˆ HÏ†â‚ HÏ†â‚‚ HÏ†â‚ƒ HÏ†â‚„ HÏˆ;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply HÏˆ;
end;

constant symbol forall_inst1 p x: Ï€ (Â¬ (`âˆ€á¶œ x', p x') âˆ¨á¶œ (p x));

constant symbol forall_inst2 p x y: Ï€ (Â¬ (`âˆ€á¶œ a, `âˆ€á¶œ b, p a b) âˆ¨á¶œ (p x y));

opaque symbol forall_inst3 [p] x y z: Ï€ ((Â¬ (`âˆ€á¶œ a, `âˆ€á¶œ b, `âˆ€á¶œ c, p a b c)) âˆ¨á¶œ ((p x y z) âˆ¨á¶œ âŠ¥)) â‰”
begin
  assume p x y z;
  apply imply_to_or;
  apply âŸ¹á¶œáµ¢;
  assume H;
  apply âˆ¨á¶œáµ¢â‚ (âˆ€á¶œâ‚‘ z (âˆ€á¶œâ‚‘ y (âˆ€á¶œâ‚‘ x H)))
end;

// # In Predicate
// 
// The In predicate works with ğ”¹ instead of Prop to avoid making critical pairs wiht other rules.
// If we use Prop, then we will need a rule
// â–· `$x âŸºá¶œ $x â†ª âŠ¤` to replace `eq $x $h` and, 
// â–· `_ âˆ¨á¶œ âŠ¤ â†ª âŠ¤` for `or _ true â†ª true`. 
//
// This choice will create a critical pair reduction which would make any clause in the goal
// that contain the litteral âŠ¤ unable to compute the predicate In.
//
// To illustrate this case, consider the goal:
// âŠ¢ (ğœ‘1 âˆ¨á¶œ â‹¯ âˆ¨á¶œ âŠ¤ â‹¯ âˆ¨á¶œ ğœ‘ğ‘›), Â¬ğœ‘k
// then we will have
// âŠ¢ In_âˆ¨á¶œ ğœ‘k (ğœ‘1 âˆ¨á¶œ â‹¯ âˆ¨á¶œ âŠ¤ â‹¯ âˆ¨á¶œ ğœ‘ğ‘›)  (apply or_neg)
// âŠ¢ In_âˆ¨á¶œ ğœ‘k âŠ¤  (by simplification)
// we got stuck...

// Decidable equality in ğ”¹.
// Symbol = has been declared constant, it cannot be used as the head of a rewrite rule LHS.
// So we create our own eq symbol.
symbol eq: Prop â†’ Prop â†’ ğ”¹;
rule eq $x $x â†ª true;

sequential symbol In_âˆ§á¶œ: Prop â†’ Prop â†’ ğ”¹;
rule In_âˆ§á¶œ $x ($h âˆ§á¶œ $tl) â†ª (eq $x $h)  Stdlib.Bool.or (In_âˆ§á¶œ $x $tl)
with In_âˆ§á¶œ $x âŠ¤ â†ª false;

sequential symbol In_âˆ¨á¶œ: Prop â†’ Prop â†’ ğ”¹;
rule In_âˆ¨á¶œ $x ($h âˆ¨á¶œ $tl) â†ª (eq $x $h) Stdlib.Bool.or (In_âˆ¨á¶œ $x $tl)
with In_âˆ¨á¶œ _ âŠ¥ â†ª false;

// and_pos: Â¬(ğœ‘1 âˆ§ â€¦ âˆ§ ğœ‘ğ‘›), ğœ‘ğ‘˜
symbol and_pos [Ï†â‚__Ï†â‚™ Ï†â‚–]:  Ï€ ((In_âˆ§á¶œ Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Â¬ Ï†â‚__Ï†â‚™ âŸ‡ Ï†â‚– âŸ‡ â–©);

opaque symbol test_and_pos: Ï€Ì‡ ((Â¬ (a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ d âˆ§á¶œ âŠ¤)) âŸ‡ d âŸ‡ â–©) â‰”
begin
  apply and_pos;
  reflexivity;
end; 

// and_neg:  (ğœ‘1 âˆ§ â‹¯ âˆ§ ğœ‘ğ‘›), Â¬ğœ‘1, â€¦ , Â¬ğœ‘ğ‘›
sequential symbol and_neg_r: Prop â†’ Clause â†’ ğ”¹; 
rule and_neg_r ($x âˆ§á¶œ $tl) (($x â‡’ âŠ¥) âŸ‡ $tl2) â†ª and_neg_r $tl $tl2
with and_neg_r âŠ¤ â–© â†ª true; 

symbol and_neg [l1 l2]: Ï€ (and_neg_r l1 l2 = true) â†’ Ï€Ì‡ (l1 âŸ‡ l2);

opaque symbol test_and_neg: Ï€Ì‡ ((a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ d âˆ§á¶œ âŠ¤) âŸ‡ (Â¬ a) âŸ‡ (Â¬ b) âŸ‡ (Â¬ c) âŸ‡ (Â¬ d) âŸ‡ â–©) â‰”
begin
  apply and_neg;
  reflexivity;
end; 

// or_pos:  Â¬(ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›), ğœ‘1 , â€¦ , ğœ‘ğ‘›
sequential symbol or_pos_r: Prop â†’ Clause â†’ ğ”¹; 
rule or_pos_r ($x âˆ¨á¶œ $tl) ($x âŸ‡ $tl2) â†ª or_pos_r $tl $tl2
with or_pos_r âŠ¥ â–© â†ª true; 

symbol or_pos [l1 l2]: Ï€ (or_pos_r l1 l2 = true) â†’ Ï€Ì‡ (Â¬ l1 âŸ‡ l2);

opaque symbol test_or_pos: Ï€Ì‡ (Â¬ (a âˆ¨á¶œ b âˆ¨á¶œ c âˆ¨á¶œ d âˆ¨á¶œ âŠ¥) âŸ‡ a âŸ‡ b âŸ‡ c âŸ‡ d âŸ‡ â–©) â‰”
begin
  apply or_pos; reflexivity
end; 

// or_neg:
// i. â–· (ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›), Â¬ğœ‘k
symbol or_neg [Ï†â‚__Ï†â‚™] Ï†â‚–:  Ï€ ((In_âˆ¨á¶œ Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Ï†â‚__Ï†â‚™ âŸ‡ Â¬ Ï†â‚– âŸ‡ â–©);

opaque symbol test_or_neg: Ï€Ì‡ (((a âˆ¨á¶œ b âˆ¨á¶œ c âˆ¨á¶œ d âˆ¨á¶œ âŠ¥)) âŸ‡ Â¬ c âŸ‡ â–©) â‰”
begin
  apply or_neg; reflexivity
end; 

// not_or:
// i. â–· Â¬(ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›)
// j. â–· Â¬ğœ‘ğ‘˜
symbol not_or [Ï†â‚–] Ï†â‚__Ï†â‚™: Ï€ (Â¬ Ï†â‚__Ï†â‚™) â†’ Ï€ ((In_âˆ¨á¶œ Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Â¬ Ï†â‚– âŸ‡ â–©);

opaque symbol identity_âŠ¥ [x] : Ï€ (x âˆ¨á¶œ âŠ¥) â†’ Ï€ x â‰”
begin
  assume x H;
  apply âˆ¨á¶œâ‚‘ H
  { assume Hx; apply Hx } { assume HâŠ¥; apply âŠ¥â‚‘; apply HâŠ¥ }
end;

opaque symbol test_not_or: Ï€Ì‡ (Â¬ (a âˆ¨á¶œ b âˆ¨á¶œ c âˆ¨á¶œ d âˆ¨á¶œ âŠ¥) âŸ‡ â–©) â†’ Ï€Ì‡ (Â¬ c âŸ‡ â–©) â‰”
begin
  assume H; // i
  apply not_or (a âˆ¨á¶œ b âˆ¨á¶œ c âˆ¨á¶œ d âˆ¨á¶œ âŠ¥)
    { apply Ï€Ì‡â‚—; apply H }
    { reflexivity }
end;

// not_and:
// i. â–· Â¬(ğœ‘1 âˆ§ â€¦ âˆ§ ğœ‘ğ‘›)
// j. â–· Â¬ğœ‘1, â€¦ , Â¬ğœ‘ğ‘›
sequential symbol not_and_r: Prop â†’ Clause â†’ ğ”¹; 
rule not_and_r ($x âˆ§á¶œ $tl) (($x â‡’ âŠ¥) âŸ‡ $tl2) â†ª not_and_r $tl $tl2
with not_and_r âŠ¤ â–© â†ª true; 

symbol not_and [l1 l2]: Ï€ (Â¬ l1) â†’ Ï€ (not_and_r l1 l2 = true) â†’ Ï€Ì‡ l2;

opaque symbol test_not_and: Ï€Ì‡ (Â¬ (a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ d âˆ§á¶œ âŠ¤) âŸ‡ â–©) â†’ Ï€Ì‡ (Â¬ a âŸ‡ Â¬ b âŸ‡ Â¬ c âŸ‡ Â¬ d âŸ‡ â–©) â‰”
begin
  assume t1;
  apply not_and (Ï€Ì‡â‚— t1);
  reflexivity
end; 

// and:
// i. â–· (ğœ‘1 âˆ§ â‹¯ âˆ§ ğœ‘ğ‘›)
// j. â–· ğœ‘ğ‘˜
symbol and [Ï†â‚–] Ï†â‚__Ï†â‚™ : Ï€ ((In_âˆ§á¶œ Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Ï†â‚__Ï†â‚™ âŸ‡ â–©)  â†’ Ï€Ì‡ (Ï†â‚– âŸ‡ â–©);

opaque symbol test_and:  Ï€Ì‡ ((a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ âŠ¤) âŸ‡ â–©) â†’  Ï€Ì‡ (c âŸ‡ â–©) â‰”
begin
  assume t1;
  apply and ((a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ âŠ¤)) { reflexivity } { apply t1  };
end;

opaque symbol resolutionâ‚— x a b: Ï€Ì‡ (x âŸ‡ a) â†’ Ï€Ì‡ ((Â¬ x) âŸ‡ b) â†’ Ï€Ì‡ (a ++ b) â‰” begin
  assume x a b H1 H2;
  apply âŸ‡â‚‘ H1 {
    assume Hx;
    apply âŸ‡â‚‘ H2 {
      assume Hnx;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œâ‚‘ Hx { assume Hpi_x;  apply âˆ¨á¶œâ‚‘ Hnx { assume Hpi_nx;  apply Â¬â‚‘ Hpi_nx Hpi_x }  {  assume Hbot; apply âŠ¥â‚‘;  apply Hbot  } } { assume Hbot; apply âŠ¥â‚‘;  apply Hbot  };
    } {
      assume Hb;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚‚;
      apply Hb;
    }
  } {
    assume Ha;
    apply âŸ‡â‚‘ H2 {
      assume Hnx;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚;
      apply Ha
    } {
      assume Hb;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚;
      apply Ha
    }
  };
end;

opaque symbol resolutionáµ£ x a b: Ï€Ì‡ ((Â¬ x) âŸ‡ a) â†’ Ï€Ì‡ (x âŸ‡ b) â†’ Ï€Ì‡ (a ++ b) â‰” begin
  assume x a b H1 H2;
  apply âŸ‡â‚‘ H1 {
    assume Hnx;
    apply âŸ‡â‚‘ H2 {
      assume Hx;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œâ‚‘ Hx { assume Hpi_x;  apply âˆ¨á¶œâ‚‘ Hnx { assume Hpi_nx;  apply Â¬â‚‘ Hpi_nx Hpi_x }  {  assume Hbot; apply âŠ¥â‚‘;  apply Hbot  } } { assume Hbot; apply âŠ¥â‚‘;  apply Hbot  };
    } {
      assume Hb;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚‚;
      apply Hb;
    }
  } {
    assume Ha;
    apply âŸ‡â‚‘ H2 {
      assume Hnx;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚;
      apply Ha
    } {
      assume Hb;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚;
      apply Ha
    }
  };
end;

opaque symbol bind_âˆƒ [p q]: (Î  x, Ï€ (p x = q x))  â†’ Ï€ ((`âˆƒá¶œ x, p x) = (`âˆƒá¶œ x, q x)) â‰”
begin
  assume p q H;
  apply prop_ext;
  apply âˆ§á¶œáµ¢ 
  {
    apply âŸ¹á¶œáµ¢;
    assume H1;
    apply âˆƒá¶œâ‚‘ _ H1;
    assume x Hpx;
    apply âˆƒá¶œáµ¢ _ x;
    rewrite left (H x);
    apply Hpx;
  }
  {
    apply âŸ¹á¶œáµ¢;
    assume H1;
    apply âˆƒá¶œâ‚‘ _ H1;
    assume x Hqx;
    apply âˆƒá¶œáµ¢ _ x;
    rewrite (H x);
    apply Hqx;
  };
end;

opaque symbol bind_âˆ€ [a p q]: (Î  (x: Ï„ a), Ï€ (p x = q x))  â†’ Ï€ ((`âˆ€á¶œ (x: Ï„ a), p x) = (`âˆ€á¶œ (x: Ï„ a), q x)) â‰”
begin
  assume a p q H;
  apply prop_ext;
  apply âˆ§á¶œáµ¢ 
  {
    apply âŸ¹á¶œáµ¢;
    assume H1;
    apply âˆ€á¶œáµ¢ _;
    assume x;
    have Hpx: Ï€ (p x) { apply âˆ€á¶œâ‚‘ x H1 };
    rewrite left (H x);
    apply Hpx;
  }
  {
    apply âŸ¹á¶œáµ¢;
    assume H1;
    apply âˆ€á¶œáµ¢ _;
    assume x;
    have Hqx: Ï€ (q x) { apply âˆ€á¶œâ‚‘ x H1 };
    rewrite (H x);
    apply Hqx;
  };
end;

symbol distinct [a] : ğ•ƒ a â†’ Prop;
