require open Stdlib.Prop;
require open Stdlib.FOL;
require open Stdlib.Set;
require open Stdlib.Nat;
require open Stdlib.Eq;
require open Stdlib.Bool;
require open Stdlib.List;

symbol o: Set;
rule Ï„ o â†ª Prop;

// # Clause
// Clauses are encoded with list Ã  la Church Encoding.
// This encoding is necessary because Inductive type in Lambdapi
// could not live in Prop.
constant symbol Clause : TYPE;

// Nil
symbol â–© : Clause; 
// Cons
injective symbol âŸ‡: Prop â†’ Clause â†’ Clause;
notation âŸ‡ infix right 2;
// Append of two clause list
sequential symbol ++ : Clause â†’ Clause â†’ Clause; notation ++ infix right 3;

rule â–© ++ $m â†ª $m
with ($x âŸ‡ $l) ++ $m â†ª $x âŸ‡ ($l ++ $m);

constant symbol Clause_ind:  Î  P: (Clause â†’ Prop), Î  l,
  Ï€ (P â–©) â†’
  (Î  x: Prop, Î  l: Clause, Ï€ (P l) â†’ Ï€ (P (x âŸ‡ l))) â†’
  Ï€ (P l);

// some sanity checks
assert x y z âŠ¢ x ++ y ++ z â‰¡ x ++ (y ++ z);
assert x l m âŠ¢ x âŸ‡ l ++ m â‰¡ x âŸ‡ (l ++ m);

injective symbol Â¬á¶œ : Prop â†’ Prop; notation Â¬á¶œ prefix 8;

// FIXME: 
constant symbol Â¬á¶œâ‚‘ [p q] : Ï€ (Â¬á¶œ p) â†’ Ï€ p â†’ Ï€ q;

injective symbol âˆ¨á¶œ : Prop â†’ Prop â†’ Prop; notation âˆ¨á¶œ infix right 12;

// Introduction and elimination for classical or
constant symbol âˆ¨á¶œáµ¢â‚ [p q] : Ï€ p â†’ Ï€ (p âˆ¨á¶œ q);
constant symbol âˆ¨á¶œáµ¢â‚‚ [p q] : Ï€ q â†’ Ï€ (p âˆ¨á¶œ q);
symbol âˆ¨á¶œâ‚‘ [p q r] : Ï€ (p âˆ¨á¶œ q) â†’ (Ï€ p â†’ Ï€ r) â†’ (Ï€ q â†’ Ï€ r) â†’ Ï€ r;

symbol âˆ¨á¶œ_com [x y] : Ï€ (x âˆ¨á¶œ y) â†’ Ï€ (y âˆ¨á¶œ x) â‰”
begin
  assume x y hxy;
  apply âˆ¨á¶œâ‚‘ hxy
  { assume hx; apply âˆ¨á¶œáµ¢â‚‚; apply hx }
  { assume hy; apply âˆ¨á¶œáµ¢â‚; apply hy }
end;


sequential symbol âˆ¨á¶œ_to_âŸ‡_rw: Prop â†’ Clause;
rule âˆ¨á¶œ_to_âŸ‡_rw ($x âˆ¨á¶œ $y) â†ª $x âŸ‡ (âˆ¨á¶œ_to_âŸ‡_rw $y)
with âˆ¨á¶œ_to_âŸ‡_rw âŠ¥ â†ª  â–©;

sequential symbol âŸ‡_to_âˆ¨á¶œ_rw: Clause â†’ Prop;
rule âŸ‡_to_âˆ¨á¶œ_rw ($x âŸ‡ $y) â†ª $x âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw $y)
with âŸ‡_to_âˆ¨á¶œ_rw â–© â†ª âŠ¥;

assert a b âŠ¢ âŸ‡_to_âˆ¨á¶œ_rw (a âŸ‡ b âŸ‡ â–©) â‰¡ a âˆ¨á¶œ b âˆ¨á¶œ âŠ¥;
assert a b c âŠ¢ âˆ¨á¶œ_to_âŸ‡_rw (a âˆ¨á¶œ b âˆ¨á¶œ âŠ¥ âˆ¨á¶œ c âˆ¨á¶œ âŠ¥) â‰¡ (a âŸ‡ b âŸ‡ âŠ¥ âŸ‡ c âŸ‡ â–©);

injective symbol Ï€Ì‡ c: TYPE â‰” Ï€ (âŸ‡_to_âˆ¨á¶œ_rw c);

opaque symbol Ï€Ì‡â‚— [a] : Ï€Ì‡ (a âŸ‡ â–©)  â†’ Ï€ a â‰”
begin
  assume a Hcl_a;
  apply @âˆ¨á¶œâ‚‘ a âŠ¥ a
  { apply Hcl_a }
  { assume Ha; apply Ha }
  { assume False; apply âŠ¥â‚‘ False };
end;

// opaque injective symbol Ï€á¶œ p : TYPE â‰” Ï€ (Â¬ (Â¬ p));

// Introduction rule for Clause
// construct `p âŸ‡ q` from a clause with only `p`
opaque symbol âŸ‡áµ¢â‚ [p q] : Ï€Ì‡ (p âŸ‡ â–©) â†’ Ï€Ì‡ (p âŸ‡ q) â‰”
begin
  assume p q Hp;
  apply âˆ¨á¶œâ‚‘ Hp
  { assume Hpi_p; apply âˆ¨á¶œáµ¢â‚;  apply Hpi_p }
  { assume Hbot; apply âŠ¥â‚‘; apply Hbot }
end;

// construct `p âŸ‡ q` from a proof of `p`
opaque symbol âŸ‡áµ¢â‚' [p q] : Ï€ p â†’ Ï€Ì‡ (p âŸ‡ q) â‰”
begin 
  assume p q Hp; apply âˆ¨á¶œáµ¢â‚; apply Hp
end;

opaque symbol âŸ‡áµ¢â‚‚ [p q] : Ï€Ì‡ q â†’ Ï€Ì‡ (p âŸ‡ q) â‰”
begin
  assume p q Hq; apply âˆ¨á¶œáµ¢â‚‚; apply Hq
end;

// Elimination rule for clause
opaque symbol âŸ‡â‚‘ [p q r] : Ï€Ì‡ (p âŸ‡ q) â†’ (Ï€Ì‡ (p âŸ‡ â–©) â†’ Ï€Ì‡ r) â†’ (Ï€Ì‡ q â†’ Ï€Ì‡ r) â†’ Ï€Ì‡ r â‰”
begin
  assume p q r Hpq Hpr Hqr;
  apply âˆ¨á¶œâ‚‘ Hpq
  { assume Hp; apply Hpr (âˆ¨á¶œáµ¢â‚ Hp) }
  { assume Hq; apply Hqr Hq }
end;

opaque  symbol âˆ¨á¶œ_assoc [x y z] : Ï€ ((x âˆ¨á¶œ (y âˆ¨á¶œ z)) â‡” ((x âˆ¨á¶œ y) âˆ¨á¶œ z)) â‰”
begin
  assume x y z;
  simplify;
  apply âˆ§áµ¢
  {
    assume Hxyz;
    apply âˆ¨á¶œâ‚‘ Hxyz
    { assume Hx;  apply âˆ¨á¶œáµ¢â‚; apply âˆ¨á¶œáµ¢â‚; apply Hx }
    {
      assume Hyz; apply âˆ¨á¶œâ‚‘ Hyz
      { assume Hy;  apply âˆ¨á¶œáµ¢â‚;  apply âˆ¨á¶œáµ¢â‚‚; apply Hy }
      { assume Hz;  apply âˆ¨á¶œáµ¢â‚‚; apply Hz }
    }
  }
  {
    assume Hxyz;
    apply âˆ¨á¶œâ‚‘ Hxyz
    {
      assume Hxy; apply âˆ¨á¶œâ‚‘ Hxy
      { assume Hx; apply âˆ¨á¶œáµ¢â‚; apply Hx }
      { assume Hy; apply âˆ¨á¶œáµ¢â‚‚; apply âˆ¨á¶œáµ¢â‚; apply Hy }
    }
    { assume Hz; apply âˆ¨á¶œáµ¢â‚‚; apply âˆ¨á¶œáµ¢â‚‚; apply Hz }
  }
end;

opaque symbol ++_to_âˆ¨á¶œ a b : Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) â‡” ((âŸ‡_to_âˆ¨á¶œ_rw a) âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw b))) â‰”
begin
  assume a b;
  apply Clause_ind (Î» u, (âŸ‡_to_âˆ¨á¶œ_rw (u ++ b)) â‡” ((âŸ‡_to_âˆ¨á¶œ_rw u) âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw b))) a
    {
      simplify;
      apply âˆ§áµ¢
        { assume H; apply âˆ¨á¶œáµ¢â‚‚; apply H }
        {
          assume H;
          apply âˆ¨á¶œâ‚‘ H { assume HâŠ¥; apply âŠ¥â‚‘; apply HâŠ¥ } { assume H1;  apply H1}
        }
    }
    {
      simplify;
      assume x l Hir;
      apply âˆ§áµ¢
      { assume H; apply âˆ¨á¶œâ‚‘ H
        {
          assume Hx;
          apply âˆ¨á¶œáµ¢â‚;
          apply âˆ¨á¶œáµ¢â‚;
          apply Hx;
        }
        {
          assume Hl++b;
          have tmp: Ï€ ((x âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b))  â‡’ ((x âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw l) âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)) {
            refine âˆ§â‚‘â‚ âˆ¨á¶œ_assoc;
          };
          apply tmp;
          apply âˆ¨á¶œâ‚‘ H
          {
            assume Hx;  apply âˆ¨á¶œáµ¢â‚; apply Hx
          }
          {
            assume Hl_or_b;
            apply âˆ¨á¶œáµ¢â‚‚;
            have HirLeft: Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw (l ++ b) â‡’ (âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b))) {
                refine (âˆ§â‚‘â‚ Hir);
            };
            apply HirLeft;
            apply Hl++b
          }
        }
      }
      {
        assume H;
        apply âˆ¨á¶œâ‚‘ H {
            assume H1;
            apply âˆ¨á¶œâ‚‘ H1 {
              assume Hx;
              apply âˆ¨á¶œáµ¢â‚;
              apply Hx;
            } {
              assume H2;
              apply âˆ¨á¶œáµ¢â‚‚;
              have tmp: Ï€ (((âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b) â‡’ âŸ‡_to_âˆ¨á¶œ_rw (l ++ b))) {
                refine (âˆ§â‚‘â‚‚ Hir);
              };
              apply tmp;
              apply âˆ¨á¶œáµ¢â‚;
              apply H2
            }
        } {
          assume H1;
          apply âˆ¨á¶œáµ¢â‚‚;
          have tmp: Ï€ (((âŸ‡_to_âˆ¨á¶œ_rw l âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b) â‡’ âŸ‡_to_âˆ¨á¶œ_rw (l ++ b))) {
                refine (âˆ§â‚‘â‚‚ Hir);
              };
              apply tmp;
              apply âˆ¨á¶œáµ¢â‚‚;
              apply H1
        }        
      }
    }
end;
 
injective symbol âˆ§á¶œ : Prop â†’ Prop â†’ Prop; notation âˆ§á¶œ infix right 10;
constant symbol âˆ§á¶œáµ¢ [p q] : Ï€ p â†’ Ï€ q â†’ Ï€ (p âˆ§á¶œ q);
symbol âˆ§á¶œâ‚‘â‚ [p q] : Ï€ (p âˆ§á¶œ q) â†’ Ï€ p;
symbol âˆ§á¶œâ‚‘â‚‚ [p q] : Ï€ (p âˆ§á¶œ q) â†’ Ï€ q;

injective symbol âŸ¹á¶œ: Prop â†’ Prop â†’ Prop;
notation âŸ¹á¶œ infix right 7;

constant symbol âŸ¹á¶œ_right [a b] : (Ï€ a â†’ Ï€ b) â†’ Ï€ (a âŸ¹á¶œ b);

constant symbol âŸ¹á¶œ_to_âˆ¨á¶œ [a b] : Ï€ (a âŸ¹á¶œ b) â†’ Ï€ ((Â¬á¶œ a) âˆ¨á¶œ b);

constant symbol âˆ¨á¶œ_to_âŸ¹á¶œ [a b] : Ï€ ((Â¬á¶œ a) âˆ¨á¶œ b) â†’ Ï€ (a âŸ¹á¶œ b);

injective symbol âŸºá¶œ: Prop â†’ Prop â†’ Prop;
notation âŸºá¶œ infix right 6;

constant symbol âŸºá¶œáµ¢ [p q] : (Ï€ p â†’ Ï€  q) â†’  (Ï€ q â†’ Ï€ p) â†’ Ï€ (p âŸºá¶œ q);

constant symbol âŸºá¶œâ‚‘ [p q r] : Ï€ (p âŸºá¶œ q) â†’  ((Ï€ p â†’ Ï€ q) â†’ (Ï€ q â†’ Ï€ p) â†’ Ï€ r) â†’ Ï€ r;

opaque symbol âŸºá¶œ_refl [p] : Ï€ (p âŸºá¶œ p) â‰”
begin
  assume p;
  apply âŸºá¶œáµ¢
  {assume Hp; apply Hp}
  {assume Hp; apply Hp}
end;

opaque symbol âŸºá¶œ_sym [p q] : Ï€ (p âŸºá¶œ q) â†’ Ï€ (q âŸºá¶œ p) â‰”
begin
  assume p q Hp_equiv_q;
  apply âŸºá¶œáµ¢
  {
    assume Hq;
    apply âŸºá¶œâ‚‘ Hp_equiv_q;
    assume Hpq Hqp;
    apply Hqp;
    apply Hq;
  }
  {
    assume Hp;
    apply âŸºá¶œâ‚‘ Hp_equiv_q;
    assume Hpq Hqp;
    apply Hpq;
    apply Hp;
  }
end;

opaque symbol âŸºá¶œ_trans [p q r] : Ï€ (p âŸºá¶œ q) â†’ Ï€ (q âŸºá¶œ r) â†’ Ï€ (p âŸºá¶œ r) â‰”
begin
  assume p q r Hpq Hqr;
  apply âŸºá¶œáµ¢
  {
    assume Hp;
    apply âŸºá¶œâ‚‘ Hpq;
    assume Hp_imp_q Hq_imp_p;
    apply âŸºá¶œâ‚‘ Hqr;
    assume Hq_imp_r Hr_imp_q;
    apply Hq_imp_r (Hp_imp_q Hp );
  }
  {
    assume Hr;
    apply âŸºá¶œâ‚‘ Hpq;
    assume Hp_imp_q Hq_imp_p;
    apply âŸºá¶œâ‚‘ Hqr;
    assume Hq_imp_r Hr_imp_q;
    apply Hq_imp_p (Hr_imp_q Hr );
  };
end;

opaque symbol feq_equiv (f:Ï„ o â†’ Ï„ o) [x x':Ï„ o] : Ï€(f x = f x') â†’ Ï€(f x âŸºá¶œ f x') â‰”
begin
  assume f x x' Hfeq;
  rewrite Hfeq;
  apply âŸºá¶œ_refl
end;

// axiom Prop equality is equivalent to x equivalent  
constant symbol eq_equiv [x y: Prop]: Ï€ (x âŸºá¶œ y) â†’ Ï€ (x = y);

opaque symbol cong [x x'] (f: Prop â†’ Prop): Ï€(x âŸºá¶œ x') â†’ Ï€(f x âŸºá¶œ f x') â‰”
begin
  assume x y f Hequivxy;
  rewrite eq_equiv Hequivxy;
  apply âŸºá¶œ_refl
end;

opaque symbol cong2 [x y x' y'] (f: Prop â†’ Prop â†’ Prop): Ï€ (x âŸºá¶œ x') â†’ Ï€ (y âŸºá¶œ y') â†’ Ï€((f x y) âŸºá¶œ (f x' y')) â‰”
begin
  assume x x' y y' f Hequivxx' Hequivyy';
  rewrite eq_equiv Hequivxx';
  rewrite eq_equiv Hequivyy';
  apply âŸºá¶œ_refl
end;

constant symbol âˆ€á¶œ [a] : (Ï„ a â†’ Prop) â†’ Prop; notation âˆ€á¶œ quantifier;
constant symbol âˆ€á¶œáµ¢ [p] : (Î  x, Ï€ (p x)) â†’ Ï€ (âˆ€á¶œ p);
constant symbol âˆ€á¶œâ‚‘ [p] x : Ï€ (âˆ€á¶œ p) â†’ Ï€ (p x);

constant symbol âˆƒá¶œ [a] : (Ï„ a â†’ Prop) â†’ Prop; notation âˆƒá¶œ quantifier;
constant symbol âˆƒá¶œáµ¢ [a] p (x:Ï„ a) : Ï€ (p x) â†’ Ï€ (âˆƒá¶œ p);
symbol âˆƒá¶œâ‚‘ [a] p : Ï€ (âˆƒá¶œ p) â†’ Î  q, (Î  x:Ï„ a, Ï€ (p x) â†’ Ï€ q) â†’ Ï€ q;

rule âˆƒá¶œâ‚‘ _ (âˆƒá¶œáµ¢ _ $x $px) _ $f â†ª $f $x $px;

constant symbol classic [p] : Ï€ (p âˆ¨á¶œ Â¬á¶œ p);

constant symbol nnpp [p] : Ï€ (Â¬á¶œ Â¬á¶œ p) â†’ Ï€ p;

//TODO: Need classical definition
opaque symbol pnnp [p] : Ï€ p â†’ Ï€ (Â¬á¶œ Â¬á¶œ p) â‰”
begin admit end;

constant symbol âŸ¹á¶œáµ¢ [p q] : (Ï€ p â†’ Ï€ q) â†’ Ï€ (p âŸ¹á¶œ q);

constant symbol âŸ¹á¶œâ‚‘ [p q] : Ï€ (p âŸ¹á¶œ q) â†’ Ï€ p â†’ Ï€ q;

constant symbol imply_to_or[p q] : Ï€ (p âŸ¹á¶œ q) â†’ Ï€ ((Â¬á¶œ p) âˆ¨á¶œ q);

constant symbol imply_to_and [p q] : Ï€ (Â¬á¶œ (p âŸ¹á¶œ q)) â†’ Ï€ (p âˆ§á¶œ (Â¬á¶œ q));

// Hilbert epsilon operator/choice
constant symbol Ïµ  [a]: (Ï„ a â†’ Prop) â†’ Ï„ a; notation Ïµ quantifier;

constant symbol Ïµáµ¢ x p : Ï€ (p x) â†’ Ï€ (p (Ïµ p));
constant symbol Ïµ_det [p q]: Î  x, Ï€ ((p x) âŸºá¶œ (q x)) â†’ Ï€ (Ïµ p = Ïµ q);

opaque symbol Ïµ_equiv_âˆƒá¶œ [p] : Ï€ ((`âˆƒá¶œ x, p x) âŸºá¶œ (p (`Ïµ x, p x))) â‰”
begin
  assume p;
  apply âŸºá¶œáµ¢
  {
    assume Hexist;
    apply âˆƒá¶œâ‚‘ _ Hexist;
    assume x Hpx;
    apply Ïµáµ¢ x (Î» u, p u);
    apply Hpx
  }
  {
    assume Heps;
    apply âˆƒá¶œáµ¢ _ (`Ïµ x, p x);
    apply Heps
  } 
end;

symbol ite c t e â‰” (c âŸ¹á¶œ t) âˆ§á¶œ (Â¬á¶œ c âŸ¹á¶œ e);
constant symbol iteI : Î  c t e p,
                           (Ï€ c â†’ Ï€ (p t))
                         â†’ ((Ï€ c â†’ Ï€ âŠ¥) â†’ Ï€ (p e))
                         â†’ Ï€ (p (ite c t e));                         

opaque symbol âˆ¨á¶œ_to_âŸ‡ a b: Ï€ (a âˆ¨á¶œ b) â†’ Ï€Ì‡ (a âŸ‡ b âŸ‡ â–©) â‰”
begin
  assume a b Haorb;
  apply âˆ¨á¶œâ‚‘ Haorb
  { assume Ha;  apply âˆ¨á¶œáµ¢â‚; apply Ha }
  {  assume Hb; apply âˆ¨á¶œáµ¢â‚‚; simplify; apply âˆ¨á¶œáµ¢â‚; apply Hb }
end; 

opaque symbol ite1 [c t e] : Ï€ (ite c t e) â†’ Ï€Ì‡ (c âŸ‡ e âŸ‡ â–©) â‰”
begin
  assume c t e Hite;
  apply âˆ¨á¶œ_to_âŸ‡;
  have H: Ï€ (Â¬á¶œ c âŸ¹á¶œ e) { apply âˆ§á¶œâ‚‘â‚‚ Hite }; 
  have tmp: Ï€ (c âˆ¨á¶œ e âŸºá¶œ  (Â¬á¶œ Â¬á¶œ c) âˆ¨á¶œ e) { 
    apply âŸºá¶œáµ¢
    {
      assume H1;
      apply âˆ¨á¶œâ‚‘ H1
      { assume Hc; apply âˆ¨á¶œáµ¢â‚; apply pnnp; apply Hc }
      { assume He; apply âˆ¨á¶œáµ¢â‚‚;  apply He };
    }
    {
      assume H1; 
      apply âˆ¨á¶œâ‚‘ H1
      { assume Hc; apply âˆ¨á¶œáµ¢â‚; apply nnpp; apply Hc }
      { assume He; apply âˆ¨á¶œáµ¢â‚‚;  apply He };
    };
  };
  apply âŸºá¶œâ‚‘ tmp;
  assume H1 H2;
  apply H2;
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply H
end;

opaque symbol ite2 [c t e] : Ï€ (ite c t e) â†’ Ï€Ì‡ ((Â¬á¶œ c) âŸ‡ t âŸ‡ â–©) â‰”
begin
  assume c t e Hite;
  apply âˆ¨á¶œ_to_âŸ‡;
  have H: Ï€ (c âŸ¹á¶œ t) { apply âˆ§á¶œâ‚‘â‚ Hite };
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply H
end;

opaque symbol ite_pos1 [c t e] : Ï€Ì‡ (Â¬á¶œ (ite c t e) âŸ‡ c âŸ‡ e âŸ‡ â–©) â‰”
begin
  assume c t e;
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply âŸ¹á¶œáµ¢;
  assume H;
  apply ite1 H;
end;

opaque symbol ite_pos2 [c t e] : Ï€Ì‡ (Â¬á¶œ (ite c t e) âŸ‡ Â¬á¶œ c âŸ‡ t âŸ‡ â–©) â‰”
begin
  assume c t e;
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply âŸ¹á¶œáµ¢;
  assume H;
  apply ite2 H;
end;

opaque symbol ite_neg1 [c t e] : Ï€Ì‡ ((ite c t e) âŸ‡ c âŸ‡ Â¬á¶œ e âŸ‡ â–©) â‰”
begin
  admit
end;

opaque symbol ite_neg2 [c t e] : Ï€Ì‡ ((ite c t e) âŸ‡ Â¬á¶œ c âŸ‡ Â¬á¶œ t âŸ‡ â–©) â‰”
begin
  admit
end;

opaque symbol not_ite1 [c t e] : Ï€ (Â¬á¶œ (ite c t e)) â†’ Ï€Ì‡( c âŸ‡ Â¬á¶œ e âŸ‡ â–©) â‰”
begin
  assume c t e H;
  admit
end;

opaque symbol not_ite2 [c t e] : Ï€ (Â¬á¶œ (ite c t e)) â†’ Ï€Ì‡(Â¬á¶œ c âŸ‡ Â¬á¶œ t âŸ‡ â–©) â‰”
begin
  assume c t e H;
  admit
end;

symbol xor a b â‰” ((Â¬á¶œ a) âˆ§á¶œ b) âˆ¨á¶œ (a âˆ§á¶œ (Â¬á¶œ b));

opaque symbol xor_pos1 [a b] : Ï€Ì‡ (Â¬á¶œ (xor a b) âŸ‡ a âŸ‡ b âŸ‡ â–©) â‰”
begin
  assume a b;
  simplify;
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply âŸ¹á¶œáµ¢;
  assume H;
  apply âˆ¨á¶œâ‚‘ H
  { assume Hnab; apply âˆ¨á¶œáµ¢â‚‚;  apply âˆ¨á¶œáµ¢â‚; apply âˆ§á¶œâ‚‘â‚‚ Hnab }
  { assume Hnab; apply âˆ¨á¶œáµ¢â‚; apply âˆ§á¶œâ‚‘â‚ Hnab }
end;

opaque symbol xor_pos2 [a b] : Ï€Ì‡ (Â¬á¶œ (xor a b) âŸ‡ Â¬á¶œ a âŸ‡ Â¬á¶œ b âŸ‡ â–©) â‰”
begin
  assume a b;
  simplify;
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply âŸ¹á¶œáµ¢;
  assume H;
  apply âˆ¨á¶œâ‚‘ H
  { assume Hnab; apply âˆ¨á¶œáµ¢â‚; apply âˆ§á¶œâ‚‘â‚ Hnab }
  { assume Hnab; apply âˆ¨á¶œáµ¢â‚‚;  apply âˆ¨á¶œáµ¢â‚; apply âˆ§á¶œâ‚‘â‚‚ Hnab }
end;

opaque symbol xor_neg1 [a b] : Ï€Ì‡ ((xor a b) âŸ‡ a âŸ‡ Â¬á¶œ b âŸ‡ â–©) â‰”
begin
  simplify;
  admit
end;

opaque symbol xor_neg2 [a b] : Ï€Ì‡ ((xor a b) âŸ‡ Â¬á¶œ a âŸ‡ b âŸ‡ â–©) â‰”
begin
  admit
end;

symbol trivial : Ï€ âŠ¤;

symbol neg_true : Ï€ (Â¬á¶œ âŠ¥);

// i â–· ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘n
// j â–· ğœ‘1 , â‹¯ , ğœ‘n
//constant symbol or [a b] : Ï€Ì‡ ((a âˆ¨á¶œ b) âŸ‡ â–©) â†’ Ï€Ì‡ (âˆ¨á¶œ_to_âŸ‡_rw  (a âˆ¨á¶œ b));

opaque symbol not_not x : Ï€Ì‡ ( (Â¬á¶œ (Â¬á¶œ (Â¬á¶œ x))) âŸ‡ x âŸ‡ â–©) â‰”
begin
  assume x;
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply âŸ¹á¶œáµ¢;
  assume H;
  apply âˆ¨á¶œáµ¢â‚;
  apply nnpp H
end;

opaque symbol implies [Ï†â‚ Ï†â‚‚] : Ï€ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚) â†’ Ï€Ì‡ (Â¬á¶œ Ï†â‚ âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ HÏ†â‚âŸ¹á¶œÏ†â‚‚;
  apply âŸ¹á¶œ_to_âˆ¨á¶œ;
  apply âŸ¹á¶œáµ¢;
  assume Ï€Ï†â‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply âŸ¹á¶œâ‚‘ HÏ†â‚âŸ¹á¶œÏ†â‚‚ Ï€Ï†â‚
end;

opaque symbol not_implies1 [Ï†â‚ Ï†â‚‚] : Ï€ (Â¬á¶œ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚)) â†’ Ï€Ì‡ (Ï†â‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ Hnot_Ï†â‚âŸ¹á¶œÏ†â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply âˆ§á¶œâ‚‘â‚ (imply_to_and Hnot_Ï†â‚âŸ¹á¶œÏ†â‚‚)
end;

opaque symbol not_implies2 [Ï†â‚ Ï†â‚‚] : Ï€ (Â¬á¶œ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚)) â†’  Ï€Ì‡ (Â¬á¶œ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ Hnot_Ï†â‚âŸ¹á¶œÏ†â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply âˆ§á¶œâ‚‘â‚‚ (imply_to_and Hnot_Ï†â‚âŸ¹á¶œÏ†â‚‚)
end;

opaque symbol implies_neg1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚ âŸ‡ Ï†â‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚;
  have Hassoc: Ï€ (((Ï†â‚ âŸ¹á¶œ Ï†â‚‚) âˆ¨á¶œ (Ï†â‚ âˆ¨á¶œ âŠ¥)) â‡” (((Ï†â‚ âŸ¹á¶œ Ï†â‚‚) âˆ¨á¶œ Ï†â‚) âˆ¨á¶œ âŠ¥)) {
    apply âˆ¨á¶œ_assoc
  };
  have Lassoc: Ï€ ((((Ï†â‚ âŸ¹á¶œ Ï†â‚‚) âˆ¨á¶œ Ï†â‚) âˆ¨á¶œ âŠ¥) â‡’ ((Ï†â‚ âŸ¹á¶œ Ï†â‚‚) âˆ¨á¶œ (Ï†â‚ âˆ¨á¶œ âŠ¥))) {
    apply âˆ§â‚‘â‚‚ Hassoc;
  };
  apply Lassoc;
  apply âˆ¨á¶œáµ¢â‚;
  admit //FIXME: finish the proof with âŸ¹á¶œ_to_âˆ¨á¶œ and EM
end;

constant symbol implies_neg2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚ âŸ‡ Â¬á¶œ Ï†â‚‚ âŸ‡ â–©);

opaque symbol equiv1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ âŸºá¶œ Ï†â‚‚ âŸ‡ â–©) â†’ Ï€Ì‡ ((Â¬á¶œ Ï†â‚) âŸ‡ Ï†â‚‚ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ H1;
  apply âˆ¨á¶œâ‚‘ H1
  {
    assume Hequiv;
    apply âŸºá¶œâ‚‘ Hequiv;
    assume H2 H3;
    simplify;
    have Hassoc: Ï€ (((Â¬á¶œ Ï†â‚) âˆ¨á¶œ (Ï†â‚‚ âˆ¨á¶œ âŠ¥)) â‡” (((Â¬á¶œ Ï†â‚) âˆ¨á¶œ Ï†â‚‚) âˆ¨á¶œ âŠ¥)) {
      apply (@âˆ¨á¶œ_assoc (Â¬á¶œ Ï†â‚) Ï†â‚‚ âŠ¥);
    };
    have Hassoc_left: Ï€ ((((Â¬á¶œ Ï†â‚) âˆ¨á¶œ Ï†â‚‚) âˆ¨á¶œ âŠ¥)  â‡’  ((Â¬á¶œ Ï†â‚) âˆ¨á¶œ (Ï†â‚‚ âˆ¨á¶œ âŠ¥))) {
      refine âˆ§â‚‘â‚‚ Hassoc
    };
    apply Hassoc_left;
    apply âˆ¨á¶œáµ¢â‚;
    apply âŸ¹á¶œ_to_âˆ¨á¶œ;
    apply âŸ¹á¶œáµ¢;
    refine H2;
  }
  {
    assume Hbot;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply Hbot;
  }
end;

opaque symbol equiv2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ (Ï†â‚ âŸºá¶œ Ï†â‚‚ âŸ‡ â–©)  â†’ Ï€Ì‡ (Ï†â‚ âŸ‡ (Â¬á¶œ Ï†â‚‚) âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ H1;
  apply âˆ¨á¶œâ‚‘ H1
  {
    assume Hequiv;
    apply âŸºá¶œâ‚‘ Hequiv;
    assume H2 H3;
    simplify;
    have Hassoc: Ï€ ((Ï†â‚ âˆ¨á¶œ ((Â¬á¶œ Ï†â‚‚) âˆ¨á¶œ âŠ¥)) â‡” ((Ï†â‚ âˆ¨á¶œ (Â¬á¶œ Ï†â‚‚)) âˆ¨á¶œ âŠ¥)) {
      apply (@âˆ¨á¶œ_assoc Ï†â‚ (Â¬á¶œ Ï†â‚‚) âŠ¥);
    };
    have Hassoc_left: Ï€ (((Ï†â‚ âˆ¨á¶œ (Â¬á¶œ Ï†â‚‚)) âˆ¨á¶œ âŠ¥)  â‡’  (Ï†â‚ âˆ¨á¶œ ((Â¬á¶œ Ï†â‚‚) âˆ¨á¶œ âŠ¥))) {
      refine âˆ§â‚‘â‚‚ Hassoc
    };
    apply Hassoc_left;
    apply âˆ¨á¶œáµ¢â‚;
    apply âˆ¨á¶œ_com;
    apply âŸ¹á¶œ_to_âˆ¨á¶œ;
    apply âŸ¹á¶œáµ¢;
    refine H3;
  }
  {
    assume Hbot;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply âˆ¨á¶œáµ¢â‚‚;
    apply Hbot;
  }
end;

constant symbol equiv_pos1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Â¬á¶œ (Ï†â‚ âŸºá¶œ Ï†â‚‚)) âŸ‡ Ï†â‚ âŸ‡ Â¬á¶œ Ï†â‚‚ âŸ‡ â–©);

constant symbol equiv_pos2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Â¬á¶œ (Ï†â‚ âŸºá¶œ Ï†â‚‚)) âŸ‡ (Â¬á¶œ Ï†â‚) âŸ‡ Ï†â‚‚ âŸ‡ â–©);

constant symbol equiv_neg1 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Ï†â‚ âŸºá¶œ Ï†â‚‚) âŸ‡ Â¬á¶œ Ï†â‚ âŸ‡ Â¬á¶œ Ï†â‚‚ âŸ‡ â–©);

constant symbol equiv_neg2 [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Ï†â‚ âŸºá¶œ Ï†â‚‚) âŸ‡ Ï†â‚ âŸ‡ Ï†â‚‚ âŸ‡ â–©);

constant symbol implies_pos [Ï†â‚ Ï†â‚‚] : Ï€Ì‡ ((Â¬á¶œ (Ï†â‚ âŸ¹á¶œ Ï†â‚‚)) âŸ‡ Â¬á¶œ Ï†â‚ âŸ‡ Ï†â‚‚ âŸ‡ â–©);

opaque symbol subproof1 [Ï†â‚ Ïˆ] : Ï€ Ï†â‚ â†’ Ï€ Ïˆ â†’ Ï€Ì‡ ((Â¬á¶œ Ï†â‚) âŸ‡ Ïˆ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ïˆ HÏ†â‚ HÏˆ;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply HÏˆ
end;

opaque symbol subproof2 [Ï†â‚ Ï†â‚‚ Ïˆ] : Ï€ Ï†â‚ â†’ Ï€ Ï†â‚‚ â†’ Ï€ Ïˆ â†’ Ï€Ì‡ ((Â¬á¶œ Ï†â‚) âŸ‡ (Â¬á¶œ Ï†â‚‚) âŸ‡ Ïˆ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ Ïˆ HÏ†â‚ HÏ†â‚‚ HÏˆ;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply HÏˆ;
end;

opaque symbol subproof3 [Ï†â‚ Ï†â‚‚ Ï†â‚ƒ Ïˆ] : Ï€ Ï†â‚ â†’ Ï€ Ï†â‚‚ â†’ Ï€ Ï†â‚ƒ â†’ Ï€ Ïˆ â†’ Ï€Ì‡ ((Â¬á¶œ Ï†â‚) âŸ‡ (Â¬á¶œ Ï†â‚‚) âŸ‡ (Â¬á¶œ Ï†â‚ƒ) âŸ‡ Ïˆ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ Ï†â‚ƒ Ïˆ HÏ†â‚ HÏ†â‚‚ HÏ†â‚ƒ HÏˆ;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply HÏˆ;
end;

opaque symbol subproof4 [Ï†â‚ Ï†â‚‚ Ï†â‚ƒ Ï†â‚„ Ïˆ] : Ï€ Ï†â‚ â†’ Ï€ Ï†â‚‚ â†’ Ï€ Ï†â‚ƒ â†’ Ï€ Ï†â‚„ â†’ Ï€ Ïˆ â†’ Ï€Ì‡ ((Â¬á¶œ Ï†â‚) âŸ‡ (Â¬á¶œ Ï†â‚‚) âŸ‡ (Â¬á¶œ Ï†â‚ƒ) âŸ‡ (Â¬á¶œ Ï†â‚„) âŸ‡ Ïˆ âŸ‡ â–©) â‰”
begin
  assume Ï†â‚ Ï†â‚‚ Ï†â‚ƒ Ï†â‚„ Ïˆ HÏ†â‚ HÏ†â‚‚ HÏ†â‚ƒ HÏ†â‚„ HÏˆ;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚‚;
  apply âˆ¨á¶œáµ¢â‚;
  apply HÏˆ;
end;

constant symbol forall_inst1 p x: Ï€ (Â¬á¶œ (`âˆ€á¶œ x', p x') âˆ¨á¶œ (p x));

constant symbol forall_inst2 p x y: Ï€ (Â¬á¶œ (`âˆ€á¶œ a, `âˆ€á¶œ b, p a b) âˆ¨á¶œ (p x y));

opaque symbol forall_inst3 [p] x y z: Ï€ ((Â¬á¶œ (`âˆ€á¶œ a, `âˆ€á¶œ b, `âˆ€á¶œ c, p a b c)) âˆ¨á¶œ ((p x y z) âˆ¨á¶œ âŠ¥)) â‰”
begin
  assume p x y z;
  apply imply_to_or;
  apply âŸ¹á¶œáµ¢;
  assume H;
  apply âˆ¨á¶œáµ¢â‚ (âˆ€á¶œâ‚‘ z (âˆ€á¶œâ‚‘ y (âˆ€á¶œâ‚‘ x H)))
end;

print forall_inst3;

// symbol morgan [p q] : Ï€ (Â¬á¶œ (p âˆ¨á¶œ q)) â†’ Ï€ (Â¬á¶œ p âˆ§á¶œ Â¬á¶œ q);

// sequential symbol morgan_l: Prop â†’ Prop;
// sequential symbol âˆ§_to_âˆ¨: Prop â†’ Prop;

// rule morgan_l  (Â¬á¶œ $hd) âˆ§á¶œ $tl â†ª Â¬á¶œ ( $hd âˆ¨á¶œ (âˆ§_to_âˆ¨  $tl));
// rule âˆ§_to_âˆ¨ (Â¬á¶œ $hd) âˆ§á¶œ $tl â†ª $hd âˆ¨á¶œ (âˆ§_to_âˆ¨ $tl)
// with âˆ§_to_âˆ¨ âŠ¤ â†ª âŠ¤;

// sequential symbol morgan_r: Prop â†’ Prop;
// sequential symbol âŸ‡_to_âˆ§: Prop â†’ Prop;

// rule morgan_r  Â¬á¶œ ($hd âˆ¨á¶œ $tl) â†ª Â¬á¶œ $hd âˆ§á¶œ (âŸ‡_to_âˆ§ $tl);
// rule âŸ‡_to_âˆ§ ($a âˆ¨á¶œ $b) â†ª  Â¬á¶œ $a âˆ§á¶œ (âŸ‡_to_âˆ§ $b)
// with âŸ‡_to_âˆ§ âŠ¥ â†ª âŠ¤;

// # In Predicate
// 
// The In predicate works with ğ”¹ instead of Prop to avoid making critical pairs wiht other rules.
// If we use Prop, then we will need a rule
// â–· `$x âŸºá¶œ $x â†ª âŠ¤` to replace `eq $x $h` and, 
// â–· `_ âˆ¨á¶œ âŠ¤ â†ª âŠ¤` for `or _ true â†ª true`. 
//
// This choice will create a critical pair reduction which would make any clause in the goal
// that contain the litteral âŠ¤ unable to compute the predicate In.
//
// To illustrate this case, consider the goal:
// âŠ¢ (ğœ‘1 âˆ¨á¶œ â‹¯ âˆ¨á¶œ âŠ¤ â‹¯ âˆ¨á¶œ ğœ‘ğ‘›), Â¬ğœ‘k
// then we will have
// âŠ¢ In_âˆ¨á¶œ ğœ‘k (ğœ‘1 âˆ¨á¶œ â‹¯ âˆ¨á¶œ âŠ¤ â‹¯ âˆ¨á¶œ ğœ‘ğ‘›)  (apply or_neg)
// âŠ¢ In_âˆ¨á¶œ ğœ‘k âŠ¤  (by simplification)
// we got stuck...


symbol ğ‘° [a]: â„• â†’ Ï„ a; 
symbol code_S : Set;
symbol S â‰” Ï„ code_S;
symbol a: Prop â‰” ğ‘° 0;

symbol b: Prop â‰” ğ‘° 1;
symbol c: Prop â‰” ğ‘° 2;
symbol d: Prop â‰” ğ‘° 3;
symbol e: Prop â‰” ğ‘° 4;

// Decidable equality in ğ”¹.
// Symbol = has been declared constant, it cannot be used as the head of a rewrite rule LHS.
// So we create our own eq symbol.
symbol eq [a]: Ï„ a â†’ Ï„ a â†’ ğ”¹;
// constant symbol ind_eq [a] : Î  p0: (ğ”¹ â†’ Prop), Ï€ (p0 true) â†’ Ï€ (p0 false) â†’ Î  x, Î  y: Ï„ a, Ï€ (p0 (eq x y));

rule eq (ğ‘° 0) (ğ‘° 0) â†ª true
with eq (@ğ‘° $a ($x +1)) (@ğ‘° $b ($y +1)) â†ª eq (@ğ‘° $a $x) (@ğ‘° $b $y)
with eq (ğ‘° 0) (ğ‘° (_ +1)) â†ª false
with eq (ğ‘° (_ +1)) (ğ‘° 0) â†ª false;

// and_neg:  (ğœ‘1 âˆ§ â‹¯ âˆ§ ğœ‘ğ‘›), Â¬ğœ‘1, â€¦ , Â¬ğœ‘ğ‘›
symbol and_neg_r: Prop â†’ Clause â†’ ğ”¹; 
rule and_neg_r âŠ¥ (_ âŸ‡ _) â†ª false
with and_neg_r âŠ¤ (_ âŸ‡ _) â†ª false
with and_neg_r (Â¬á¶œ _) (_ âŸ‡ _) â†ª false
with and_neg_r (_ âˆ¨á¶œ _) (_ âŸ‡ _) â†ª false
with and_neg_r ($x âˆ§á¶œ _) (âŠ¥ âŸ‡ _) â†ª if (eq $x âŠ¥) true false
with and_neg_r ($x âˆ§á¶œ _) (âŠ¤ âŸ‡ _) â†ª if (eq $x âŠ¤) true false
with and_neg_r ($x âˆ§á¶œ _) ((_ âˆ¨á¶œ _) âŸ‡ _) â†ª false
with and_neg_r ($x âˆ§á¶œ _) ((_ âˆ§á¶œ _) âŸ‡ _) â†ª false
with and_neg_r ($x âˆ§á¶œ $tl) (Â¬á¶œ $y âŸ‡ $tl2) â†ª if (eq $x $y)  (and_neg_r $tl $tl2) false
with and_neg_r âŠ¥ â–© â†ª false
with and_neg_r (_ âˆ§á¶œ _) â–© â†ª false
with and_neg_r (_ âˆ¨á¶œ _) â–© â†ª false
with and_neg_r (Â¬á¶œ _) â–© â†ª false
with and_neg_r âŠ¤ â–© â†ª true;

//constant symbol ifâ‚‘ c t e p : Ï€ (p (if c t e)) â†’ Ï€ (Â¬ c) â†’ Ï€ (p e);

// opaque symbol iteE c t e p : Prf (p (ite c t e)) â†’ Prf (Â¬ c) â†’ Prf (p e) â‰”
// {  apply iteE q true false (Î» z, z) qite pnq };

symbol and_neg [l1 l2]: Ï€ (and_neg_r l1 l2 = true) â†’ Ï€Ì‡ (l1 âŸ‡ l2);

symbol ind_Prop :
Î  p: (Prop â†’ Prop),
Ï€ (p âŠ¤) â†’
Ï€ (p âŠ¥) â†’
(Î  x: Prop, Ï€ (p x) â†’ Ï€ (p (Â¬á¶œ x))) â†’
(Î  x: Prop, Ï€ (p x) â†’ Î  y: Prop, Ï€ (p y) â†’ Ï€ (p (x âˆ§á¶œ y))) â†’
(Î  x: Prop, Ï€ (p x) â†’ Î  y: Prop, Ï€ (p y) â†’ Ï€ (p (x âˆ¨á¶œ y))) â†’
Î  x: Prop, Ï€ (p x);


symbol and_neg_proof [l1 l2] : Ï€ (and_neg_r l1 l2 = true âŸ¹á¶œ (l1 âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw l2)) â‰”
begin
  assume l1 l2;
  apply ind_Prop (Î» l1', and_neg_r l1' l2 = true âŸ¹á¶œ âŸ‡_to_âˆ¨á¶œ_rw (l1' âŸ‡ l2))
  {
    apply Clause_ind (Î» l2', (and_neg_r âŠ¤ l2' = true) âŸ¹á¶œ âŸ‡_to_âˆ¨á¶œ_rw (âŠ¤ âŸ‡ l2')) l2
    {
      apply âŸ¹á¶œáµ¢;
      assume HReflTrue;
      apply âˆ¨á¶œáµ¢â‚;
      apply trivial
    }
    {
      assume x l2' IH; simplify; apply âŸ¹á¶œáµ¢; assume HfalseEqTrue; apply âŠ¥â‚‘; apply falseâ‰ true HfalseEqTrue
    }
  }
  {
    admit
  }
  {
    admit
  }
  {
    assume x Hx y Hy;
    apply Clause_ind (Î» l2', (and_neg_r (x âˆ§á¶œ y) l2' = true) âŸ¹á¶œ âŸ‡_to_âˆ¨á¶œ_rw ((x âˆ§á¶œ y) âŸ‡ l2')) l2
    { admit }
    {
      assume x' l2' IHClause;
      apply ind_Prop (Î» u, (and_neg_r (x âˆ§á¶œ y) (u âŸ‡ l2') = true) âŸ¹á¶œ âŸ‡_to_âˆ¨á¶œ_rw ((x âˆ§á¶œ y) âŸ‡ (u âŸ‡ l2')))
      { admit }
      { admit }
      { 
        assume x1 IHProp;
        simplify;
        apply ind_ğ”¹_eq (Î» u, ((if (u) (and_neg_r y l2') false) = true) âŸ¹á¶œ ((x âˆ§á¶œ y) âˆ¨á¶œ ((Â¬á¶œ x1) âˆ¨á¶œ (âŸ‡_to_âˆ¨á¶œ_rw l2')))) (eq x x1)
        {
          assume Htrue;
          rewrite Htrue;
          simplify;
          apply âŸ¹á¶œáµ¢;
          assume H2;
          admit
        }
        {
          assume HEqfalse;
          rewrite HEqfalse;
          simplify;
          apply âŸ¹á¶œáµ¢;
          assume HfalseEqTrue;
          apply âŠ¥â‚‘;
          apply falseâ‰ true HfalseEqTrue;
        };
      }
      { admit }
      { admit }
    }
  }
  {
    admit
  }
end;

opaque symbol test_and_neg: Ï€Ì‡ ((a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ d âˆ§á¶œ âŠ¤) âŸ‡ Â¬á¶œ a âŸ‡ Â¬á¶œ b âŸ‡ Â¬á¶œ c âŸ‡ Â¬á¶œ d âŸ‡ â–©) â‰”
begin
  apply and_neg; reflexivity
end; 



sequential symbol In_âˆ§á¶œ: Prop â†’ Prop â†’ ğ”¹;
rule In_âˆ§á¶œ $x ($h âˆ§á¶œ $tl) â†ª (eq $x $h)  Stdlib.Bool.or (In_âˆ§á¶œ $x $tl)
with In_âˆ§á¶œ $x âŠ¤ â†ª false;

sequential symbol In_âˆ¨á¶œ: Prop â†’ Prop â†’ ğ”¹;
rule In_âˆ¨á¶œ $x ($h âˆ¨á¶œ $tl) â†ª (eq $x $h) Stdlib.Bool.or (In_âˆ¨á¶œ $x $tl)
with In_âˆ¨á¶œ _ âŠ¥ â†ª false;

// and_pos: Â¬(ğœ‘1 âˆ§ â€¦ âˆ§ ğœ‘ğ‘›), ğœ‘ğ‘˜
symbol and_pos [Ï†â‚__Ï†â‚™ Ï†â‚–]:  Ï€ ((In_âˆ§á¶œ Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Â¬á¶œ Ï†â‚__Ï†â‚™ âŸ‡ Ï†â‚– âŸ‡ â–©);

opaque symbol test_and_pos: Ï€Ì‡ ((Â¬á¶œ (a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ d âˆ§á¶œ âŠ¤)) âŸ‡ d âŸ‡ â–©) â‰”
begin
  apply and_pos;
  reflexivity;
end; 



// or_pos:  Â¬(ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›), ğœ‘1 , â€¦ , ğœ‘ğ‘›
sequential symbol or_pos_r: Prop â†’ Clause â†’ ğ”¹; 
rule or_pos_r ($x âˆ¨á¶œ $tl) ($x âŸ‡ $tl2) â†ª or_pos_r $tl $tl2
with or_pos_r âŠ¥ â–© â†ª true; 

symbol or_pos [l1 l2]: Ï€ (or_pos_r l1 l2 = true) â†’ Ï€Ì‡ (Â¬á¶œ l1 âŸ‡ l2);

opaque symbol test_or_pos: Ï€Ì‡ (Â¬á¶œ (a âˆ¨á¶œ b âˆ¨á¶œ c âˆ¨á¶œ d âˆ¨á¶œ âŠ¥) âŸ‡ a âŸ‡ b âŸ‡ c âŸ‡ d âŸ‡ â–©) â‰”
begin
  apply or_pos; reflexivity
end; 

// or_neg:
// i. â–· (ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›), Â¬ğœ‘k
symbol or_neg [Ï†â‚__Ï†â‚™] Ï†â‚–:  Ï€ ((In_âˆ¨á¶œ Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Ï†â‚__Ï†â‚™ âŸ‡ Â¬á¶œ Ï†â‚– âŸ‡ â–©);

opaque symbol test_or_neg: Ï€Ì‡ (((a âˆ¨á¶œ b âˆ¨á¶œ c âˆ¨á¶œ d âˆ¨á¶œ âŠ¥)) âŸ‡ Â¬á¶œ c âŸ‡ â–©) â‰”
begin
  apply or_neg; reflexivity
end; 

// not_or:
// i. â–· Â¬(ğœ‘1 âˆ¨ â‹¯ âˆ¨ ğœ‘ğ‘›)
// j. â–· Â¬ğœ‘ğ‘˜
symbol not_or [Ï†â‚–] Ï†â‚__Ï†â‚™: Ï€ (Â¬á¶œ Ï†â‚__Ï†â‚™) â†’ Ï€ ((In_âˆ¨á¶œ Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Â¬á¶œ Ï†â‚– âŸ‡ â–©);

opaque symbol identity_âŠ¥ [x] : Ï€ (x âˆ¨á¶œ âŠ¥) â†’ Ï€ x â‰”
begin
  assume x H;
  apply âˆ¨á¶œâ‚‘ H
  { assume Hx; apply Hx } { assume HâŠ¥; apply âŠ¥â‚‘; apply HâŠ¥ }
end;

opaque symbol test_not_or: Ï€Ì‡ (Â¬á¶œ (a âˆ¨á¶œ b âˆ¨á¶œ c âˆ¨á¶œ d âˆ¨á¶œ âŠ¥) âŸ‡ â–©) â†’ Ï€Ì‡ (Â¬á¶œ c âŸ‡ â–©) â‰”
begin
  assume H; // i
  apply not_or (a âˆ¨á¶œ b âˆ¨á¶œ c âˆ¨á¶œ d âˆ¨á¶œ âŠ¥)
    { apply Ï€Ì‡â‚—; apply H }
    { reflexivity }
end;

// not_and:
// i. â–· Â¬(ğœ‘1 âˆ§ â€¦ âˆ§ ğœ‘ğ‘›)
// j. â–· Â¬ğœ‘1, â€¦ , Â¬ğœ‘ğ‘›
sequential symbol not_and_r: Prop â†’ Clause â†’ ğ”¹; 
rule not_and_r ($x âˆ§á¶œ $tl) (Â¬á¶œ $x âŸ‡ $tl2) â†ª not_and_r $tl $tl2
with not_and_r âŠ¤ â–© â†ª true; 

symbol not_and [l1 l2]: Ï€ (Â¬á¶œ l1) â†’ Ï€ (not_and_r l1 l2 = true) â†’ Ï€Ì‡ l2;

opaque symbol test_not_and: Ï€Ì‡ (Â¬á¶œ (a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ d âˆ§á¶œ âŠ¤) âŸ‡ â–©) â†’ Ï€Ì‡ (Â¬á¶œ a âŸ‡ Â¬á¶œ b âŸ‡ Â¬á¶œ c âŸ‡ Â¬á¶œ d âŸ‡ â–©) â‰”
begin
  assume t1;
  apply not_and (Ï€Ì‡â‚— t1);
  reflexivity
end; 

// and:
// i. â–· (ğœ‘1 âˆ§ â‹¯ âˆ§ ğœ‘ğ‘›)
// j. â–· ğœ‘ğ‘˜
symbol and [Ï†â‚–] Ï†â‚__Ï†â‚™ : Ï€ ((In_âˆ§á¶œ Ï†â‚– Ï†â‚__Ï†â‚™) = true) â†’ Ï€Ì‡ (Ï†â‚__Ï†â‚™ âŸ‡ â–©)  â†’ Ï€Ì‡ (Ï†â‚– âŸ‡ â–©);

opaque symbol test_and:  Ï€Ì‡ ((a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ âŠ¤) âŸ‡ â–©) â†’  Ï€Ì‡ (c âŸ‡ â–©) â‰”
begin
  assume t1;
  apply and ((a âˆ§á¶œ b âˆ§á¶œ c âˆ§á¶œ âŠ¤)) { reflexivity } { apply t1  };
end;

opaque symbol resolutionâ‚— x a b: Ï€Ì‡ (x âŸ‡ a) â†’ Ï€Ì‡ ((Â¬á¶œ x) âŸ‡ b) â†’ Ï€Ì‡ (a ++ b) â‰” begin
  assume x a b H1 H2;
  apply âŸ‡â‚‘ H1 {
    assume Hx;
    apply âŸ‡â‚‘ H2 {
      assume Hnx;
      simplify;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œâ‚‘ Hx { assume Hpi_x;  apply âˆ¨á¶œâ‚‘ Hnx { assume Hpi_nx;  apply Â¬á¶œâ‚‘ Hpi_nx Hpi_x }  {  assume Hbot; apply âŠ¥â‚‘;  apply Hbot  } } { assume Hbot; apply âŠ¥â‚‘;  apply Hbot  };
    } {
      assume Hb;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚‚;
      apply Hb;
    }
  } {
    assume Ha;
    apply âŸ‡â‚‘ H2 {
      assume Hnx;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚;
      apply Ha
    } {
      assume Hb;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚;
      apply Ha
    }
  };
end;

opaque symbol resolutionáµ£ x a b: Ï€Ì‡ ((Â¬á¶œ x) âŸ‡ a) â†’ Ï€Ì‡ (x âŸ‡ b) â†’ Ï€Ì‡ (a ++ b) â‰” begin
  assume x a b H1 H2;
  apply âŸ‡â‚‘ H1 {
    assume Hnx;
    apply âŸ‡â‚‘ H2 {
      assume Hx;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œâ‚‘ Hx { assume Hpi_x;  apply âˆ¨á¶œâ‚‘ Hnx { assume Hpi_nx;  apply Â¬á¶œâ‚‘ Hpi_nx Hpi_x }  {  assume Hbot; apply âŠ¥â‚‘;  apply Hbot  } } { assume Hbot; apply âŠ¥â‚‘;  apply Hbot  };
    } {
      assume Hb;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚‚;
      apply Hb;
    }
  } {
    assume Ha;
    apply âŸ‡â‚‘ H2 {
      assume Hnx;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚;
      apply Ha
    } {
      assume Hb;
      have tmp:  Ï€ ((âŸ‡_to_âˆ¨á¶œ_rw a âˆ¨á¶œ âŸ‡_to_âˆ¨á¶œ_rw b)  â‡’ âŸ‡_to_âˆ¨á¶œ_rw (a ++ b)) {
        apply âˆ§â‚‘â‚‚ (++_to_âˆ¨á¶œ a b);
      };
      apply tmp;
      apply âˆ¨á¶œáµ¢â‚;
      apply Ha
    }
  };
end;

opaque symbol bind_âˆƒ [p q]: (Î  x, Ï€ (p x âŸºá¶œ q x))  â†’ Ï€ ((`âˆƒá¶œ x, p x) âŸºá¶œ (`âˆƒá¶œ x, q x)) â‰”
begin
  assume p q H;
  apply âŸºá¶œáµ¢ 
  {
    assume H1;
    apply âˆƒá¶œâ‚‘ _ H1;
    assume x Hpx;
    apply âˆƒá¶œáµ¢ _ x;
    apply âŸºá¶œâ‚‘ (H x);
    assume Hpx_qx Hqx_px;
    apply Hpx_qx Hpx
  }
  {
    assume H1;
    apply âˆƒá¶œâ‚‘ _ H1;
    assume x Hqx;
    apply âˆƒá¶œáµ¢ _ x;
    apply âŸºá¶œâ‚‘ (H x);
    assume Hpx_qx Hqx_px;
    apply Hqx_px Hqx
  };
end;

opaque symbol bind_âˆ€ [p q]: (Î  x, Ï€ (p x âŸºá¶œ q x))  â†’ Ï€ ((`âˆ€á¶œ x, p x) âŸºá¶œ (`âˆ€á¶œ x, q x)) â‰”
begin
  assume p q H;
  apply âŸºá¶œáµ¢ 
  {
    assume H1;
    apply âˆ€á¶œáµ¢ _;
    assume x;
    have Hpx: Ï€ (p x) { apply âˆ€á¶œâ‚‘ x H1 };
    apply âŸºá¶œâ‚‘ (H x);
    assume Hpx_qx Hqx_px;
    apply Hpx_qx Hpx
  }
  {
    assume H1;
    apply âˆ€á¶œáµ¢ _;
    assume x;
    have Hqx: Ï€ (q x) { apply âˆ€á¶œâ‚‘ x H1 };
    apply âŸºá¶œâ‚‘ (H x);
    assume Hpx_qx Hqx_px;
    apply Hqx_px Hqx
  };
end;

symbol distinct [a] : ğ•ƒ a â†’ Prop;