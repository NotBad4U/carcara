require open Stdlib.Prop;
require open Stdlib.FOL;
require open Stdlib.Set;
require open Stdlib.Eq;
require open Stdlib.Bool;
require open lambdapi.Classic;

// SMT use congruence of ⇔/= so we set `=` as infix right notation
// to be able to parse term such as `a = b = c`.
notation = infix right 10;

constant symbol eq_reflᶜ [a] (x:τ a) : πᶜ (x = x);
constant symbol ind_eqᶜ [a] [x y:τ a] : πᶜ (x = y) → Π p, πᶜ (p y) → πᶜ (p x);

//FIXME:
constant symbol meta-arr [p q]: (πᶜ p → πᶜ q) → πᶜ (p ⇒ q);

constant symbol fold_⇒ᶜ [p q] : πᶜ (p ⇒ q) → πᶜ p → πᶜ q;

builtin "P"     ≔ πᶜ; // : Prop → TYPE
builtin "refl"  ≔ eq_reflᶜ; // : Π [a] (x:T a), P(x = x)
builtin "eqind" ≔ ind_eqᶜ; // : Π [a] x y, P(x = y) → Π p:T a → Prop, P(p y) → P(p x)


symbol ind_Prop :
Π p: (Prop → Prop),
πᶜ (p ⊤) →
πᶜ (p ⊥) →
(Π x: Prop, πᶜ (p x) → πᶜ (p (¬ x))) →
(Π x: Prop, πᶜ (p x) → Π y: Prop, πᶜ (p y) → πᶜ (p (x ∧ᶜ y))) →
(Π x: Prop, πᶜ (p x) → Π y: Prop, πᶜ (p y) → πᶜ (p (x ∨ᶜ y))) →
Π x: Prop, πᶜ (p x);

// testing symbols
private symbol a: Prop;
private symbol b: Prop;
private symbol c: Prop;
private symbol d: Prop;
private symbol e: Prop;

symbol o: Set;
rule τ o ↪ Prop;

symbol trivial : πᶜ ⊤;

symbol neg_⊥ : πᶜ (¬ ⊥);

// # Clause
// Clauses are encoded with list à la Church Encoding.
// This encoding is necessary because Inductive type in Lambdapi
// could not live in Prop.
constant symbol Clause : TYPE;

constant symbol clause: Set;
rule τ clause ↪ Clause;

// Nil
symbol ▩ : Clause; 
// Cons
injective symbol ⟇: Prop → Clause → Clause;
notation ⟇ infix right 2;
// Append of two clause list
sequential symbol ++ : Clause → Clause → Clause; notation ++ infix right 3;

rule ▩ ++ $m ↪ $m
with ($x ⟇ $l) ++ $m ↪ $x ⟇ ($l ++ $m);

constant symbol Clause_ind:  Π P: (Clause → Prop), Π l,
  πᶜ (P ▩) →
  (Π x: Prop, Π l: Clause, πᶜ (P l) → πᶜ (P (x ⟇ l))) →
  πᶜ (P l);

// some sanity checks
assert x y z ⊢ x ++ y ++ z ≡ x ++ (y ++ z);
assert x l m ⊢ x ⟇ l ++ m ≡ x ⟇ (l ++ m);


sequential symbol ∨ᶜ_to_⟇_rw: Prop → Clause;
rule ∨ᶜ_to_⟇_rw ($x ∨ᶜ $y) ↪ $x ⟇ (∨ᶜ_to_⟇_rw $y)
with ∨ᶜ_to_⟇_rw ⊥ ↪  ▩;

sequential symbol ⟇_to_∨ᶜ_rw: Clause → Prop;
rule ⟇_to_∨ᶜ_rw ($x ⟇ $y) ↪ $x ∨ᶜ (⟇_to_∨ᶜ_rw $y)
with ⟇_to_∨ᶜ_rw ▩ ↪ ⊥;

assert ⊢ ⟇_to_∨ᶜ_rw (a ⟇ b ⟇ ▩) ≡ a ∨ᶜ b ∨ᶜ ⊥;
assert ⊢ ∨ᶜ_to_⟇_rw (a ∨ᶜ b ∨ᶜ ⊥ ∨ᶜ c ∨ᶜ ⊥) ≡ (a ⟇ b ⟇ ⊥ ⟇ c ⟇ ▩);

injective symbol π̇ c: TYPE ≔ πᶜ (⟇_to_∨ᶜ_rw c);

opaque symbol π̇ₗ [a] : π̇ (a ⟇ ▩)  → πᶜ a ≔
begin
  assume a Hcl_a;
  apply @∨ᶜₑ a ⊥ a
  { apply Hcl_a }
  { assume Ha; apply Ha }
  { assume False; apply ⊥ᶜₑ False; };
end;

// opaque injective symbol πᶜ p : TYPE ≔ πᶜ (¬ (¬ p));

// Introduction rule for Clause
// construct `p ⟇ q` from a clause with only `p`
opaque symbol ⟇ᵢ₁ [p q] : π̇ (p ⟇ ▩) → π̇ (p ⟇ q) ≔
begin
  assume p q Hp;
  apply ∨ᶜₑ Hp
  { assume Hpi_p; apply ∨ᶜᵢ₁;  apply Hpi_p }
  { assume Hbot; apply ⊥ᶜₑ; apply Hbot }
end;

// construct `p ⟇ q` from a proof of `p`
opaque symbol ⟇ᵢ₁' [p q] : πᶜ p → π̇ (p ⟇ q) ≔
begin 
  assume p q Hp; apply ∨ᶜᵢ₁; apply Hp
end;

opaque symbol ⟇ᵢ₂ [p q] : π̇ q → π̇ (p ⟇ q) ≔
begin
  assume p q Hq; apply ∨ᶜᵢ₂; apply Hq
end;

// Elimination rule for clause
opaque symbol ⟇ₑ [p q r] : π̇ (p ⟇ q) → (π̇ (p ⟇ ▩) → π̇ r) → (π̇ q → π̇ r) → π̇ r ≔
begin
  assume p q r Hpq Hpr Hqr;
  apply ∨ᶜₑ Hpq
  { assume Hp; apply Hpr (∨ᶜᵢ₁ Hp) }
  { assume Hq; apply Hqr Hq }
end;


opaque symbol ++_to_∨ᶜ a b : πᶜ ((⟇_to_∨ᶜ_rw (a ++ b)) ⇔ᶜ  ((⟇_to_∨ᶜ_rw a) ∨ᶜ (⟇_to_∨ᶜ_rw b))) ≔
begin
  assume a b;
  apply Clause_ind (λ u, (⟇_to_∨ᶜ_rw (u ++ b)) ⇔ᶜ  ((⟇_to_∨ᶜ_rw u) ∨ᶜ (⟇_to_∨ᶜ_rw b))) a
    {
      apply ∧ᶜᵢ
        { apply ⇒ᶜᵢ; assume H; apply ∨ᶜᵢ₂; apply H }
        {
          apply ⇒ᶜᵢ; assume H;
          apply ∨ᶜₑ H { assume H⊥; apply ⊥ᶜₑ; apply H⊥ } { assume H1;  apply H1}
        }
    }
    {
      assume x l Hir;
      apply ∧ᶜᵢ
      { apply ⇒ᶜᵢ; assume H; apply ∨ᶜₑ H
        {
          assume Hx;
          apply ∨ᶜᵢ₁;
          apply ∨ᶜᵢ₁;
          apply Hx;
        }
        {
          assume Hl++b;
          have tmp: πᶜ ((x ∨ᶜ (⟇_to_∨ᶜ_rw l ∨ᶜ ⟇_to_∨ᶜ_rw b)) ⇒ᶜ ((x ∨ᶜ ⟇_to_∨ᶜ_rw l) ∨ᶜ ⟇_to_∨ᶜ_rw b)) {
            
            refine ∧ᶜₑ₁ ∨ᶜ_assoc;  //((x ∨ᶜ (⟇_to_∨ᶜ_rw l ∨ᶜ ⟇_to_∨ᶜ_rw b)) ⇒ᶜ ((x ∨ᶜ ⟇_to_∨ᶜ_rw l) ∨ᶜ ⟇_to_∨ᶜ_rw b))
          };
          apply ⇒ᶜₑ tmp;
          apply ∨ᶜₑ H
          {
            assume Hx;  apply ∨ᶜᵢ₁; apply Hx
          }
          {
            assume Hl_or_b;
            apply ∨ᶜᵢ₂;
            have HirLeft: πᶜ ((⟇_to_∨ᶜ_rw (l ++ b) ⇒ᶜ (⟇_to_∨ᶜ_rw l ∨ᶜ ⟇_to_∨ᶜ_rw b))) {
                refine (∧ᶜₑ₁ Hir);
            };
            apply ⇒ᶜₑ HirLeft;
            apply Hl++b
          }
        }
      }
      {
        apply ⇒ᶜᵢ;
        assume H;
        apply ∨ᶜₑ H {
            assume H1;
            apply ∨ᶜₑ H1 {
              assume Hx;
              apply ∨ᶜᵢ₁;
              apply Hx;
            } {
              assume H2;
              apply ∨ᶜᵢ₂;
              have tmp: πᶜ (((⟇_to_∨ᶜ_rw l ∨ᶜ ⟇_to_∨ᶜ_rw b) ⇒ᶜ ⟇_to_∨ᶜ_rw (l ++ b))) {
                refine (∧ᶜₑ₂ Hir);
              };
              apply ⇒ᶜₑ tmp;
              apply ∨ᶜᵢ₁;
              apply H2
            }
        } {
          assume H1;
          apply ∨ᶜᵢ₂;
          have tmp: πᶜ (((⟇_to_∨ᶜ_rw l ∨ᶜ ⟇_to_∨ᶜ_rw b) ⇒ᶜ ⟇_to_∨ᶜ_rw (l ++ b))) {
                refine (∧ᶜₑ₂ Hir);
              };
              apply ⇒ᶜₑ tmp;
              apply ∨ᶜᵢ₂;
              apply H1
        }        
      }
    }
end;

constant symbol nnpp_eq p : πᶜ ((¬ ¬ p) = p);

// Axiom propositional_extensionality: forall (P Q : Prop), (P <-> Q) -> P = Q.
// τ o ↪ Prop
constant symbol prop_ext [p: τ o] [q: τ o]: πᶜ (p ⇔ᶜ q) → πᶜ (p = q);

opaque symbol ⟺_ext [p: τ o] [q: τ o]:  πᶜ (p = q) → πᶜ (p ⇔ᶜ q) ≔
begin
  assume p q Heq;  rewrite Heq; apply ⇔ᶜ_refl
end;

opaque symbol iff_equiv_eq p q: πᶜ ((p ⇔ᶜ q) = (p = q)) ≔
begin
  assume p q;
  apply prop_ext;
  apply ∧ᶜᵢ
  { apply ⇒ᶜᵢ; assume Hiff; apply prop_ext Hiff }
  { apply ⇒ᶜᵢ; assume Heq; rewrite Heq; apply ⇔ᶜ_refl }
end;

opaque  symbol ∨ᶜ_assoc_eq x y z : πᶜ ((x ∨ᶜ (y ∨ᶜ z)) = ((x ∨ᶜ y) ∨ᶜ z)) ≔
begin
  assume x y z;
  apply prop_ext;
  apply ∨ᶜ_assoc
end;

opaque  symbol ∧ᶜ_assoc_eq x y z : πᶜ ((x ∧ᶜ (y ∧ᶜ z)) = ((x ∧ᶜ y) ∧ᶜ z)) ≔
begin
  assume x y z;
  apply prop_ext;
  apply ∧ᶜ_assoc
end;

opaque symbol morgan₁ p q : πᶜ ((¬ (p ∧ᶜ q)) = ((¬ p) ∨ᶜ (¬ q))) ≔
begin
  assume p q;
  apply prop_ext;
  apply ∧ᶜᵢ
  {
    apply ⇒ᶜᵢ;
    assume H;
    apply  not_and_or H
  }
  {
    apply ⇒ᶜᵢ;
    assume H;
    refine or_not_and H
  }
end;

opaque symbol morgan₂ p q : πᶜ ((¬ (p ∨ᶜ q)) = ((¬ p) ∧ᶜ (¬ q))) ≔
begin
  assume p q;
  apply prop_ext;
  apply ∧ᶜᵢ
  {
    apply ⇒ᶜᵢ;
    assume H;
    refine not_or_and H
  }
  {
    apply ⇒ᶜᵢ;
    assume H;
    refine and_not_or H
  }
end;

opaque symbol distributive_or p q r : πᶜ ((p ∨ᶜ (q ∧ᶜ r)) = ((p ∨ᶜ q) ∧ᶜ (p ∨ᶜ r))) ≔
begin
  assume p q r;
  apply prop_ext;
  apply ∧ᶜᵢ
  {
    apply ⇒ᶜᵢ;
    assume H;
    apply ∧ᶜᵢ
    {
      apply ∨ᶜₑ H
      { assume Hp; apply ∨ᶜᵢ₁; refine Hp }
      { assume Hqr; apply ∨ᶜᵢ₂; refine ∧ᶜₑ₁ Hqr }
    }
    {
      apply ∨ᶜₑ H
      { assume Hp; apply ∨ᶜᵢ₁; refine Hp }
      { assume Hqr; apply ∨ᶜᵢ₂; refine ∧ᶜₑ₂ Hqr }
    }
  }
  {
    apply ⇒ᶜᵢ;
    assume H;
    have H1: πᶜ (p ∨ᶜ q) { apply ∧ᶜₑ₁ H  };
    have H2: πᶜ (p ∨ᶜ r) { apply ∧ᶜₑ₂ H  };
    apply ∨ᶜₑ H1
    { 
        assume Hp;
        apply ∨ᶜₑ H2
        {
          assume Hp';
          apply ∨ᶜᵢ₁;
          apply Hp';
        }
        {
          assume Hr;
          apply ∨ᶜᵢ₁;
          apply Hp;
        }  
    }
    {
      assume Hq;
      apply ∨ᶜₑ H2
        {
          assume Hp';
          apply ∨ᶜᵢ₁;
          apply Hp';
        }
        {
          assume Hr;
          apply ∨ᶜᵢ₂;
          apply ∧ᶜᵢ
          { refine Hq }
          { refine Hr }
        }  
    };
  }
end;

opaque symbol distributive_and p q r : πᶜ ((p ∧ᶜ (q ∨ᶜ r)) = ((p ∧ᶜ q) ∨ᶜ (p ∧ᶜ r))) ≔
begin
  assume p q r;
  apply prop_ext;
  apply ∧ᶜᵢ
  {
    apply ⇒ᶜᵢ;
    assume H;
    have Hp: πᶜ p { apply ∧ᶜₑ₁ H };
    have Hqorr: πᶜ (q ∨ᶜ r) { apply ∧ᶜₑ₂ H };
    apply ∨ᶜₑ Hqorr
    { 
      assume Hq;
      apply ∨ᶜᵢ₁;
      apply ∧ᶜᵢ { refine Hp } { refine Hq }
    }
    {
      assume Hr;
      apply ∨ᶜᵢ₂;
      apply ∧ᶜᵢ { refine Hp } { refine Hr  }
    }
  }
  {
    apply ⇒ᶜᵢ;
    assume H;
    apply ∨ᶜₑ H
    {
      assume Hpandq;
      apply ∧ᶜᵢ { refine ∧ᶜₑ₁ Hpandq  } { apply ∨ᶜᵢ₁; refine ∧ᶜₑ₂ Hpandq }
    }
    {
      assume Hpandr;
      apply ∧ᶜᵢ { refine ∧ᶜₑ₁ Hpandr  } { apply ∨ᶜᵢ₂; refine ∧ᶜₑ₂ Hpandr }
    }
  }
end;

opaque symbol and_com p q : πᶜ ((p ∧ᶜ q) = (q ∧ᶜ p)) ≔
begin
  assume p q;
  apply prop_ext;
  apply ∧ᶜᵢ
  { apply ⇒ᶜᵢ; assume Hpq; apply ∧ᶜ_com Hpq }
  { apply ⇒ᶜᵢ; assume Hqp; apply ∧ᶜ_com Hqp }
end;

opaque symbol or_com p q : πᶜ ((p ∨ᶜ q) = (q ∨ᶜ p)) ≔
begin
  assume p q;
  apply prop_ext;
  apply ∧ᶜᵢ
  { apply ⇒ᶜᵢ; assume Hpq; apply ∨ᶜ_com Hpq }
  { apply ⇒ᶜᵢ; assume Hpq; apply ∨ᶜ_com Hpq }
end;

opaque symbol or_idempotent p : πᶜ ((p ∨ᶜ p) = p) ≔
begin
  assume p;
  apply prop_ext;
  apply ∧ᶜᵢ
  {
    apply ⇒ᶜᵢ;
    assume Hporp;
    apply ∨ᶜₑ Hporp
    { assume Hp; refine Hp }
    { assume Hp; refine Hp }
  }
  {
    apply ⇒ᶜᵢ;
    assume Hp;
    apply ∨ᶜᵢ₁;
    refine Hp
  }
end;

opaque symbol and_idempotent p : πᶜ ((p ∧ᶜ p) = p) ≔
begin
  assume p;
  apply prop_ext;
  apply ∧ᶜᵢ
  { apply ⇒ᶜᵢ; assume Hpandp; apply ∧ᶜₑ₁ Hpandp; }
  {
    apply ⇒ᶜᵢ;
    assume Hp;
    apply ∧ᶜᵢ { refine Hp } { refine Hp }
  }
end;

opaque symbol imp_eq_or p q: πᶜ (((¬ p) ∨ᶜ q) =  (p ⇒ᶜ q)) ≔
begin
  assume p q;
  apply prop_ext;
  apply ∧ᶜᵢ
  { apply ⇒ᶜᵢ; assume Hor; apply or_to_imply Hor }
  { apply ⇒ᶜᵢ; assume Himp; apply imply_to_or Himp }
end;

opaque symbol contrapos [p q] : πᶜ (p ⇒ᶜ q  ⇔ᶜ (¬ q ⇒ᶜ ¬ p)) ≔
begin
  assume p q;
  apply ∧ᶜᵢ
  {
    apply ⇒ᶜᵢ;
    assume Himp;
    apply ⇒ᶜᵢ;
    assume Hnq;
    apply ¬ᶜᵢ;
    assume Hp;
    have Hq: πᶜ q
    {  apply ⇒ᶜₑ Himp Hp };
    apply ¬ᶜₑ Hnq Hq
  }
  {
    apply ⇒ᶜᵢ;
    assume Himp;
    apply ⇒ᶜᵢ;
    assume Hp;
    have Hor: πᶜ ((¬ ¬ q) ∨ᶜ ¬ p) {
      rewrite imp_eq_or;
      apply Himp
    };
    apply ∨ᶜₑ Hor
    { assume Hnnq; rewrite left  nnpp_eq; apply Hnnq }
    { assume Hnp; apply  ¬ᶜₑ Hnp Hp }
  };
end;

opaque symbol contradiction p : (πᶜ (¬ p) → πᶜ ⊥) → πᶜ p ≔
begin
  assume p Hnp;
  admit
end;

// // Hilbert epsilon operator/choice
symbol ϵ  [a]: (τ a → Prop) → τ a; notation ϵ quantifier;

constant symbol ϵᵢ [a] x (p: τ a → Prop) : πᶜ (p x) → πᶜ (p (ϵ p));
constant symbol ϵ_det [p q]: Π x, πᶜ ((p x) ⇔ᶜ (q x)) → πᶜ (ϵ p = ϵ q);

opaque symbol ϵ_to_∃ [a] p: πᶜ ((`∃ᶜ (x : τ a),  p x) = p (`ϵ (x : τ a), p x)) ≔
begin
  assume a p;
  apply prop_ext;
  apply ∧ᶜᵢ
  {
    apply ⇒ᶜᵢ;
    assume H;
    apply ∃ᶜₑ _ H;
    assume x H1;
    apply ϵᵢ x (λ u, (p u)) H1;
  }
  {
    apply ⇒ᶜₑ (∧ᶜₑ₂ (@contrapos (p (`ϵ x, p x) ) (`∃ᶜ x, p x)));
    apply ⇒ᶜᵢ;
    assume H;
    have H1: πᶜ (`∀ᶜ x, ¬ p x) { apply (⇒ᶜₑ (∧ᶜₑ₁ (nex_forall p)) H) };
    admit
    //type ∀ᶜₑ (λ u, ¬ (p u)) H1
  }
end;

opaque symbol ϵ_to_∀ [a] p: πᶜ ((`∀ᶜ (x : τ a), p x) = p (`ϵ (x : τ a), (¬ p x))) ≔
begin
  assume a p;
  apply prop_ext;
  apply ∧ᶜᵢ
  {
    apply ⇒ᶜᵢ;
    assume H;
    apply ∀ᶜₑ (`ϵ x, ¬ (p x)) H
  }
  {
    apply ⇒ᶜₑ (∧ᶜₑ₂ (@contrapos (p (`ϵ x, ¬ (p x)) ) (`∀ᶜ x, p x)));
    apply ⇒ᶜᵢ;
    assume H;
    have H1: πᶜ (`∃ᶜ x, ¬ p x) { refine (⇒ᶜₑ (∧ᶜₑ₁ (nforall_ex p)) H) };
    apply ∃ᶜₑ _ H1;
    assume x Hnpx;
    apply ϵᵢ x (λ u, ¬ (p u)) Hnpx;
  }
end;

opaque  symbol and_identity_r x : πᶜ ((x ∧ᶜ ⊤) = x) ≔
begin
  assume x;
  apply prop_ext;
  apply ∧ᶜᵢ
  { apply ⇒ᶜᵢ; assume Hand; apply ∧ᶜₑ₁ Hand  }
  { apply ⇒ᶜᵢ; assume Hx; apply ∧ᶜᵢ { refine Hx } { refine trivial } }
end;

opaque  symbol and_identity_l x : πᶜ ((⊤ ∧ᶜ x) = x) ≔
begin
  assume x;
  apply prop_ext;
  apply ∧ᶜᵢ
  { apply ⇒ᶜᵢ; assume Hand; apply ∧ᶜₑ₂ Hand  }
  { apply ⇒ᶜᵢ; assume Hx; apply ∧ᶜᵢ { refine trivial } { refine Hx } }
end;

opaque  symbol and_domination x : πᶜ ((x ∧ᶜ ⊥) = ⊥) ≔
begin
  assume x;
  apply prop_ext;
  apply ∧ᶜᵢ
  { apply ⇒ᶜᵢ; assume Hand; apply ∧ᶜₑ₂ Hand  }
  { apply ⇒ᶜᵢ; assume Hx; apply ⊥ᶜₑ Hx }
end;

opaque  symbol or_identity_l x : πᶜ ((⊥ ∨ᶜ x) = x) ≔
begin
  assume x;
  apply prop_ext;
  apply ∧ᶜᵢ
  { apply ⇒ᶜᵢ; assume Hor; apply ∨ᶜₑ Hor { assume Hbot; apply ⊥ᶜₑ; refine Hbot } { assume Hx; refine Hx }  }
  { apply ⇒ᶜᵢ; assume Hx; apply ∨ᶜᵢ₂; refine Hx }
end;

opaque  symbol or_identity_r x : πᶜ ((x ∨ᶜ ⊥) = x) ≔
begin
  assume x;
  apply prop_ext;
  apply ∧ᶜᵢ
  { apply ⇒ᶜᵢ; assume Hor; apply ∨ᶜₑ Hor { assume Hx; refine Hx } { assume Hbot; apply ⊥ᶜₑ; refine Hbot } }
  { apply ⇒ᶜᵢ; assume Hx; apply ∨ᶜᵢ₁; refine Hx }
end;

opaque symbol ϵ_equiv_∃ᶜ' [p] : πᶜ ((`∃ᶜ x, p x) = (p (`ϵ x, p x))) ≔
begin
  assume p;
  apply prop_ext;
  apply ∧ᶜᵢ
  {
    apply ⇒ᶜᵢ;
    assume Hexist;
    apply ∃ᶜₑ _ Hexist;
    assume x Hpx;
    apply ϵᵢ x (λ u, p u);
    apply Hpx
  }
  {
    apply ⇒ᶜᵢ;
    assume Heps;
    apply ∃ᶜᵢ _ (`ϵ x, p x);
    apply Heps
  } 
end;

opaque symbol ϵ_equiv_∃ᶜ [p] : πᶜ ((`∃ᶜ x, p x) ⇔ᶜ (p (`ϵ x, p x))) ≔
begin
  assume p;
  apply ∧ᶜᵢ
  {
    apply ⇒ᶜᵢ;
    assume Hexist;
    apply ∃ᶜₑ _ Hexist;
    assume x Hpx;
    apply ϵᵢ x (λ u, p u);
    apply Hpx
  }
  {
    apply ⇒ᶜᵢ;
    assume Heps;
    apply ∃ᶜᵢ _ (`ϵ x, p x);
    apply Heps
  } 
end;

symbol ite c t e ≔ (c ⇒ᶜ t) ∧ᶜ ((¬ c) ⇒ᶜ e);
constant symbol iteI : Π c t e p,
                           (πᶜ c → πᶜ (p t))
                         → ((πᶜ c → πᶜ ⊥) → πᶜ (p e))
                         → πᶜ (p (ite c t e));                         

opaque symbol ∨ᶜ_to_⟇ a b: πᶜ (a ∨ᶜ b) → π̇ (a ⟇ b ⟇ ▩) ≔
begin
  assume a b Haorb;
  apply ∨ᶜₑ Haorb
  { assume Ha;  apply ∨ᶜᵢ₁; apply Ha }
  {  assume Hb; apply ∨ᶜᵢ₂; apply ∨ᶜᵢ₁; apply Hb }
end;

opaque symbol cong [a b] (f:τ a → τ b) [x x':τ a] : πᶜ(x = x') → πᶜ(f x = f x') ≔
begin
  assume a b f x x' xx'; rewrite xx'; reflexivity;
end;

opaque symbol cong2 [a b c] (f:τ a → τ b → τ c):
  Π [x x':τ a], πᶜ (x = x') → Π [y y':τ b], πᶜ (y = y') → πᶜ (f x y = f x' y') ≔
begin
  assume a b c f x x' xx' y y' yy'; rewrite xx'; rewrite yy'; reflexivity
end;


opaque symbol cong3 [a b c d] (f:τ a → τ b → τ c → τ d):
  Π [x x':τ a], πᶜ (x = x') → Π [y y':τ b], πᶜ (y = y') → Π [z z':τ c], πᶜ (z = z') → πᶜ (f x y z = f x' y' z') ≔
begin
  assume a b c d f x x' xx' y y' yy' z z' zz'; rewrite xx'; rewrite yy'; rewrite zz'; reflexivity
end;

opaque symbol ite1 [c t e] : πᶜ (ite c t e) → π̇ (c ⟇ e ⟇ ▩) ≔
begin
  assume c t e Hite;
  apply ∨ᶜ_to_⟇;
  have H: πᶜ (¬ c ⇒ᶜ e) { apply ∧ᶜₑ₂ Hite }; 
  have tmp: πᶜ (c ∨ᶜ e ⇔ᶜ  (¬ ¬ c) ∨ᶜ e) { 
    apply ∧ᶜᵢ
    {
      apply ⇒ᶜᵢ;
      assume H1;
      apply ∨ᶜₑ H1
      { assume Hc; apply ∨ᶜᵢ₁; simplify; apply meta-arr; assume Hnc; refine (fold_⇒ᶜ Hnc) Hc }
      { assume He; apply ∨ᶜᵢ₂;  apply He };
    }
    {
      apply ⇒ᶜᵢ;
      assume H1; 
      apply ∨ᶜₑ H1
      { assume Hc; apply ∨ᶜᵢ₁; apply nnpp; refine Hc }
      { assume He; apply ∨ᶜᵢ₂;  apply He };
    };
  };
  have H2: πᶜ ((¬ (¬ c) ∨ᶜ e) ⇒ᶜ (c ∨ᶜ e)) { refine ∧ᶜₑ₂ tmp };
  apply ⇒ᶜₑ H2;
  rewrite imp_eq_or;
  refine H;
end;

opaque symbol ite2 [c t e] : πᶜ (ite c t e) → π̇ ((¬ c) ⟇ t ⟇ ▩) ≔
begin
  assume c t e Hite;
  apply ∨ᶜ_to_⟇;
  have H: πᶜ (c ⇒ᶜ t) { apply ∧ᶜₑ₁ Hite };
  rewrite imp_eq_or;
  apply H
end;

// Use it to unfold the definition of `¬`.
// The tactic simplify is to agressive.
opaque symbol negdef p : πᶜ ((p ⇒ ⊥) = ¬ p) ≔
begin
    simplify;
    reflexivity
end;


opaque symbol ite_pos1 [c t e] : π̇ ((¬ (ite c t e)) ⟇ c ⟇ e ⟇ ▩) ≔
begin
  assume c t e;
  apply imply_to_or;
  apply ⇒ᶜᵢ;
  assume H;
  apply ite1 H;
end;

opaque symbol ite_pos2 [c t e] : π̇ (¬ (ite c t e) ⟇ ¬ c ⟇ t ⟇ ▩) ≔
begin
  assume c t e;
  simplify;
  //rewrite negdef;
  apply imply_to_or;
  apply ⇒ᶜᵢ;
  assume H;
  apply ite2 H;
end;

opaque symbol ite_neg1 [c t e] : π̇ ((ite c t e) ⟇ c ⟇ ¬ e ⟇ ▩) ≔
begin
  assume c t e;
  simplify;
  rewrite or_identity_r;
  rewrite .[c ∨ᶜ ((e ⇒ ⊥))] or_com;
  rewrite left .[c ⇒ᶜ t] imp_eq_or;
  rewrite left .[(c ⇒ ⊥) ⇒ᶜ e] imp_eq_or;
  rewrite or_com;
  rewrite distributive_or;
  apply ∧ᶜᵢ
  {
    rewrite ∨ᶜ_assoc_eq;
    apply ∨ᶜᵢ₁;
    rewrite left ∨ᶜ_assoc_eq;
    apply ∨ᶜᵢ₂;
    apply classic
  }
  {
    rewrite or_com;
    rewrite left ∨ᶜ_assoc_eq;
    apply ∨ᶜᵢ₂;
    rewrite ∨ᶜ_assoc_eq;
    apply ∨ᶜᵢ₁;
    apply classic
  };
end;

opaque symbol ite_neg2 [c t e] : π̇ ((ite c t e) ⟇ ¬ c ⟇ ¬ t ⟇ ▩) ≔
begin
  assume c t e;
  simplify;
  rewrite or_identity_r;
  rewrite left .[c ⇒ᶜ t] imp_eq_or;
  rewrite left .[((c ⇒ ⊥)) ⇒ᶜ e] imp_eq_or;
  rewrite or_com;
  rewrite distributive_or;
  apply ∧ᶜᵢ
  {
    rewrite left ∨ᶜ_assoc_eq;
    apply ∨ᶜᵢ₂;
    rewrite or_com;
    rewrite left ∨ᶜ_assoc_eq;
    apply ∨ᶜᵢ₂;
    apply classic
  }
  {
    rewrite ∨ᶜ_assoc_eq;
    rewrite .[(c ⇒ ⊥) ∨ᶜ (t ⇒ ⊥)] or_com;
    apply ∨ᶜᵢ₁;
    rewrite left ∨ᶜ_assoc_eq;
    apply ∨ᶜᵢ₂;
    apply classic
  }
end;

opaque symbol not_ite1 [c t e] : πᶜ (¬ (ite c t e)) → π̇( c ⟇ ¬ e ⟇ ▩) ≔
begin
  assume c t e H;
  have H1: πᶜ ((¬ (c ⇒ᶜ t)) ∨ᶜ (¬ ((¬ c) ⇒ᶜ e))) { apply not_and_or H };
  apply ∨ᶜₑ H1
  {
    assume Hl;
    have Hl': πᶜ (¬ ((¬ c) ∨ᶜ t)) { rewrite imp_eq_or;  refine Hl };
    have Hl'': πᶜ ((¬ ¬ c) ∧ᶜ ¬ t) {  apply not_or_and Hl' };
    apply ∨ᶜᵢ₁;
    apply nnpp;
    apply ∧ᶜₑ₁ Hl'';
  }
  {
    assume Hr;
    have Hr': πᶜ (¬ ((¬ ¬ c) ∨ᶜ e)) { rewrite imp_eq_or;  refine Hr };
    have Hr'': πᶜ ((¬ ¬ ¬ c) ∧ᶜ ¬ e) {  apply not_or_and Hr' };
    apply ∨ᶜᵢ₂;
    apply ∨ᶜᵢ₁;
    apply ∧ᶜₑ₂ Hr''
  };
end;

opaque symbol not_ite2 [c t e] : πᶜ (¬ (ite c t e)) → π̇(¬ c ⟇ ¬ t ⟇ ▩) ≔
begin
  simplify;
  assume c t e H;
  have H1: πᶜ ((¬ (c ⇒ᶜ t)) ∨ᶜ (¬ ((¬ c) ⇒ᶜ e))) { apply not_and_or H };
  apply ∨ᶜₑ H1
  {
    assume Hl;
    have Hl': πᶜ (¬ ((¬ c) ∨ᶜ t)) { rewrite imp_eq_or;  refine Hl };
    have Hl'': πᶜ ((¬ ¬ c) ∧ᶜ ¬ t) {  apply not_or_and Hl' };
    apply ∨ᶜᵢ₂;
    apply ∨ᶜᵢ₁;
    apply ∧ᶜₑ₂ Hl''
  }
  {
    assume Hr;
    have Hr': πᶜ (¬ ((¬ ¬ c) ∨ᶜ e)) { rewrite imp_eq_or;  refine Hr };
    have Hr'': πᶜ ((¬ ¬ ¬ c) ∧ᶜ ¬ e) {  apply not_or_and Hr' };
    apply ∨ᶜᵢ₁;
    apply nnpp;
    apply ∧ᶜₑ₁ Hr''
  }
end;

symbol xor a b ≔ ((¬ a) ∧ᶜ b) ∨ᶜ (a ∧ᶜ (¬ b));

opaque symbol xor_pos1 [a b] : π̇ (¬ (xor a b) ⟇ a ⟇ b ⟇ ▩) ≔
begin
  assume a b;
  simplify;
  apply imply_to_or;
  apply ⇒ᶜᵢ;
  assume H;
  apply ∨ᶜₑ H
  { assume Hnab; apply ∨ᶜᵢ₂;  apply ∨ᶜᵢ₁; apply ∧ᶜₑ₂ Hnab }
  { assume Hnab; apply ∨ᶜᵢ₁; apply ∧ᶜₑ₁ Hnab }
end;

opaque symbol xor_pos2 [a b] : π̇ (¬ (xor a b) ⟇ ¬ a ⟇ ¬ b ⟇ ▩) ≔
begin
  assume a b;
  simplify;
  apply imply_to_or;
  apply ⇒ᶜᵢ;
  assume H;
  apply ∨ᶜₑ H
  { assume Hnab; apply ∨ᶜᵢ₁; apply ∧ᶜₑ₁ Hnab }
  { assume Hnab; apply ∨ᶜᵢ₂;  apply ∨ᶜᵢ₁; apply ∧ᶜₑ₂ Hnab }
end;

opaque symbol xor_neg1 [a b] : π̇ ((xor a b) ⟇ a ⟇ ¬ b ⟇ ▩) ≔
begin
  simplify;
  assume a b;
  rewrite left ∨ᶜ_assoc_eq;
  rewrite or_com;
  rewrite distributive_or;
  apply ∧ᶜᵢ
  {
    rewrite or_identity_r;
    rewrite left ∨ᶜ_assoc_eq;
    apply ∨ᶜᵢ₂;
    rewrite or_com;
    rewrite ∨ᶜ_assoc_eq;
    apply ∨ᶜᵢ₁;
    rewrite or_com;
    apply classic
  }
  {
    rewrite left ∨ᶜ_assoc_eq;
    apply ∨ᶜᵢ₂;
    rewrite left ∨ᶜ_assoc_eq;
    apply ∨ᶜᵢ₂;
    rewrite or_com;
    rewrite ∨ᶜ_assoc_eq;
    apply ∨ᶜᵢ₁;
    apply classic
  }
end;

opaque symbol xor_neg2 [a b] : π̇ ((xor a b) ⟇ ¬ a ⟇ b ⟇ ▩) ≔
begin
  simplify;
  assume a b;
  rewrite left ∨ᶜ_assoc_eq;
  rewrite or_com;
  rewrite distributive_or;
  apply ∧ᶜᵢ
  {
    rewrite left ∨ᶜ_assoc_eq;
    rewrite or_com;
    rewrite distributive_or;
    apply ∧ᶜᵢ
    {
      rewrite left ∨ᶜ_assoc_eq;
      apply ∨ᶜᵢ₂;
      rewrite or_com;
      apply classic
    }
    {
      rewrite or_com;
      rewrite ∨ᶜ_assoc_eq;
      apply ∨ᶜᵢ₁;
      rewrite or_com;
      rewrite left ∨ᶜ_assoc_eq;
      apply ∨ᶜᵢ₂;
      rewrite or_identity_r;
      apply classic
    }
  }
  {
    rewrite left ∨ᶜ_assoc_eq;
    rewrite or_com;
    rewrite distributive_or;
    apply ∧ᶜᵢ
    {
      rewrite or_com;
      rewrite ∨ᶜ_assoc_eq;
      apply ∨ᶜᵢ₁;
      rewrite ∨ᶜ_assoc_eq;
      apply ∨ᶜᵢ₁;
      apply classic
    }
    {
      rewrite or_com;
      rewrite ∨ᶜ_assoc_eq;
      rewrite or_identity_r;
      apply ∨ᶜᵢ₁;
      rewrite or_com;
      rewrite left ∨ᶜ_assoc_eq;
      apply ∨ᶜᵢ₂;
      apply classic
    }
  }
end;

// // i ▷ 𝜑1 ∨ ⋯ ∨ 𝜑n
// // j ▷ 𝜑1 , ⋯ , 𝜑n
constant symbol or [a b] : π̇ ((a ∨ᶜ b) ⟇ ▩) → π̇ (∨ᶜ_to_⟇_rw  (a ∨ᶜ b));

opaque symbol not_not x : π̇ ( (¬ (¬ (¬ x))) ⟇ x ⟇ ▩) ≔
begin
  assume x;
  apply imply_to_or;
  apply ⇒ᶜᵢ;
  assume H;
  apply ∨ᶜᵢ₁;
  apply nnpp H
end;

opaque symbol implies [φ₁ φ₂] : πᶜ (φ₁ ⇒ᶜ φ₂) → π̇ (¬ φ₁ ⟇ φ₂ ⟇ ▩) ≔
begin
  assume φ₁ φ₂ Hφ₁⇒ᶜφ₂;
  apply imply_to_or;
  apply ⇒ᶜᵢ;
  assume πφ₁;
  apply ∨ᶜᵢ₁;
  apply ⇒ᶜₑ Hφ₁⇒ᶜφ₂ πφ₁
end;

opaque symbol not_implies1 [φ₁ φ₂] : πᶜ (¬ (φ₁ ⇒ᶜ φ₂)) → π̇ (φ₁ ⟇ ▩) ≔
begin
  assume φ₁ φ₂ Hnot_φ₁⇒ᶜφ₂;
  apply ∨ᶜᵢ₁;
  apply ∧ᶜₑ₁ (imply_to_and Hnot_φ₁⇒ᶜφ₂)
end;

opaque symbol not_implies2 [φ₁ φ₂] : πᶜ (¬ (φ₁ ⇒ᶜ φ₂)) →  π̇ (¬ φ₂ ⟇ ▩) ≔
begin
  assume φ₁ φ₂ Hnot_φ₁⇒ᶜφ₂;
  apply ∨ᶜᵢ₁;
  apply ∧ᶜₑ₂ (imply_to_and Hnot_φ₁⇒ᶜφ₂)
end;

opaque symbol implies_neg1 [φ₁ φ₂] : π̇ (φ₁ ⇒ᶜ φ₂ ⟇ φ₁ ⟇ ▩) ≔
begin
  assume φ₁ φ₂;
  simplify;
  rewrite left imp_eq_or;
  rewrite ∨ᶜ_assoc_eq;
  apply ∨ᶜᵢ₁;
  rewrite .[(¬ φ₁) ∨ᶜ φ₂] or_com;
  rewrite left ∨ᶜ_assoc_eq;
  apply ∨ᶜᵢ₂;
  rewrite or_com;
  apply classic
end;

opaque symbol implies_neg2 [φ₁ φ₂] : π̇ (φ₁ ⇒ᶜ φ₂ ⟇ ¬ φ₂ ⟇ ▩) ≔
begin
  assume φ₁ φ₂;
  simplify;
  rewrite left imp_eq_or;
  rewrite ∨ᶜ_assoc_eq;
  apply ∨ᶜᵢ₁;
  rewrite left ∨ᶜ_assoc_eq;
  apply ∨ᶜᵢ₂;
  apply classic
end;

opaque symbol equiv1 [φ₁ φ₂] : π̇ (φ₁ = φ₂ ⟇ ▩) → π̇ ((¬ φ₁) ⟇ φ₂ ⟇ ▩) ≔
begin
  assume φ₁ φ₂ H1;
  apply ∨ᶜₑ H1
  {
    assume Hequiv;
    have Hequiv':  πᶜ (φ₁ ⇔ᶜ φ₂) { apply ⟺_ext; apply Hequiv };
    have H2: πᶜ (φ₁ ⇒ᶜ φ₂) { apply ∧ᶜₑ₁ Hequiv' };
    have H3: πᶜ (φ₂ ⇒ᶜ φ₁) { apply ∧ᶜₑ₂ Hequiv' };
    have Hassoc: πᶜ (((¬ φ₁) ∨ᶜ (φ₂ ∨ᶜ ⊥)) ⇔ᶜ  (((¬ φ₁) ∨ᶜ φ₂) ∨ᶜ ⊥)) {
      apply (@∨ᶜ_assoc (¬ φ₁) φ₂ ⊥);
    };
    have Hassoc_left: πᶜ ((((¬ φ₁) ∨ᶜ φ₂) ∨ᶜ ⊥)  ⇒ᶜ  ((¬ φ₁) ∨ᶜ (φ₂ ∨ᶜ ⊥))) {
      refine ∧ᶜₑ₂ Hassoc
    };
    apply ⇒ᶜₑ Hassoc_left;
    apply ∨ᶜᵢ₁;
    apply imply_to_or;
    refine H2;
  }
  {
    assume Hbot;
    apply ∨ᶜᵢ₂;
    apply ∨ᶜᵢ₂;
    apply Hbot;
  }
end;

opaque symbol equiv2 [φ₁ φ₂] : π̇ (φ₁ = φ₂ ⟇ ▩)  → π̇ (φ₁ ⟇ (¬ φ₂) ⟇ ▩) ≔
begin
  assume φ₁ φ₂ H1;
  apply ∨ᶜₑ H1
  {
    assume Hequiv;
    have Hequiv':  πᶜ (φ₁ ⇔ᶜ φ₂) { apply ⟺_ext; apply Hequiv };
    have H2: πᶜ (φ₁ ⇒ᶜ φ₂) { apply ∧ᶜₑ₁ Hequiv' };
    have H3: πᶜ (φ₂ ⇒ᶜ φ₁) { apply ∧ᶜₑ₂ Hequiv' };
    have Hassoc: πᶜ ((φ₁ ∨ᶜ ((¬ φ₂) ∨ᶜ ⊥)) ⇔ᶜ  ((φ₁ ∨ᶜ (¬ φ₂)) ∨ᶜ ⊥)) {
      apply (@∨ᶜ_assoc φ₁ (¬ φ₂) ⊥);
    };
    have Hassoc_left: πᶜ (((φ₁ ∨ᶜ (¬ φ₂)) ∨ᶜ ⊥)  ⇒ᶜ  (φ₁ ∨ᶜ ((¬ φ₂) ∨ᶜ ⊥))) {
      refine ∧ᶜₑ₂ Hassoc
    };
    apply ⇒ᶜₑ Hassoc_left;
    apply ∨ᶜᵢ₁;
    apply ∨ᶜ_com;
    apply imply_to_or;
    refine H3;
  }
  {
    assume Hbot;
    apply ∨ᶜᵢ₂;
    apply ∨ᶜᵢ₂;
    apply Hbot;
  }
end;

opaque symbol equiv_pos1 [φ₁ φ₂] : π̇ ((¬ (φ₁ = φ₂)) ⟇ φ₁ ⟇ ¬ φ₂ ⟇ ▩) ≔
begin
  simplify;
  assume p q;
  apply imply_to_or;
  apply ⇒ᶜᵢ;
  assume Heq;
  rewrite Heq;
  rewrite ∨ᶜ_assoc_eq;
  apply ∨ᶜᵢ₁;
  apply classic
end;

opaque symbol equiv_pos2 [φ₁ φ₂] : π̇ ((¬ (φ₁ = φ₂)) ⟇ (¬ φ₁) ⟇ φ₂ ⟇ ▩) ≔
begin
  simplify;
  assume p q;
  apply imply_to_or;
  apply ⇒ᶜᵢ;
  assume Heq;
  rewrite or_identity_r;
  apply ∨ᶜ_com;
  rewrite Heq;
  apply classic
end;

opaque symbol equiv_neg1 [φ₁ φ₂] : π̇ ((φ₁ = φ₂) ⟇ ¬ φ₁ ⟇ ¬ φ₂ ⟇ ▩) ≔
begin
  simplify;
  assume p q;
  rewrite or_identity_r;
  apply ∨ᶜ_com;
  rewrite left ∨ᶜ_assoc_eq;
  apply imply_to_or;
  apply ⇒ᶜᵢ;
  assume Hp;
  apply imply_to_or;
  apply ⇒ᶜᵢ;
  assume Hq;
  apply prop_ext;
  apply ∧ᶜᵢ
  { apply ⇒ᶜᵢ; assume Hp'; apply Hq }
  { apply ⇒ᶜᵢ; assume Hq'; apply Hp }
end;

opaque symbol equiv_neg2 [φ₁ φ₂] : π̇ ((φ₁ = φ₂) ⟇ φ₁ ⟇ φ₂ ⟇ ▩) ≔
begin
  simplify;
  assume p q;
  rewrite or_identity_r;
  rewrite left iff_equiv_eq;
  apply ∨ᶜ_com;
  simplify;
  rewrite distributive_or; //(p ∨ᶜ q) (p ⇒ᶜ q) (q ⇒ᶜ p);
  apply ∧ᶜᵢ
  {
    rewrite left imp_eq_or;
    rewrite left ∨ᶜ_assoc_eq;
    rewrite .[(¬ p) ∨ᶜ q] or_com;
    rewrite  .[q ∨ᶜ (q ∨ᶜ ¬ p)] ∨ᶜ_assoc_eq;
    rewrite or_idempotent;
    rewrite .[q ∨ᶜ (¬ p)] or_com;
    rewrite ∨ᶜ_assoc_eq;
    apply ∨ᶜᵢ₁;
    apply classic
  }
  {
    rewrite left imp_eq_or;
    rewrite ∨ᶜ_assoc_eq;
    rewrite .[p ∨ᶜ q] or_com;
    rewrite left .[((q ∨ᶜ p) ∨ᶜ ¬ q)] ∨ᶜ_assoc_eq;
    apply ∨ᶜᵢ₁;
    rewrite .[p ∨ᶜ ¬ q] or_com;
    rewrite ∨ᶜ_assoc_eq;
    apply ∨ᶜᵢ₁;
    apply classic
  }
end;

opaque symbol implies_pos [φ₁ φ₂] : π̇ ((¬ (φ₁ ⇒ᶜ φ₂)) ⟇ ¬ φ₁ ⟇ φ₂ ⟇ ▩) ≔
begin
  simplify;
  assume x y;
  rewrite or_identity_r;
  rewrite left imp_eq_or;
  apply ∨ᶜ_com;
  apply classic
end;

opaque symbol subproof1 [φ₁ ψ] : πᶜ φ₁ → πᶜ ψ → π̇ ((¬ φ₁) ⟇ ψ ⟇ ▩) ≔
begin
  assume φ₁ ψ Hφ₁ Hψ;
  apply ∨ᶜᵢ₂;
  apply ∨ᶜᵢ₁;
  apply Hψ
end;

opaque symbol subproof2 [φ₁ φ₂ ψ] : πᶜ φ₁ → πᶜ φ₂ → πᶜ ψ → π̇ ((¬ φ₁) ⟇ (¬ φ₂) ⟇ ψ ⟇ ▩) ≔
begin
  assume φ₁ φ₂ ψ Hφ₁ Hφ₂ Hψ;
  apply ∨ᶜᵢ₂;
  apply ∨ᶜᵢ₂;
  apply ∨ᶜᵢ₁;
  apply Hψ;
end;

opaque symbol subproof3 [φ₁ φ₂ φ₃ ψ] : πᶜ φ₁ → πᶜ φ₂ → πᶜ φ₃ → πᶜ ψ → π̇ ((¬ φ₁) ⟇ (¬ φ₂) ⟇ (¬ φ₃) ⟇ ψ ⟇ ▩) ≔
begin
  assume φ₁ φ₂ φ₃ ψ Hφ₁ Hφ₂ Hφ₃ Hψ;
  apply ∨ᶜᵢ₂;
  apply ∨ᶜᵢ₂;
  apply ∨ᶜᵢ₂;
  apply ∨ᶜᵢ₁;
  apply Hψ;
end;

opaque symbol subproof4 [φ₁ φ₂ φ₃ φ₄ ψ] : πᶜ φ₁ → πᶜ φ₂ → πᶜ φ₃ → πᶜ φ₄ → πᶜ ψ → π̇ ((¬ φ₁) ⟇ (¬ φ₂) ⟇ (¬ φ₃) ⟇ (¬ φ₄) ⟇ ψ ⟇ ▩) ≔
begin
  assume φ₁ φ₂ φ₃ φ₄ ψ Hφ₁ Hφ₂ Hφ₃ Hφ₄ Hψ;
  apply ∨ᶜᵢ₂;
  apply ∨ᶜᵢ₂;
  apply ∨ᶜᵢ₂;
  apply ∨ᶜᵢ₂;
  apply ∨ᶜᵢ₁;
  apply Hψ;
end;

opaque symbol forall_inst1 p x : πᶜ (¬ (`∀ᶜ x', p x') ∨ᶜ (p x)) ≔
begin
 assume p x;
 rewrite imp_eq_or;
 apply ⇒ᶜᵢ;
 assume H;
 apply ∀ᶜₑ x H
end;

opaque symbol forall_inst2 p x y: πᶜ (¬ (`∀ᶜ a, `∀ᶜ b, p a b) ∨ᶜ (p x y)) ≔
begin
  assume p x y;
  rewrite imp_eq_or;
  apply ⇒ᶜᵢ;
  assume H;
  apply ∀ᶜₑ y (∀ᶜₑ x H)
 end;

opaque symbol forall_inst3 [p] x y z: πᶜ ((¬ (`∀ᶜ a, `∀ᶜ b, `∀ᶜ c, p a b c)) ∨ᶜ ((p x y z) ∨ᶜ ⊥)) ≔
begin
  assume p x y z;
  apply imply_to_or;
  apply ⇒ᶜᵢ;
  assume H;
  apply ∨ᶜᵢ₁ (∀ᶜₑ z (∀ᶜₑ y (∀ᶜₑ x H)))
end;

// # In Predicate
// 
// The In predicate works with 𝔹 instead of Prop to avoid making critical pairs wiht other rules.
// If we use Prop, then we will need a rule
// ▷ `$x ⇔ᶜ $x ↪ ⊤` to replace `eq $x $h` and, 
// ▷ `_ ∨ᶜ ⊤ ↪ ⊤` for `or _ true ↪ true`. 
//
// This choice will create a critical pair reduction which would make any clause in the goal
// that contain the litteral ⊤ unable to compute the predicate In.
//
// To illustrate this case, consider the goal:
// ⊢ (𝜑1 ∨ᶜ ⋯ ∨ᶜ ⊤ ⋯ ∨ᶜ 𝜑𝑛), ¬𝜑k
// then we will have
// ⊢ In_∨ᶜ 𝜑k (𝜑1 ∨ᶜ ⋯ ∨ᶜ ⊤ ⋯ ∨ᶜ 𝜑𝑛)  (apply or_neg)
// ⊢ In_∨ᶜ 𝜑k ⊤  (by simplification)
// we got stuck...

// Decidable equality in 𝔹.
// Symbol = has been declared constant, it cannot be used as the head of a rewrite rule LHS.
// So we create our own eq symbol.

// symbol 𝑰 [a]: ℕ → τ a; 

symbol eq : Prop → Prop → 𝔹;
rule eq $x $x ↪ true;

sequential symbol In_∧ᶜ: Prop → Prop → 𝔹;
rule In_∧ᶜ $x ($h ∧ᶜ $tl) ↪ (eq $x $h)  Stdlib.Bool.or (In_∧ᶜ $x $tl)
with In_∧ᶜ $x ⊤ ↪ false;

sequential symbol In_∨ᶜ: Prop → Prop → 𝔹;
rule In_∨ᶜ $x ($h ∨ᶜ $tl) ↪ (eq $x $h) Stdlib.Bool.or (In_∨ᶜ $x $tl)
with In_∨ᶜ _ ⊥ ↪ false;

sequential symbol In_∧ᶜ': Prop → Prop → 𝔹;
rule In_∧ᶜ' $x ($h ∧ᶜ $tl) ↪ (eq $x $h)  Stdlib.Bool.or (In_∧ᶜ' $x $tl)
with In_∧ᶜ' $x $h ↪ (eq $x $h);

sequential symbol In_∨ᶜ': Prop → Prop → 𝔹;
rule In_∨ᶜ' $x ($h ∨ᶜ $tl) ↪ (eq $x $h) Stdlib.Bool.or (In_∨ᶜ' $x $tl)
with In_∨ᶜ' $x $h ↪ (eq $x $h);

// and_pos: ¬(𝜑1 ∧ … ∧ 𝜑𝑛), 𝜑𝑘
symbol and_pos [φ₁__φₙ φₖ]:  πᶜ ((In_∧ᶜ' φₖ φ₁__φₙ) = true) → π̇ (¬ φ₁__φₙ ⟇ φₖ ⟇ ▩);

opaque symbol test_and_pos: π̇ ((¬ (a ∧ᶜ b ∧ᶜ c ∧ᶜ d)) ⟇ d ⟇ ▩) ≔
begin
  apply and_pos;
  reflexivity;
end; 

// and_neg:  (𝜑1 ∧ ⋯ ∧ 𝜑𝑛), ¬𝜑1, … , ¬𝜑𝑛
sequential symbol and_neg_r: Prop → Clause → 𝔹; 
rule and_neg_r ($x ∧ᶜ $tl) (($x ⇒ ⊥) ⟇ $tl2) ↪ and_neg_r $tl $tl2
with and_neg_r ⊤ ▩ ↪ true; 

sequential symbol and_neg_r': Prop → Clause → 𝔹; 
rule and_neg_r' ($x ∧ᶜ $tl) (($x ⇒ ⊥) ⟇ $tl2) ↪ and_neg_r' $tl $tl2
with and_neg_r' ($x) (($x ⇒ ⊥) ⟇ ▩) ↪ true;
//with and_neg_r ⊤ ▩ ↪ true; 

symbol and_neg [l1 l2]: πᶜ (and_neg_r' l1 l2 = true) → π̇ (l1 ⟇ l2);

opaque symbol test_and_neg: π̇ ((a ∧ᶜ b ∧ᶜ c ∧ᶜ d) ⟇ (¬ a) ⟇ (¬ b) ⟇ (¬ c) ⟇ (¬ d) ⟇ ▩) ≔
begin
  apply and_neg;
  reflexivity;
end; 

// or_pos:  ¬(𝜑1 ∨ ⋯ ∨ 𝜑𝑛), 𝜑1 , … , 𝜑𝑛
sequential symbol or_pos_r: Prop → Clause → 𝔹; 
rule or_pos_r ($x ∨ᶜ $tl) ($x ⟇ $tl2) ↪ or_pos_r $tl $tl2
with or_pos_r ⊥ ▩ ↪ true; 

sequential symbol or_pos_r': Prop → Clause → 𝔹; 
rule or_pos_r' ($x ∨ᶜ $tl) ($x ⟇ $tl2) ↪ or_pos_r' $tl $tl2
with or_pos_r' $x ($x ⟇ ▩) ↪ true;

symbol or_pos [l1 l2]: πᶜ (or_pos_r' l1 l2 = true) → π̇ (¬ l1 ⟇ l2);

opaque symbol test_or_pos: π̇ (¬ (a ∨ᶜ b ∨ᶜ c ∨ᶜ d) ⟇ a ⟇ b ⟇ c ⟇ d ⟇ ▩) ≔
begin
  apply or_pos; reflexivity
end; 

// or_neg:
// i. ▷ (𝜑1 ∨ ⋯ ∨ 𝜑𝑛), ¬𝜑k
symbol or_neg [φ₁__φₙ] φₖ:  πᶜ ((In_∨ᶜ' φₖ φ₁__φₙ) = true) → π̇ (φ₁__φₙ ⟇ ¬ φₖ ⟇ ▩);

opaque symbol test_or_neg: π̇ (((a ∨ᶜ b ∨ᶜ c ∨ᶜ d)) ⟇ ¬ c ⟇ ▩) ≔
begin
  apply or_neg; reflexivity
end; 

// not_or:
// i. ▷ ¬(𝜑1 ∨ ⋯ ∨ 𝜑𝑛)
// j. ▷ ¬𝜑𝑘
symbol not_or [φₖ] φ₁__φₙ: πᶜ (¬ φ₁__φₙ) → πᶜ ((In_∨ᶜ' φₖ φ₁__φₙ) = true) → π̇ (¬ φₖ ⟇ ▩);

opaque symbol identity_⊥ [x] : πᶜ (x ∨ᶜ ⊥) → πᶜ x ≔
begin
  assume x H;
  apply ∨ᶜₑ H
  { assume Hx; apply Hx } { assume H⊥; apply ⊥ᶜₑ; apply H⊥ }
end;

opaque symbol test_not_or: π̇ (¬ (a ∨ᶜ b ∨ᶜ c ∨ᶜ d) ⟇ ▩) → π̇ (¬ c ⟇ ▩) ≔
begin
  assume H; // i
  apply not_or (a ∨ᶜ b ∨ᶜ c ∨ᶜ d)
    { apply π̇ₗ; apply H }
    { reflexivity }
end;

// not_and:
// i. ▷ ¬(𝜑1 ∧ … ∧ 𝜑𝑛)
// j. ▷ ¬𝜑1, … , ¬𝜑𝑛
sequential symbol not_and_r: Prop → Clause → 𝔹; 
rule not_and_r ($x ∧ᶜ $tl) (($x ⇒ ⊥) ⟇ $tl2) ↪ not_and_r $tl $tl2
with not_and_r ⊤ ▩ ↪ true; 

sequential symbol not_and_r': Prop → Clause → 𝔹; 
rule not_and_r' ($x ∧ᶜ $tl) (($x ⇒ ⊥) ⟇ $tl2) ↪ not_and_r' $tl $tl2
with not_and_r' $x (($x ⇒ ⊥) ⟇ ▩) ↪ true;

symbol not_and [l1 l2]: πᶜ (¬ l1) → πᶜ (not_and_r' l1 l2 = true) → π̇ l2;

opaque symbol test_not_and: π̇ (¬ (a ∧ᶜ b ∧ᶜ c ∧ᶜ d) ⟇ ▩) → π̇ (¬ a ⟇ ¬ b ⟇ ¬ c ⟇ ¬ d ⟇ ▩) ≔
begin
  assume t1;
  apply not_and (π̇ₗ t1);
  reflexivity
end; 

// and:
// i. ▷ (𝜑1 ∧ ⋯ ∧ 𝜑𝑛)
// j. ▷ 𝜑𝑘
symbol and [φₖ] φ₁__φₙ : πᶜ ((In_∧ᶜ' φₖ φ₁__φₙ) = true) → π̇ (φ₁__φₙ ⟇ ▩)  → π̇ (φₖ ⟇ ▩);

opaque symbol test_and:  π̇ ((a ∧ᶜ b ∧ᶜ c ∧ᶜ d) ⟇ ▩) →  π̇ (c ⟇ ▩) ≔
begin
  assume t1;
  apply and ((a ∧ᶜ b ∧ᶜ (c ∧ᶜ d))) { simplify; reflexivity } { apply t1  };
end;

opaque symbol resolutionₗ x a b: π̇ (x ⟇ a) → π̇ ((¬ x) ⟇ b) → π̇ (a ++ b) ≔ begin
  assume x a b H1 H2;
  apply ⟇ₑ H1 {
    assume Hx;
    apply ⟇ₑ H2 {
      assume Hnx;
      have tmp:  πᶜ ((⟇_to_∨ᶜ_rw a ∨ᶜ ⟇_to_∨ᶜ_rw b)  ⇒ᶜ ⟇_to_∨ᶜ_rw (a ++ b)) {
        apply ∧ᶜₑ₂ (++_to_∨ᶜ a b);
      };
      apply ⇒ᶜₑ tmp;
      apply ∨ᶜₑ Hx { assume Hpi_x;  apply ∨ᶜₑ Hnx { assume Hpi_nx;  apply ¬ᶜₑ Hpi_nx Hpi_x }  {  assume Hbot; apply ⊥ᶜₑ;  apply Hbot  } } { assume Hbot; apply ⊥ᶜₑ;  apply Hbot  };
    } {
      assume Hb;
      have tmp:  πᶜ ((⟇_to_∨ᶜ_rw a ∨ᶜ ⟇_to_∨ᶜ_rw b)  ⇒ᶜ ⟇_to_∨ᶜ_rw (a ++ b)) {
        apply ∧ᶜₑ₂ (++_to_∨ᶜ a b);
      };
      apply ⇒ᶜₑ tmp;
      apply ∨ᶜᵢ₂;
      apply Hb;
    }
  } {
    assume Ha;
    apply ⟇ₑ H2 {
      assume Hnx;
      have tmp:  πᶜ ((⟇_to_∨ᶜ_rw a ∨ᶜ ⟇_to_∨ᶜ_rw b) ⇒ᶜ ⟇_to_∨ᶜ_rw (a ++ b)) {
        apply ∧ᶜₑ₂ (++_to_∨ᶜ a b);
      };
      apply ⇒ᶜₑ tmp;
      apply ∨ᶜᵢ₁;
      apply Ha
    } {
      assume Hb;
      have tmp:  πᶜ ((⟇_to_∨ᶜ_rw a ∨ᶜ ⟇_to_∨ᶜ_rw b) ⇒ᶜ ⟇_to_∨ᶜ_rw (a ++ b)) {
        apply ∧ᶜₑ₂ (++_to_∨ᶜ a b);
      };
      apply ⇒ᶜₑ  tmp;
      apply ∨ᶜᵢ₁;
      apply Ha
    }
  };
end;

opaque symbol resolutionᵣ x a b: π̇ ((¬ x) ⟇ a) → π̇ (x ⟇ b) → π̇ (a ++ b) ≔ begin
  assume x a b H1 H2;
  apply ⟇ₑ H1 {
    assume Hnx;
    apply ⟇ₑ H2 {
      assume Hx;
      have tmp:  πᶜ ((⟇_to_∨ᶜ_rw a ∨ᶜ ⟇_to_∨ᶜ_rw b) ⇒ᶜ ⟇_to_∨ᶜ_rw (a ++ b)) {
        apply ∧ᶜₑ₂ (++_to_∨ᶜ a b);
      };
      apply ⇒ᶜₑ tmp;
      apply ∨ᶜₑ Hx { assume Hpi_x;  apply ∨ᶜₑ Hnx { assume Hpi_nx;  apply ¬ᶜₑ Hpi_nx Hpi_x }  {  assume Hbot; apply ⊥ᶜₑ;  apply Hbot  } } { assume Hbot; apply ⊥ᶜₑ;  apply Hbot  };
    } {
      assume Hb;
      have tmp:  πᶜ ((⟇_to_∨ᶜ_rw a ∨ᶜ ⟇_to_∨ᶜ_rw b)  ⇒ᶜ ⟇_to_∨ᶜ_rw (a ++ b)) {
        apply ∧ᶜₑ₂ (++_to_∨ᶜ a b);
      };
      apply ⇒ᶜₑ tmp;
      apply ∨ᶜᵢ₂;
      apply Hb;
    }
  } {
    assume Ha;
    apply ⟇ₑ H2 {
      assume Hnx;
      have tmp:  πᶜ ((⟇_to_∨ᶜ_rw a ∨ᶜ ⟇_to_∨ᶜ_rw b) ⇒ᶜ ⟇_to_∨ᶜ_rw (a ++ b)) {
        apply ∧ᶜₑ₂ (++_to_∨ᶜ a b);
      };
      apply ⇒ᶜₑ tmp;
      apply ∨ᶜᵢ₁;
      apply Ha
    } {
      assume Hb;
      have tmp:  πᶜ ((⟇_to_∨ᶜ_rw a ∨ᶜ ⟇_to_∨ᶜ_rw b) ⇒ᶜ ⟇_to_∨ᶜ_rw (a ++ b)) {
        apply ∧ᶜₑ₂ (++_to_∨ᶜ a b);
      };
      apply ⇒ᶜₑ tmp;
      apply ∨ᶜᵢ₁;
      apply Ha
    }
  };
end;

opaque symbol bind_∃ [p q]: (Π x, πᶜ (p x = q x))  → πᶜ ((`∃ᶜ x, p x) = (`∃ᶜ x, q x)) ≔
begin
  assume p q H;
  apply prop_ext;
  apply ∧ᶜᵢ 
  {
    apply ⇒ᶜᵢ;
    assume H1;
    apply ∃ᶜₑ _ H1;
    assume x Hpx;
    apply ∃ᶜᵢ _ x;
    rewrite left (H x);
    apply Hpx;
  }
  {
    apply ⇒ᶜᵢ;
    assume H1;
    apply ∃ᶜₑ _ H1;
    assume x Hqx;
    apply ∃ᶜᵢ _ x;
    rewrite (H x);
    apply Hqx;
  };
end;

opaque symbol bind_∀ [a p q]: (Π (x: τ a), πᶜ (p x = q x))  → πᶜ ((`∀ᶜ (x: τ a), p x) = (`∀ᶜ (x: τ a), q x)) ≔
begin
  assume a p q H;
  apply prop_ext;
  apply ∧ᶜᵢ 
  {
    apply ⇒ᶜᵢ;
    assume H1;
    apply ∀ᶜᵢ _;
    assume x;
    have Hpx: πᶜ (p x) { apply ∀ᶜₑ x H1; };
    rewrite left (H x);
    apply Hpx;
  }
  {
    apply ⇒ᶜᵢ;
    assume H1;
    apply ∀ᶜᵢ _;
    assume x;
    have Hqx: πᶜ (q x) { apply ∀ᶜₑ x H1 };
    rewrite (H x);
    apply Hqx;
  };
end;

opaque symbol bind_∀' [a p q]: (Π (x: τ a), Π (y: τ a), πᶜ (x = y) → πᶜ (p x = q y))  → πᶜ ((`∀ᶜ (x: τ a), p x) = (`∀ᶜ (y: τ a), q y)) ≔
begin
  assume a p q;
  assume H;
  apply prop_ext;
  apply ∧ᶜᵢ 
  {
    apply ⇒ᶜᵢ;
    assume H1;
    apply ∀ᶜᵢ _;
    assume x;
    have Hpx: πᶜ (p x) { apply ∀ᶜₑ x H1; };
    rewrite left H x x (eq_reflᶜ x);
    apply Hpx
  }
  {
    apply ⇒ᶜᵢ;
    assume H1;
    apply ∀ᶜᵢ _;
    assume x;
    have Hqx: πᶜ (q x) { apply ∀ᶜₑ x H1 };
    rewrite H x x (eq_reflᶜ x);
    apply Hqx;
  };
end;

opaque symbol sko_forall [a p q]: (Π (x: τ a), πᶜ (x = `ϵ (y: τ a), ¬ (p y)) → πᶜ (p x = q))  → πᶜ ((`∀ᶜ (x: τ a), p x) = q) ≔
begin
  assume a p q H;
  apply prop_ext;
  apply ∧ᶜᵢ
  {
    apply ⇒ᶜₑ (∧ᶜₑ₂ (@contrapos (`∀ᶜ x, p x) q));
    apply ⇒ᶜᵢ;
    assume Hnq;
    rewrite .[x in ¬ x]  (ϵ_to_∀ p);
    have H1:  πᶜ (p (`ϵ x, ¬ (p x)) = q) { apply H; reflexivity };
    rewrite H1;
    apply Hnq
  }
  {
    rewrite .[x in _ ⇒ᶜ x]  (ϵ_to_∀ p);
    apply ⇒ᶜᵢ;
    assume Hq;
    have H1:  πᶜ (p (`ϵ y, ¬ (p y)) = q) { apply H; reflexivity };
    rewrite H1;
    apply Hq
  }
end;

require open Stdlib.Nat;

// Inductive t A : nat -> Type :=
//   |nil : t A 0
//   |cons : forall (h:A) (n:nat), t A n -> t A (S n).
(a: Set) inductive Vec: ℕ → TYPE ≔
| □ : Vec a 0 // \Box
| cons (n: ℕ) : τ a →  Vec a n  →  Vec a (n + 1);

constant symbol vec : Set → ℕ → Set;
rule τ (vec $a $n) ↪ Vec $a $n;

symbol distinct a n : Vec a n → Prop; 

//type (cons 2 a (cons 1 b (cons 0 c □)));

// boolean case
rule distinct o _ □ ↪ ⊤
with distinct o 2 (cons 1 $x (cons 0 $y □)) ↪ ($x ≠ $y)
with distinct o (_ +1 +1 +1) _ ↪ ⊥;

compute distinct o 2 ((cons 1 a (cons 0 b □)));
compute distinct o 3 (cons 2 a (cons _ b (cons _ c □)));

opaque symbol distinct_elim : πᶜ ((distinct o 0 □) = ⊤) ≔  eq_reflᶜ (distinct o 0 □);

opaque symbol distinct_elim₂ x y : πᶜ ((distinct o 2 ((cons _ x (cons _ y □)))) = (x ≠ y)) ≔ eq_reflᶜ (distinct o 2 (cons _ x (cons _ y □)));

opaque symbol distinct_elim₃ n (v: Vec o (n + 3)) : πᶜ (distinct o (n + 3) v = ⊥) ≔  eq_reflᶜ (distinct o (n + 3) v);

// General case for Int and Real
require open Stdlib.Z;
require open Stdlib.Pos;

rule distinct int _ (cons Stdlib.Nat.0 _ □) ↪ ⊤
with distinct int ($s Stdlib.Nat.+1 Stdlib.Nat.+1) (cons ($s Stdlib.Nat.+1) $x (cons $s $y $l)) ↪ ($x ≠ $y) ∧ᶜ (distinct int ($s Stdlib.Nat.+1) (cons $s $y $l));

assert ⊢ distinct int _ (cons _ 1 (cons _ 2 (cons _ 3 □))) ≡ ((Zpos Stdlib.Pos.H = Zpos (Stdlib.Pos.O Stdlib.Pos.H)) ⇒ ⊥) ∧ᶜ (((Zpos (Stdlib.Pos.O Stdlib.Pos.H) = Zpos (Stdlib.Pos.I Stdlib.Pos.H)) ⇒ ⊥) ∧ᶜ ⊤);

opaque symbol feqᶜ [a b] (f:τ a → τ b) [x x':τ a] : πᶜ(x = x') → πᶜ(f x = f x') ≔
begin
  assume a b f x x' xx'; rewrite xx'; reflexivity;
end;

opaque symbol feq2ᶜ [a b c] (f:τ a → τ b → τ c):
  Π [x x':τ a], πᶜ(x = x') → Π [y y':τ b], πᶜ(y = y') → πᶜ(f x y = f x' y') ≔
begin
  assume a b c f x x' xx' y y' yy'; rewrite xx'; rewrite yy'; reflexivity
end;

opaque symbol feq3ᶜ [a b c d] (f:τ a → τ b →  τ c → τ d):
  Π [x x':τ a], πᶜ(x = x') → Π [y y':τ b], πᶜ(y = y') → Π [z z':τ c], πᶜ(z = z') → πᶜ(f x y z = f x' y' z') ≔
begin
  assume a b c d f x x' xx' y y' yy' z z' zz'; rewrite xx'; rewrite yy'; rewrite zz'; reflexivity
end;
