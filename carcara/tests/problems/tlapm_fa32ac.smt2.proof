(assume a0 (forall ((smt__x Idv) (smt__y Idv)) (! (=> (forall ((smt__z Idv)) (= (smt__TLA______Mem smt__z smt__x) (smt__TLA______Mem smt__z smt__y))) (= smt__x smt__y)) :pattern ((smt__TLA______SetExtTrigger smt__x smt__y)))))
(assume a1 (forall ((smt__x Idv) (smt__y Idv)) (! (=> (forall ((smt__z Idv)) (=> (smt__TLA______Mem smt__z smt__x) (smt__TLA______Mem smt__z smt__y))) (smt__TLA______SubsetEq smt__x smt__y)) :pattern ((smt__TLA______SubsetEq smt__x smt__y)))))
(assume a2 (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (! (=> (and (smt__TLA______SubsetEq smt__x smt__y) (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y)) :pattern ((smt__TLA______SubsetEq smt__x smt__y) (smt__TLA______Mem smt__z smt__x)))))
(assume a3 (forall ((smt__a Idv) (smt__x Idv)) (! (= (smt__TLA______Mem smt__x (smt__TLA______Subset smt__a)) (smt__TLA______SubsetEq smt__x smt__a)) :pattern ((smt__TLA______Mem smt__x (smt__TLA______Subset smt__a))) :pattern ((smt__TLA______SubsetEq smt__x smt__a) (smt__TLA______Subset smt__a)))))
(assume a4 (forall ((smt__f Idv) (smt__g Idv)) (! (=> (and (smt__TLA______FunIsafcn smt__f) (smt__TLA______FunIsafcn smt__g) (= (smt__TLA______FunDom smt__f) (smt__TLA______FunDom smt__g)) (forall ((smt__x Idv)) (=> (smt__TLA______Mem smt__x (smt__TLA______FunDom smt__f)) (= (smt__TLA______FunApp smt__f smt__x) (smt__TLA______FunApp smt__g smt__x))))) (= smt__f smt__g)) :pattern ((smt__TLA______FunIsafcn smt__f) (smt__TLA______FunIsafcn smt__g)))))
(assume a5 (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (! (=> (and (smt__TLA______FunIsafcn smt__f) (= (smt__TLA______FunDom smt__f) smt__a) (forall ((smt__x Idv)) (=> (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem (smt__TLA______FunApp smt__f smt__x) smt__b)))) (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))) :pattern ((smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))))))
(assume a6 (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (! (=> (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (and (smt__TLA______FunIsafcn smt__f) (= (smt__TLA______FunDom smt__f) smt__a))) :pattern ((smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))))))
(assume a7 (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv) (smt__x Idv)) (! (=> (and (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (smt__TLA______Mem smt__x smt__a)) (smt__TLA______Mem (smt__TLA______FunApp smt__f smt__x) smt__b)) :pattern ((smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (smt__TLA______Mem smt__x smt__a)) :pattern ((smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (smt__TLA______FunApp smt__f smt__x)))))
(assume a8 (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))))
(assume a9 (not (=> (and (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (and (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) (and (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))))
(step t1 (cl (not (= (not (=> (and (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (and (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) (and (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))) (not (=> (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)) (and (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))))) (not (not (=> (and (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (and (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) (and (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))))) (not (=> (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)) (and (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))))) :rule equiv_pos2)
(step t2 (cl (= (and (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (and (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (and (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))))) :rule rare_rewrite :args ("bool-and-flatten" rare-list (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (rare-list (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (rare-list (and (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)))))
(step t3 (cl (= (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (and (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)))) :rule rare_rewrite :args ("bool-and-flatten" (rare-list (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (rare-list (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)) rare-list))
(step t4 (cl (= (and (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (and (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)))) :rule trans :premises (t2 t3))
(step t5 (cl (= (and (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (and (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))) :rule refl)
(step t6 (cl (= (=> (and (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (and (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) (and (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) (=> (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)) (and (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))))) :rule cong :premises (t4 t5))
(step t7 (cl (= (not (=> (and (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (and (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) (and (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))) (not (=> (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)) (and (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))))) :rule cong :premises (t6))
(step t8 (cl (not (=> (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)) (and (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))))) :rule resolution :premises (t1 t7 a9))
(step t9 (cl (not (and (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))) :rule not_implies2 :premises (t8))
(step t10 (cl (not (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (not (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule not_and :premises (t9))
(step t11 (cl (= (= (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) true) (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule equiv_simplify)
(step t12 (cl (not (= (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) true)) (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) :rule equiv1 :premises (t11))
(step t13 (cl (not (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc___ smt__VARIABLE___alloc______prime))) (not (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)) (= smt__VARIABLE___alloc___ smt__VARIABLE___alloc______prime)) :rule equiv_pos2)
(step t14 (cl (not (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)) (= smt__VARIABLE___alloc___ smt__VARIABLE___alloc______prime) (not (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc___ smt__VARIABLE___alloc______prime)))) :rule reordering :premises (t13))
(step t15 (cl (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) :rule not_implies1 :premises (t8))
(step t16 (cl (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)) :rule and :premises (t15))
(step t17 (cl (not (= (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc___ smt__VARIABLE___alloc______prime))))) (not (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)))) (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc___ smt__VARIABLE___alloc______prime)))) :rule equiv_pos2)
(step t18 (cl (= (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))))) :rule refl)
(step t19 (cl (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) :rule refl)
(step t20 (cl (= (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc___ smt__VARIABLE___alloc______prime))) :rule rare_rewrite :args ("eq-symm" smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))
(step t21 (cl (= (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc___ smt__VARIABLE___alloc______prime)))) :rule cong :premises (t19 t20))
(step t22 (cl (= (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc___ smt__VARIABLE___alloc______prime))))) :rule cong :premises (t18 t21))
(step t23 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) :rule implies_neg1)
(anchor :step t24)
(assume t24.a0 (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))))
(step t24.t1 (cl (or (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)))) :rule forall_inst :args ((:= smt__x smt__VARIABLE___alloc______prime) (:= smt__y smt__VARIABLE___alloc___)))
(step t24.t2 (cl (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) :rule or :premises (t24.t1))
(step t24.t3 (cl (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) :rule resolution :premises (t24.t2 t24.a0))
(step t24 (cl (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) :rule subproof :discharge (t24.a0))
(step t25 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) :rule resolution :premises (t23 t24))
(step t26 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) (not (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)))) :rule implies_neg2)
(step t27 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___))) (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)))) :rule resolution :premises (t25 t26))
(step t28 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)))) :rule contraction :premises (t27))
(step t29 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc___ smt__VARIABLE___alloc______prime)))) :rule resolution :premises (t17 t22 t28))
(step t30 (cl (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc___ smt__VARIABLE___alloc______prime))) :rule implies :premises (t29))
(step t31 (cl (= (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___) (= smt__VARIABLE___alloc___ smt__VARIABLE___alloc______prime))) :rule resolution :premises (t30 a8))
(step t32 (cl (= smt__VARIABLE___alloc___ smt__VARIABLE___alloc______prime)) :rule resolution :premises (t14 t16 t31))
(step t33 (cl (= smt__VARIABLE___alloc______prime smt__VARIABLE___alloc___)) :rule symm :premises (t32))
(step t34 (cl (= (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)) (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) :rule refl)
(step t35 (cl (= (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule cong :premises (t33 t34))
(step t36 (cl (= (= (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) true) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule equiv_simplify)
(step t37 (cl (= (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) true) (not (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule equiv2 :premises (t36))
(step t38 (cl (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) :rule and :premises (t15))
(step t39 (cl (= (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) true)) :rule resolution :premises (t37 t38))
(step t40 (cl (= (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) true)) :rule trans :premises (t35 t39))
(step t41 (cl (smt__TLA______Mem smt__VARIABLE___alloc______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) :rule resolution :premises (t12 t40))
(step t42 (cl (= (= (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) true) (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule equiv_simplify)
(step t43 (cl (not (= (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) true)) (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) :rule equiv1 :premises (t42))
(step t44 (cl (not (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat___ smt__VARIABLE___unsat______prime))) (not (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___)) (= smt__VARIABLE___unsat___ smt__VARIABLE___unsat______prime)) :rule equiv_pos2)
(step t45 (cl (not (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___)) (= smt__VARIABLE___unsat___ smt__VARIABLE___unsat______prime) (not (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat___ smt__VARIABLE___unsat______prime)))) :rule reordering :premises (t44))
(step t46 (cl (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___)) :rule and :premises (t15))
(step t47 (cl (not (= (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___))) (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat___ smt__VARIABLE___unsat______prime))))) (not (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___)))) (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat___ smt__VARIABLE___unsat______prime)))) :rule equiv_pos2)
(step t48 (cl (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___))) :rule refl)
(step t49 (cl (= (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat___ smt__VARIABLE___unsat______prime))) :rule rare_rewrite :args ("eq-symm" smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___))
(step t50 (cl (= (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___)) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat___ smt__VARIABLE___unsat______prime)))) :rule cong :premises (t48 t49))
(step t51 (cl (= (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___))) (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat___ smt__VARIABLE___unsat______prime))))) :rule cong :premises (t18 t50))
(step t52 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___))) (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) :rule implies_neg1)
(anchor :step t53)
(assume t53.a0 (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))))
(step t53.t1 (cl (or (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___)))) :rule forall_inst :args ((:= smt__x smt__VARIABLE___unsat______prime) (:= smt__y smt__VARIABLE___unsat___)))
(step t53.t2 (cl (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___))) :rule or :premises (t53.t1))
(step t53.t3 (cl (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___))) :rule resolution :premises (t53.t2 t53.a0))
(step t53 (cl (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___))) :rule subproof :discharge (t53.a0))
(step t54 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___))) :rule resolution :premises (t52 t53))
(step t55 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___))) (not (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___)))) :rule implies_neg2)
(step t56 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___))) (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___)))) :rule resolution :premises (t54 t55))
(step t57 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___)))) :rule contraction :premises (t56))
(step t58 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat___ smt__VARIABLE___unsat______prime)))) :rule resolution :premises (t47 t51 t57))
(step t59 (cl (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat___ smt__VARIABLE___unsat______prime))) :rule implies :premises (t58))
(step t60 (cl (= (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___) (= smt__VARIABLE___unsat___ smt__VARIABLE___unsat______prime))) :rule resolution :premises (t59 a8))
(step t61 (cl (= smt__VARIABLE___unsat___ smt__VARIABLE___unsat______prime)) :rule resolution :premises (t45 t46 t60))
(step t62 (cl (= smt__VARIABLE___unsat______prime smt__VARIABLE___unsat___)) :rule symm :premises (t61))
(step t63 (cl (= (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule cong :premises (t62 t34))
(step t64 (cl (= (= (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) true) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule equiv_simplify)
(step t65 (cl (= (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) true) (not (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule equiv2 :premises (t64))
(step t66 (cl (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) :rule and :premises (t15))
(step t67 (cl (= (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) true)) :rule resolution :premises (t65 t66))
(step t68 (cl (= (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) true)) :rule trans :premises (t63 t67))
(step t69 (cl (smt__TLA______Mem smt__VARIABLE___unsat______prime (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) :rule resolution :premises (t43 t68))
(step t70 (cl) :rule resolution :premises (t10 t41 t69))

