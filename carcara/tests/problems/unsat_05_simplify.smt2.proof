unsat
(assume a0 (not (p a)))
(assume a1 (forall ((x1 U)) (or (not (= x1 a)) (p x1))))
(assume a2 (forall ((x1 U) (x2 U) (x3 U)) (or (not (= x2 (f x3))) (or (not (= x3 a)) (q x1 x2 x3)))))
(step t1 (cl (not (= (forall ((x1 U)) (or (not (= x1 a)) (p x1))) (p a))) (not (forall ((x1 U)) (or (not (= x1 a)) (p x1)))) (p a)) :rule equiv_pos2)
(anchor :step t2 :args ((x1 U) (:= x1 x1)))
(step t2.t1 (cl (= x1 x1)) :rule refl)
(step t2.t2 (cl (= (= x1 a) (= a x1))) :rule rare_rewrite :args ("eq-symm" x1 a))
(step t2.t3 (cl (= (not (= x1 a)) (not (= a x1)))) :rule cong :premises (t2.t2))
(step t2.t4 (cl (= (p x1) (p x1))) :rule refl)
(step t2.t5 (cl (= (or (not (= x1 a)) (p x1)) (or (not (= a x1)) (p x1)))) :rule cong :premises (t2.t3 t2.t4))
(step t2 (cl (= (forall ((x1 U)) (or (not (= x1 a)) (p x1))) (forall ((x1 U)) (or (not (= a x1)) (p x1))))) :rule bind)
(step t3 (cl (= (forall ((x1 U)) (or (not (= a x1)) (p x1))) (or (not (= a a)) (p a)))) :rule all_simplify)
(step t4 (cl (= (= a a) true)) :rule rare_rewrite :args ("eq-refl" a))
(step t5 (cl (= (not (= a a)) (not true))) :rule cong :premises (t4))
(step t6 (cl (= (not true) false)) :rule rare_rewrite :args ("evaluate"))
(step t7 (cl (= (not (= a a)) false)) :rule trans :premises (t5 t6))
(step t8 (cl (= (p a) (p a))) :rule refl)
(step t9 (cl (= (or (not (= a a)) (p a)) (or false (p a)))) :rule cong :premises (t7 t8))
(step t10 (cl (= (or false (p a)) (p a))) :rule rare_rewrite :args ("bool-or-false" rare-list (rare-list (p a))))
(step t11 (cl (= (or (not (= a a)) (p a)) (p a))) :rule trans :premises (t9 t10))
(step t12 (cl (= (forall ((x1 U)) (or (not (= a x1)) (p x1))) (p a))) :rule trans :premises (t3 t11))
(step t13 (cl (= (forall ((x1 U)) (or (not (= x1 a)) (p x1))) (p a))) :rule trans :premises (t2 t12))
(step t14 (cl (p a)) :rule resolution :premises (t1 t13 a1))
(step t15 (cl) :rule resolution :premises (t14 a0))

