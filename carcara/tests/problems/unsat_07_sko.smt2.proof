(define-fun veriT_sk0 () U (choice ((veriT_vr3 U)) (p veriT_vr3)))
(assume h1 (not (=> (forall ((x1 U)) (not (p x1))) (not (exists ((x1 U)) (p x1))))))
(assume h2 (= (not (exists ((x1 U)) (p x1))) true))
(anchor :step t3 :args ((veriT_vr0 U) (:= x1 veriT_vr0)))
(step t3.t1 (cl (= x1 veriT_vr0)) :rule refl)
(step t3.t2 (cl (= (p x1) (p veriT_vr0))) :rule cong :premises (t3.t1))
(step t3.t3 (cl (= (not (p x1)) (not (p veriT_vr0)))) :rule cong :premises (t3.t2))
(step t3 (cl (= (forall ((x1 U)) (not (p x1))) (forall ((veriT_vr0 U)) (not (p veriT_vr0))))) :rule bind)
(anchor :step t4 :args ((veriT_vr0 U) (:= x1 veriT_vr0)))
(step t4.t1 (cl (= x1 veriT_vr0)) :rule refl)
(step t4.t2 (cl (= (p x1) (p veriT_vr0))) :rule cong :premises (t4.t1))
(step t4 (cl (= (exists ((x1 U)) (p x1)) (exists ((veriT_vr0 U)) (p veriT_vr0)))) :rule bind)
(step t5 (cl (= (not (exists ((x1 U)) (p x1))) (not (exists ((veriT_vr0 U)) (p veriT_vr0))))) :rule cong :premises (t4))
(step t6 (cl (= (=> (forall ((x1 U)) (not (p x1))) (not (exists ((x1 U)) (p x1)))) (=> (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (exists ((veriT_vr0 U)) (p veriT_vr0)))))) :rule cong :premises (t3 t5))
(step t7 (cl (= (not (=> (forall ((x1 U)) (not (p x1))) (not (exists ((x1 U)) (p x1))))) (not (=> (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (exists ((veriT_vr0 U)) (p veriT_vr0))))))) :rule cong :premises (t6))
(step t8 (cl (not (= (not (=> (forall ((x1 U)) (not (p x1))) (not (exists ((x1 U)) (p x1))))) (not (=> (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (exists ((veriT_vr0 U)) (p veriT_vr0))))))) (not (not (=> (forall ((x1 U)) (not (p x1))) (not (exists ((x1 U)) (p x1)))))) (not (=> (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (exists ((veriT_vr0 U)) (p veriT_vr0)))))) :rule equiv_pos2)
(step t9 (cl (not (not (not (=> (forall ((x1 U)) (not (p x1))) (not (exists ((x1 U)) (p x1))))))) (=> (forall ((x1 U)) (not (p x1))) (not (exists ((x1 U)) (p x1))))) :rule not_not)
(step t10 (cl (not (= (not (=> (forall ((x1 U)) (not (p x1))) (not (exists ((x1 U)) (p x1))))) (not (=> (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (exists ((veriT_vr0 U)) (p veriT_vr0))))))) (=> (forall ((x1 U)) (not (p x1))) (not (exists ((x1 U)) (p x1)))) (not (=> (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (exists ((veriT_vr0 U)) (p veriT_vr0)))))) :rule th_resolution :premises (t9 t8))
(step t11 (cl (not (=> (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (exists ((veriT_vr0 U)) (p veriT_vr0)))))) :rule th_resolution :premises (h1 t7 t10))
(step t12 (cl (= (not (=> (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (exists ((veriT_vr0 U)) (p veriT_vr0))))) (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (not (exists ((veriT_vr0 U)) (p veriT_vr0))))))) :rule bool_simplify)
(step t13 (cl (not (= (not (=> (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (exists ((veriT_vr0 U)) (p veriT_vr0))))) (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (not (exists ((veriT_vr0 U)) (p veriT_vr0))))))) (not (not (=> (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (exists ((veriT_vr0 U)) (p veriT_vr0)))))) (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (not (exists ((veriT_vr0 U)) (p veriT_vr0)))))) :rule equiv_pos2)
(step t14 (cl (not (not (not (=> (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (exists ((veriT_vr0 U)) (p veriT_vr0))))))) (=> (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (exists ((veriT_vr0 U)) (p veriT_vr0))))) :rule not_not)
(step t15 (cl (not (= (not (=> (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (exists ((veriT_vr0 U)) (p veriT_vr0))))) (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (not (exists ((veriT_vr0 U)) (p veriT_vr0))))))) (=> (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (exists ((veriT_vr0 U)) (p veriT_vr0)))) (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (not (exists ((veriT_vr0 U)) (p veriT_vr0)))))) :rule th_resolution :premises (t14 t13))
(step t16 (cl (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (not (exists ((veriT_vr0 U)) (p veriT_vr0)))))) :rule th_resolution :premises (t11 t12 t15))
(step t17 (cl (= (not (not (exists ((veriT_vr0 U)) (p veriT_vr0)))) (exists ((veriT_vr0 U)) (p veriT_vr0)))) :rule not_simplify)
(step t18 (cl (= (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (not (exists ((veriT_vr0 U)) (p veriT_vr0))))) (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (exists ((veriT_vr0 U)) (p veriT_vr0))))) :rule cong :premises (t17))
(step t19 (cl (not (= (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (not (exists ((veriT_vr0 U)) (p veriT_vr0))))) (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (exists ((veriT_vr0 U)) (p veriT_vr0))))) (not (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (not (not (exists ((veriT_vr0 U)) (p veriT_vr0)))))) (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (exists ((veriT_vr0 U)) (p veriT_vr0)))) :rule equiv_pos2)
(step t20 (cl (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (exists ((veriT_vr0 U)) (p veriT_vr0)))) :rule th_resolution :premises (t16 t18 t19))
(anchor :step t21 :args ((veriT_vr1 U) (:= veriT_vr0 veriT_vr1)))
(step t21.t1 (cl (= veriT_vr0 veriT_vr1)) :rule refl)
(step t21.t2 (cl (= (p veriT_vr0) (p veriT_vr1))) :rule cong :premises (t21.t1))
(step t21 (cl (= (exists ((veriT_vr0 U)) (p veriT_vr0)) (exists ((veriT_vr1 U)) (p veriT_vr1)))) :rule bind)
(step t22 (cl (= (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (exists ((veriT_vr0 U)) (p veriT_vr0))) (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (exists ((veriT_vr1 U)) (p veriT_vr1))))) :rule cong :premises (t21))
(step t23 (cl (not (= (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (exists ((veriT_vr0 U)) (p veriT_vr0))) (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (exists ((veriT_vr1 U)) (p veriT_vr1))))) (not (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (exists ((veriT_vr0 U)) (p veriT_vr0)))) (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (exists ((veriT_vr1 U)) (p veriT_vr1)))) :rule equiv_pos2)
(step t24 (cl (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (exists ((veriT_vr1 U)) (p veriT_vr1)))) :rule th_resolution :premises (t20 t22 t23))
(anchor :step t25 :args ((veriT_vr2 U) (:= veriT_vr0 veriT_vr2)))
(step t25.t1 (cl (= veriT_vr0 veriT_vr2)) :rule refl)
(step t25.t2 (cl (= (p veriT_vr0) (p veriT_vr2))) :rule cong :premises (t25.t1))
(step t25.t3 (cl (= (not (p veriT_vr0)) (not (p veriT_vr2)))) :rule cong :premises (t25.t2))
(step t25 (cl (= (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (forall ((veriT_vr2 U)) (not (p veriT_vr2))))) :rule bind)
(anchor :step t26 :args ((veriT_vr3 U) (:= veriT_vr1 veriT_vr3)))
(step t26.t1 (cl (= veriT_vr1 veriT_vr3)) :rule refl)
(step t26.t2 (cl (= (p veriT_vr1) (p veriT_vr3))) :rule cong :premises (t26.t1))
(step t26 (cl (= (exists ((veriT_vr1 U)) (p veriT_vr1)) (exists ((veriT_vr3 U)) (p veriT_vr3)))) :rule bind)
(step t27 (cl (= (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (exists ((veriT_vr1 U)) (p veriT_vr1))) (and (forall ((veriT_vr2 U)) (not (p veriT_vr2))) (exists ((veriT_vr3 U)) (p veriT_vr3))))) :rule cong :premises (t25 t26))
(step t28 (cl (not (= (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (exists ((veriT_vr1 U)) (p veriT_vr1))) (and (forall ((veriT_vr2 U)) (not (p veriT_vr2))) (exists ((veriT_vr3 U)) (p veriT_vr3))))) (not (and (forall ((veriT_vr0 U)) (not (p veriT_vr0))) (exists ((veriT_vr1 U)) (p veriT_vr1)))) (and (forall ((veriT_vr2 U)) (not (p veriT_vr2))) (exists ((veriT_vr3 U)) (p veriT_vr3)))) :rule equiv_pos2)
(step t29 (cl (and (forall ((veriT_vr2 U)) (not (p veriT_vr2))) (exists ((veriT_vr3 U)) (p veriT_vr3)))) :rule th_resolution :premises (t24 t27 t28))
(anchor :step t30 :args ((:= veriT_vr3 veriT_sk0)))
(step t30.t1 (cl (= veriT_vr3 veriT_sk0)) :rule refl)
(step t30.t2 (cl (= (p veriT_vr3) (p veriT_sk0))) :rule cong :premises (t30.t1))
(step t30 (cl (= (exists ((veriT_vr3 U)) (p veriT_vr3)) (p veriT_sk0))) :rule sko_ex)
(step t31 (cl (= (and (forall ((veriT_vr2 U)) (not (p veriT_vr2))) (exists ((veriT_vr3 U)) (p veriT_vr3))) (and (forall ((veriT_vr2 U)) (not (p veriT_vr2))) (p veriT_sk0)))) :rule cong :premises (t30))
(step t32 (cl (not (= (and (forall ((veriT_vr2 U)) (not (p veriT_vr2))) (exists ((veriT_vr3 U)) (p veriT_vr3))) (and (forall ((veriT_vr2 U)) (not (p veriT_vr2))) (p veriT_sk0)))) (not (and (forall ((veriT_vr2 U)) (not (p veriT_vr2))) (exists ((veriT_vr3 U)) (p veriT_vr3)))) (and (forall ((veriT_vr2 U)) (not (p veriT_vr2))) (p veriT_sk0))) :rule equiv_pos2)
(step t33 (cl (and (forall ((veriT_vr2 U)) (not (p veriT_vr2))) (p veriT_sk0))) :rule th_resolution :premises (t29 t31 t32))
(anchor :step t34 :args ((veriT_vr4 U) (:= veriT_vr2 veriT_vr4)))
(step t34.t1 (cl (= veriT_vr2 veriT_vr4)) :rule refl)
(step t34.t2 (cl (= (p veriT_vr2) (p veriT_vr4))) :rule cong :premises (t34.t1))
(step t34.t3 (cl (= (not (p veriT_vr2)) (not (p veriT_vr4)))) :rule cong :premises (t34.t2))
(step t34 (cl (= (forall ((veriT_vr2 U)) (not (p veriT_vr2))) (forall ((veriT_vr4 U)) (not (p veriT_vr4))))) :rule bind)
(step t35 (cl (= (and (forall ((veriT_vr2 U)) (not (p veriT_vr2))) (p veriT_sk0)) (and (forall ((veriT_vr4 U)) (not (p veriT_vr4))) (p veriT_sk0)))) :rule cong :premises (t34))
(step t36 (cl (not (= (and (forall ((veriT_vr2 U)) (not (p veriT_vr2))) (p veriT_sk0)) (and (forall ((veriT_vr4 U)) (not (p veriT_vr4))) (p veriT_sk0)))) (not (and (forall ((veriT_vr2 U)) (not (p veriT_vr2))) (p veriT_sk0))) (and (forall ((veriT_vr4 U)) (not (p veriT_vr4))) (p veriT_sk0))) :rule equiv_pos2)
(step t37 (cl (and (forall ((veriT_vr4 U)) (not (p veriT_vr4))) (p veriT_sk0))) :rule th_resolution :premises (t33 t35 t36))
(anchor :step t38 :args ((veriT_vr5 U) (:= x1 veriT_vr5)))
(step t38.t1 (cl (= x1 veriT_vr5)) :rule refl)
(step t38.t2 (cl (= (p x1) (p veriT_vr5))) :rule cong :premises (t38.t1))
(step t38 (cl (= (exists ((x1 U)) (p x1)) (exists ((veriT_vr5 U)) (p veriT_vr5)))) :rule bind)
(step t39 (cl (= (not (exists ((x1 U)) (p x1))) (not (exists ((veriT_vr5 U)) (p veriT_vr5))))) :rule cong :premises (t38))
(step t40 (cl (= (= (not (exists ((x1 U)) (p x1))) true) (= (not (exists ((veriT_vr5 U)) (p veriT_vr5))) true))) :rule cong :premises (t39))
(step t41 (cl (not (= (= (not (exists ((x1 U)) (p x1))) true) (= (not (exists ((veriT_vr5 U)) (p veriT_vr5))) true))) (not (= (not (exists ((x1 U)) (p x1))) true)) (= (not (exists ((veriT_vr5 U)) (p veriT_vr5))) true)) :rule equiv_pos2)
(step t42 (cl (= (not (exists ((veriT_vr5 U)) (p veriT_vr5))) true)) :rule th_resolution :premises (h2 t40 t41))
(step t43 (cl (= (= (not (exists ((veriT_vr5 U)) (p veriT_vr5))) true) (not (exists ((veriT_vr5 U)) (p veriT_vr5))))) :rule equiv_simplify)
(step t44 (cl (not (= (= (not (exists ((veriT_vr5 U)) (p veriT_vr5))) true) (not (exists ((veriT_vr5 U)) (p veriT_vr5))))) (not (= (not (exists ((veriT_vr5 U)) (p veriT_vr5))) true)) (not (exists ((veriT_vr5 U)) (p veriT_vr5)))) :rule equiv_pos2)
(step t45 (cl (not (exists ((veriT_vr5 U)) (p veriT_vr5)))) :rule th_resolution :premises (t42 t43 t44))
(anchor :step t46 :args ((veriT_vr6 U) (:= veriT_vr5 veriT_vr6)))
(step t46.t1 (cl (= veriT_vr5 veriT_vr6)) :rule refl)
(step t46.t2 (cl (= (p veriT_vr5) (p veriT_vr6))) :rule cong :premises (t46.t1))
(step t46 (cl (= (exists ((veriT_vr5 U)) (p veriT_vr5)) (exists ((veriT_vr6 U)) (p veriT_vr6)))) :rule bind)
(step t47 (cl (= (not (exists ((veriT_vr5 U)) (p veriT_vr5))) (not (exists ((veriT_vr6 U)) (p veriT_vr6))))) :rule cong :premises (t46))
(step t48 (cl (not (= (not (exists ((veriT_vr5 U)) (p veriT_vr5))) (not (exists ((veriT_vr6 U)) (p veriT_vr6))))) (not (not (exists ((veriT_vr5 U)) (p veriT_vr5)))) (not (exists ((veriT_vr6 U)) (p veriT_vr6)))) :rule equiv_pos2)
(step t49 (cl (not (not (not (exists ((veriT_vr5 U)) (p veriT_vr5))))) (exists ((veriT_vr5 U)) (p veriT_vr5))) :rule not_not)
(step t50 (cl (not (= (not (exists ((veriT_vr5 U)) (p veriT_vr5))) (not (exists ((veriT_vr6 U)) (p veriT_vr6))))) (exists ((veriT_vr5 U)) (p veriT_vr5)) (not (exists ((veriT_vr6 U)) (p veriT_vr6)))) :rule th_resolution :premises (t49 t48))
(step t51 (cl (not (exists ((veriT_vr6 U)) (p veriT_vr6)))) :rule th_resolution :premises (t45 t47 t50))
(step t52 (cl (= (exists ((veriT_vr6 U)) (p veriT_vr6)) (not (forall ((veriT_vr6 U)) (not (p veriT_vr6)))))) :rule connective_def)
(step t53 (cl (= (not (exists ((veriT_vr6 U)) (p veriT_vr6))) (not (not (forall ((veriT_vr6 U)) (not (p veriT_vr6))))))) :rule cong :premises (t52))
(step t54 (cl (not (= (not (exists ((veriT_vr6 U)) (p veriT_vr6))) (not (not (forall ((veriT_vr6 U)) (not (p veriT_vr6))))))) (not (not (exists ((veriT_vr6 U)) (p veriT_vr6)))) (not (not (forall ((veriT_vr6 U)) (not (p veriT_vr6)))))) :rule equiv_pos2)
(step t55 (cl (not (not (not (exists ((veriT_vr6 U)) (p veriT_vr6))))) (exists ((veriT_vr6 U)) (p veriT_vr6))) :rule not_not)
(step t56 (cl (not (= (not (exists ((veriT_vr6 U)) (p veriT_vr6))) (not (not (forall ((veriT_vr6 U)) (not (p veriT_vr6))))))) (exists ((veriT_vr6 U)) (p veriT_vr6)) (not (not (forall ((veriT_vr6 U)) (not (p veriT_vr6)))))) :rule th_resolution :premises (t55 t54))
(step t57 (cl (not (not (not (forall ((veriT_vr6 U)) (not (p veriT_vr6)))))) (forall ((veriT_vr6 U)) (not (p veriT_vr6)))) :rule not_not)
(step t58 (cl (not (= (not (exists ((veriT_vr6 U)) (p veriT_vr6))) (not (not (forall ((veriT_vr6 U)) (not (p veriT_vr6))))))) (exists ((veriT_vr6 U)) (p veriT_vr6)) (forall ((veriT_vr6 U)) (not (p veriT_vr6)))) :rule th_resolution :premises (t57 t56))
(step t59 (cl (not (not (forall ((veriT_vr6 U)) (not (p veriT_vr6)))))) :rule th_resolution :premises (t51 t53 t58))
(step t60 (cl (not (not (not (forall ((veriT_vr6 U)) (not (p veriT_vr6)))))) (forall ((veriT_vr6 U)) (not (p veriT_vr6)))) :rule not_not)
(step t61 (cl (forall ((veriT_vr6 U)) (not (p veriT_vr6)))) :rule th_resolution :premises (t60 t59))
(step t62 (cl (= (not (not (forall ((veriT_vr6 U)) (not (p veriT_vr6))))) (forall ((veriT_vr6 U)) (not (p veriT_vr6))))) :rule not_simplify)
(step t63 (cl (not (= (not (not (forall ((veriT_vr6 U)) (not (p veriT_vr6))))) (forall ((veriT_vr6 U)) (not (p veriT_vr6))))) (not (not (not (forall ((veriT_vr6 U)) (not (p veriT_vr6)))))) (forall ((veriT_vr6 U)) (not (p veriT_vr6)))) :rule equiv_pos2)
(step t64 (cl (not (not (not (not (forall ((veriT_vr6 U)) (not (p veriT_vr6))))))) (not (forall ((veriT_vr6 U)) (not (p veriT_vr6))))) :rule not_not)
(step t65 (cl (not (= (not (not (forall ((veriT_vr6 U)) (not (p veriT_vr6))))) (forall ((veriT_vr6 U)) (not (p veriT_vr6))))) (not (forall ((veriT_vr6 U)) (not (p veriT_vr6)))) (forall ((veriT_vr6 U)) (not (p veriT_vr6)))) :rule th_resolution :premises (t64 t63))
(step t66 (cl true) :rule tautology :premises (t65))
(step t67 (cl (forall ((veriT_vr6 U)) (not (p veriT_vr6)))) :rule hole :premises (t61 t62 t66))
(step t68 (cl (forall ((veriT_vr4 U)) (not (p veriT_vr4)))) :rule and :premises (t37))
(step t69 (cl (p veriT_sk0)) :rule and :premises (t37))
(step t70 (cl (or (not (forall ((veriT_vr4 U)) (not (p veriT_vr4)))) (forall ((veriT_vr4 U)) (not (p veriT_vr4))))) :rule qnt_cnf)
(step t71 (cl (or (not (forall ((veriT_vr6 U)) (not (p veriT_vr6)))) (forall ((veriT_vr6 U)) (not (p veriT_vr6))))) :rule qnt_cnf)
(step t72 (cl (or (not (forall ((veriT_vr6 U)) (not (p veriT_vr6)))) (not (p veriT_sk0)))) :rule forall_inst :args ((:= veriT_vr6 veriT_sk0)))
(step t73 (cl (or (not (forall ((veriT_vr4 U)) (not (p veriT_vr4)))) (not (p veriT_sk0)))) :rule forall_inst :args ((:= veriT_vr4 veriT_sk0)))
(step t74 (cl (not (forall ((veriT_vr6 U)) (not (p veriT_vr6)))) (not (p veriT_sk0))) :rule or :premises (t72))
(step t75 (cl) :rule resolution :premises (t74 t69 t67))
(step t76 (cl (not (forall ((veriT_vr4 U)) (not (p veriT_vr4)))) (not (p veriT_sk0))) :rule or :premises (t73))
