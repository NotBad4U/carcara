(assume a0 (forall ((smt__x Idv) (smt__y Idv)) (! (=> (forall ((smt__z Idv)) (= (smt__TLA______Mem smt__z smt__x) (smt__TLA______Mem smt__z smt__y))) (= smt__x smt__y)) :pattern ((smt__TLA______SetExtTrigger smt__x smt__y)))))
(assume a1 (forall ((smt__x Idv) (smt__y Idv)) (! (=> (forall ((smt__z Idv)) (=> (smt__TLA______Mem smt__z smt__x) (smt__TLA______Mem smt__z smt__y))) (smt__TLA______SubsetEq smt__x smt__y)) :pattern ((smt__TLA______SubsetEq smt__x smt__y)))))
(assume a2 (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (! (=> (and (smt__TLA______SubsetEq smt__x smt__y) (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y)) :pattern ((smt__TLA______SubsetEq smt__x smt__y) (smt__TLA______Mem smt__z smt__x)))))
(assume a3 (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (=> (and (smt__TLA______Mem smt__y smt__a) (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)))))
(assume a4 (forall ((smt__a Idv) (smt__x Idv)) (! (=> (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)) (exists ((smt__y Idv)) (and (smt__TLA______Mem smt__y smt__a) (smt__TLA______Mem smt__x smt__y)))) :pattern ((smt__TLA______Mem smt__x (smt__TLA______Union smt__a))))))
(assume a5 (forall ((smt__a Idv) (smt__x Idv)) (! (= (smt__TLA______Mem smt__x (smt__TLA______Subset smt__a)) (smt__TLA______SubsetEq smt__x smt__a)) :pattern ((smt__TLA______Mem smt__x (smt__TLA______Subset smt__a))) :pattern ((smt__TLA______SubsetEq smt__x smt__a) (smt__TLA______Subset smt__a)))))
(assume a6 (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))))
(assume a7 (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______SetMinus smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (not (smt__TLA______Mem smt__x smt__b))))))
(assume a8 (forall ((smt__f Idv) (smt__g Idv)) (! (=> (and (smt__TLA______FunIsafcn smt__f) (smt__TLA______FunIsafcn smt__g) (= (smt__TLA______FunDom smt__f) (smt__TLA______FunDom smt__g)) (forall ((smt__x Idv)) (=> (smt__TLA______Mem smt__x (smt__TLA______FunDom smt__f)) (= (smt__TLA______FunApp smt__f smt__x) (smt__TLA______FunApp smt__g smt__x))))) (= smt__f smt__g)) :pattern ((smt__TLA______FunIsafcn smt__f) (smt__TLA______FunIsafcn smt__g)))))
(assume a9 (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (! (=> (and (smt__TLA______FunIsafcn smt__f) (= (smt__TLA______FunDom smt__f) smt__a) (forall ((smt__x Idv)) (=> (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem (smt__TLA______FunApp smt__f smt__x) smt__b)))) (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))) :pattern ((smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))))))
(assume a10 (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (! (=> (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (and (smt__TLA______FunIsafcn smt__f) (= (smt__TLA______FunDom smt__f) smt__a))) :pattern ((smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))))))
(assume a11 (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv) (smt__x Idv)) (! (=> (and (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (smt__TLA______Mem smt__x smt__a)) (smt__TLA______Mem (smt__TLA______FunApp smt__f smt__x) smt__b)) :pattern ((smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (smt__TLA______Mem smt__x smt__a)) :pattern ((smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (smt__TLA______FunApp smt__f smt__x)))))
(assume a12 (forall ((smt__x Idv) (smt__y Idv)) (! (smt__TLA______SetExtTrigger (smt__TLA______Cap smt__x smt__y) smt__TLA______SetEnum___0) :pattern ((smt__TLA______Cap smt__x smt__y)))))
(assume a13 (forall ((smt__a Idv) (smt__b Idv)) (! (smt__TLA______SetExtTrigger smt__a smt__b) :pattern ((smt__TLA______IsSetOf smt__a) (smt__TLA______IsSetOf smt__b)))))
(assume a14 (forall ((smt__x Idv)) (! (not (smt__TLA______Mem smt__x smt__TLA______SetEnum___0)) :pattern ((smt__TLA______Mem smt__x smt__TLA______SetEnum___0)))))
(assume a15 (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))))
(assume a16 (smt__TLA______Mem smt__CONSTANT___clt___ smt__CONSTANT___Client___))
(assume a17 (smt__TLA______Mem smt__CONSTANT___S___ (smt__TLA______Subset smt__CONSTANT___Resource___)))
(assume a18 (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___))
(assume a19 (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___))
(assume a20 (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___))
(assume a21 (and (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (= smt__STATE___Mutex___ smt__TLA______Tt___Idv) (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) smt__TLA______Tt___Idv)))
(assume a22 (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))
(assume a23 (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))
(assume a24 (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)))
(assume a25 (forall ((smt__a1 Idv) (smt__y1 Idv)) (=> (smt__TLA______Mem smt__y1 smt__a1) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__y1) (smt__TLA______SetOf___1___flatnd___1 smt__a1)))))
(assume a26 (forall ((smt__a1 Idv) (smt__x Idv)) (! (=> (smt__TLA______Mem smt__x (smt__TLA______SetOf___1___flatnd___1 smt__a1)) (exists ((smt__y1 Idv)) (and (smt__TLA______Mem smt__y1 smt__a1) (= smt__x (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__y1))))) :pattern ((smt__TLA______Mem smt__x (smt__TLA______SetOf___1___flatnd___1 smt__a1))))))
(assume a27 (forall ((smt__a Idv)) (! (smt__TLA______IsSetOf (smt__TLA______SetOf___1___flatnd___1 smt__a)) :pattern ((smt__TLA______SetOf___1___flatnd___1 smt__a)))))
(assume a28 (not (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______SetMinus smt__CONSTANT___Resource___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))))))
(step t1 (cl (=> (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)))) (or (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a))))) :rule implies_neg1)
(anchor :step t2)
(assume t2.a0 (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)))))
(step t2.t1 (cl (or (not (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a))))) (or (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))))) :rule forall_inst :args ((:= smt__a (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)) (:= smt__x smt__CONSTANT___r___) (:= smt__y (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))
(step t2.t2 (cl (not (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a))))) (or (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) :rule or :premises (t2.t1))
(step t2.t3 (cl (not (= (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (=> (and (smt__TLA______Mem smt__y smt__a) (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)))) (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)))))) (not (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (=> (and (smt__TLA______Mem smt__y smt__a) (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a))))) (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a))))) :rule equiv_pos2)
(step t2.t4 (cl (= (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (=> (and (smt__TLA______Mem smt__y smt__a) (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)))) (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)))))) :rule all_simplify)
(step t2.t5 (cl (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a))))) :rule resolution :premises (t2.t3 t2.t4 a3))
(step t2.t6 (cl (or (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) :rule resolution :premises (t2.t2 t2.t5))
(step t2 (cl (not (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a))))) (or (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) :rule subproof :discharge (t2.a0))
(step t3 (cl (=> (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)))) (or (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) (or (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) :rule resolution :premises (t1 t2))
(step t4 (cl (=> (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)))) (or (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) (not (or (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))))) :rule implies_neg2)
(step t5 (cl (=> (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)))) (or (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) (=> (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)))) (or (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))))) :rule resolution :premises (t3 t4))
(step t6 (cl (=> (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)))) (or (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))))) :rule contraction :premises (t5))
(step t7 (cl (not (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a))))) (or (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) :rule implies :premises (t6))
(step t8 (cl (not (or (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))) :rule or_pos)
(step t9 (cl (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (not (or (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))))) :rule reordering :premises (t8))
(step t10 (cl (not (and (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) :rule and_pos)
(step t11 (cl (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))) (not (and (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))))) :rule reordering :premises (t10))
(step t12 (cl (not (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______SetMinus smt__CONSTANT___Resource___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______SetMinus smt__CONSTANT___Resource___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))))) :rule equiv_pos2)
(step t13 (cl (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______SetMinus smt__CONSTANT___Resource___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) (not (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______SetMinus smt__CONSTANT___Resource___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))))))) :rule reordering :premises (t12))
(step t14 (cl (not (= (not (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______SetMinus smt__CONSTANT___Resource___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______SetMinus smt__CONSTANT___Resource___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))))) (not (not (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______SetMinus smt__CONSTANT___Resource___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______SetMinus smt__CONSTANT___Resource___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) :rule equiv_pos2)
(step t15 (cl (= (not (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______SetMinus smt__CONSTANT___Resource___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______SetMinus smt__CONSTANT___Resource___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))))) :rule rare_rewrite :args ("bool-double-not-elim" (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______SetMinus smt__CONSTANT___Resource___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))))
(step t16 (cl (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______SetMinus smt__CONSTANT___Resource___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) :rule resolution :premises (t14 t15 a28))
(step t17 (cl (or (not (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______SetMinus smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (not (smt__TLA______Mem smt__x smt__b)))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______SetMinus smt__CONSTANT___Resource___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))))))) :rule forall_inst :args ((:= smt__a smt__CONSTANT___Resource___) (:= smt__b (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (:= smt__x smt__CONSTANT___r___)))
(step t18 (cl (not (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______SetMinus smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (not (smt__TLA______Mem smt__x smt__b)))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______SetMinus smt__CONSTANT___Resource___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))))) :rule or :premises (t17))
(step t19 (cl (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______SetMinus smt__CONSTANT___Resource___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))))) :rule resolution :premises (t18 a7))
(step t20 (cl (and (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))))) :rule resolution :premises (t13 t16 t19))
(step t21 (cl (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) :rule resolution :premises (t11 t20))
(step t22 (cl (not (or (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) :rule or_pos)
(step t23 (cl (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)) (not (or (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) :rule reordering :premises (t22))
(step t24 (cl (or (not (forall ((smt__a1 Idv) (smt__y1 Idv)) (or (not (smt__TLA______Mem smt__y1 smt__a1)) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__y1) (smt__TLA______SetOf___1___flatnd___1 smt__a1))))) (or (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))))) :rule forall_inst :args ((:= smt__a1 smt__CONSTANT___Client___) (:= smt__y1 smt__CONSTANT___c1___)))
(step t25 (cl (not (forall ((smt__a1 Idv) (smt__y1 Idv)) (or (not (smt__TLA______Mem smt__y1 smt__a1)) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__y1) (smt__TLA______SetOf___1___flatnd___1 smt__a1))))) (or (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))) :rule or :premises (t24))
(step t26 (cl (not (= (forall ((smt__a1 Idv) (smt__y1 Idv)) (=> (smt__TLA______Mem smt__y1 smt__a1) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__y1) (smt__TLA______SetOf___1___flatnd___1 smt__a1)))) (forall ((smt__a1 Idv) (smt__y1 Idv)) (or (not (smt__TLA______Mem smt__y1 smt__a1)) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__y1) (smt__TLA______SetOf___1___flatnd___1 smt__a1)))))) (not (forall ((smt__a1 Idv) (smt__y1 Idv)) (=> (smt__TLA______Mem smt__y1 smt__a1) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__y1) (smt__TLA______SetOf___1___flatnd___1 smt__a1))))) (forall ((smt__a1 Idv) (smt__y1 Idv)) (or (not (smt__TLA______Mem smt__y1 smt__a1)) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__y1) (smt__TLA______SetOf___1___flatnd___1 smt__a1))))) :rule equiv_pos2)
(anchor :step t27 :args ((smt__a1 Idv) (:= smt__a1 smt__a1) (smt__y1 Idv) (:= smt__y1 smt__y1)))
(step t27.t1 (cl (= smt__a1 smt__a1)) :rule refl)
(step t27.t2 (cl (= smt__y1 smt__y1)) :rule refl)
(step t27.t3 (cl (= (=> (smt__TLA______Mem smt__y1 smt__a1) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__y1) (smt__TLA______SetOf___1___flatnd___1 smt__a1))) (or (not (smt__TLA______Mem smt__y1 smt__a1)) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__y1) (smt__TLA______SetOf___1___flatnd___1 smt__a1))))) :rule rare_rewrite :args ("bool-impl-elim" (smt__TLA______Mem smt__y1 smt__a1) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__y1) (smt__TLA______SetOf___1___flatnd___1 smt__a1))))
(step t27 (cl (= (forall ((smt__a1 Idv) (smt__y1 Idv)) (=> (smt__TLA______Mem smt__y1 smt__a1) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__y1) (smt__TLA______SetOf___1___flatnd___1 smt__a1)))) (forall ((smt__a1 Idv) (smt__y1 Idv)) (or (not (smt__TLA______Mem smt__y1 smt__a1)) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__y1) (smt__TLA______SetOf___1___flatnd___1 smt__a1)))))) :rule bind)
(step t28 (cl (forall ((smt__a1 Idv) (smt__y1 Idv)) (or (not (smt__TLA______Mem smt__y1 smt__a1)) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__y1) (smt__TLA______SetOf___1___flatnd___1 smt__a1))))) :rule resolution :premises (t26 t27 a25))
(step t29 (cl (or (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))) :rule resolution :premises (t25 t28))
(step t30 (cl (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) :rule resolution :premises (t23 a18 t29))
(step t31 (cl (= (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)) true) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))) :rule equiv_simplify)
(step t32 (cl (not (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)) true)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) :rule equiv1 :premises (t31))
(step t33 (cl (= smt__CONSTANT___r___ smt__CONSTANT___r___)) :rule refl)
(step t34 (cl (not (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))) (not (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) :rule equiv_pos2)
(step t35 (cl (not (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)) (not (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))) :rule reordering :premises (t34))
(step t36 (cl (or (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))) :rule forall_inst :args ((:= smt__x (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (:= smt__y (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))
(step t37 (cl (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))) :rule or :premises (t36))
(step t38 (cl (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))) :rule resolution :premises (t37 a15))
(step t39 (cl (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) :rule resolution :premises (t35 a23 t38))
(step t40 (cl (= (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___))) :rule symm :premises (t39))
(step t41 (cl (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)))) :rule cong :premises (t33 t40))
(step t42 (cl (= (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) true) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)))) :rule equiv_simplify)
(step t43 (cl (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) true) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)))) :rule equiv2 :premises (t42))
(step t44 (cl (not (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___))) :rule and_pos)
(step t45 (cl (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (not (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) :rule reordering :premises (t44))
(step t46 (cl (not (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) :rule equiv_pos2)
(step t47 (cl (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (not (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))))) :rule reordering :premises (t46))
(step t48 (cl (or (not (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))))) :rule forall_inst :args ((:= smt__a (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (:= smt__b (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (:= smt__x smt__CONSTANT___r___)))
(step t49 (cl (not (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) :rule or :premises (t48))
(step t50 (cl (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) :rule resolution :premises (t49 a6))
(step t51 (cl (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) :rule resolution :premises (t47 a22 t50))
(step t52 (cl (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___))) :rule resolution :premises (t45 t51))
(step t53 (cl (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) true)) :rule resolution :premises (t43 t52))
(step t54 (cl (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)) true)) :rule trans :premises (t41 t53))
(step t55 (cl (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) :rule resolution :premises (t32 t54))
(step t56 (cl (not (or (not (smt__TLA______Mem (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Union (smt__TLA______SetOf___1___flatnd___1 smt__CONSTANT___Client___)))))) :rule resolution :premises (t9 t21 t30 t55))
(step t57 (cl (not (= (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (=> (and (smt__TLA______Mem smt__y smt__a) (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)))) (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)))))) (not (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (=> (and (smt__TLA______Mem smt__y smt__a) (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a))))) (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a))))) :rule equiv_pos2)
(step t58 (cl (= (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (=> (and (smt__TLA______Mem smt__y smt__a) (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)))) (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a)))))) :rule all_simplify)
(step t59 (cl (forall ((smt__a Idv) (smt__x Idv) (smt__y Idv)) (or (not (smt__TLA______Mem smt__y smt__a)) (not (smt__TLA______Mem smt__x smt__y)) (smt__TLA______Mem smt__x (smt__TLA______Union smt__a))))) :rule resolution :premises (t57 t58 a3))
(step t60 (cl) :rule resolution :premises (t7 t56 t59))

