(assume a0 (forall ((smt__x Idv) (smt__y Idv)) (! (=> (forall ((smt__z Idv)) (= (smt__TLA______Mem smt__z smt__x) (smt__TLA______Mem smt__z smt__y))) (= smt__x smt__y)) :pattern ((smt__TLA______SetExtTrigger smt__x smt__y)))))
(assume a1 (forall ((smt__x Idv) (smt__y Idv)) (! (=> (forall ((smt__z Idv)) (=> (smt__TLA______Mem smt__z smt__x) (smt__TLA______Mem smt__z smt__y))) (smt__TLA______SubsetEq smt__x smt__y)) :pattern ((smt__TLA______SubsetEq smt__x smt__y)))))
(assume a2 (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (and (smt__TLA______SubsetEq smt__x smt__y) (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y))))
(assume a3 (forall ((smt__a Idv) (smt__x Idv)) (! (= (smt__TLA______Mem smt__x (smt__TLA______Subset smt__a)) (smt__TLA______SubsetEq smt__x smt__a)) :pattern ((smt__TLA______Mem smt__x (smt__TLA______Subset smt__a))) :pattern ((smt__TLA______SubsetEq smt__x smt__a) (smt__TLA______Subset smt__a)))))
(assume a4 (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (! (= (smt__TLA______Mem smt__x (smt__TLA______Cup smt__a smt__b)) (or (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))) :pattern ((smt__TLA______Mem smt__x (smt__TLA______Cup smt__a smt__b))) :pattern ((smt__TLA______Mem smt__x smt__a) (smt__TLA______Cup smt__a smt__b)) :pattern ((smt__TLA______Mem smt__x smt__b) (smt__TLA______Cup smt__a smt__b)))))
(assume a5 (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))))
(assume a6 (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (! (= (smt__TLA______Mem smt__x (smt__TLA______SetMinus smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (not (smt__TLA______Mem smt__x smt__b)))) :pattern ((smt__TLA______Mem smt__x (smt__TLA______SetMinus smt__a smt__b))) :pattern ((smt__TLA______Mem smt__x smt__a) (smt__TLA______SetMinus smt__a smt__b)) :pattern ((smt__TLA______Mem smt__x smt__b) (smt__TLA______SetMinus smt__a smt__b)))))
(assume a7 (forall ((smt__f Idv) (smt__g Idv)) (! (=> (and (smt__TLA______FunIsafcn smt__f) (smt__TLA______FunIsafcn smt__g) (= (smt__TLA______FunDom smt__f) (smt__TLA______FunDom smt__g)) (forall ((smt__x Idv)) (=> (smt__TLA______Mem smt__x (smt__TLA______FunDom smt__f)) (= (smt__TLA______FunApp smt__f smt__x) (smt__TLA______FunApp smt__g smt__x))))) (= smt__f smt__g)) :pattern ((smt__TLA______FunIsafcn smt__f) (smt__TLA______FunIsafcn smt__g)))))
(assume a8 (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv)) (! (smt__TLA______FunIsafcn (smt__TLA______FunExcept smt__f smt__x smt__y)) :pattern ((smt__TLA______FunExcept smt__f smt__x smt__y)))))
(assume a9 (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv)) (! (= (smt__TLA______FunDom (smt__TLA______FunExcept smt__f smt__x smt__y)) (smt__TLA______FunDom smt__f)) :pattern ((smt__TLA______FunExcept smt__f smt__x smt__y)))))
(assume a10 (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv)) (! (=> (smt__TLA______Mem smt__x (smt__TLA______FunDom smt__f)) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__x) smt__y)) :pattern ((smt__TLA______FunExcept smt__f smt__x smt__y)))))
(assume a11 (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (! (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) smt__y)) (=> (distinct smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))) :pattern ((smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z)) :pattern ((smt__TLA______FunExcept smt__f smt__x smt__y) (smt__TLA______FunApp smt__f smt__z)))))
(assume a12 (forall ((smt__x Idv) (smt__y Idv)) (! (smt__TLA______SetExtTrigger (smt__TLA______Cap smt__x smt__y) smt__TLA______SetEnum___0) :pattern ((smt__TLA______Cap smt__x smt__y)))))
(assume a13 (forall ((smt__x Idv)) (! (not (smt__TLA______Mem smt__x smt__TLA______SetEnum___0)) :pattern ((smt__TLA______Mem smt__x smt__TLA______SetEnum___0)))))
(assume a14 (forall ((smt__x Idv) (smt__y Idv)) (! (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)) :pattern ((smt__TLA______TrigEq___Idv smt__x smt__y)))))
(assume a15 (forall ((smt__x Idv) (smt__y Idv)) (! (= (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__x smt__y) (= smt__x smt__y)) :pattern ((smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__x smt__y)))))
(assume a16 (forall ((smt__x Idv) (smt__y Idv)) (! (smt__TLA______SetExtTrigger smt__x smt__y) :pattern ((smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__x smt__y)))))
(assume a17 (smt__TLA______Mem smt__CONSTANT___clt___ smt__CONSTANT___Client___))
(assume a18 (smt__TLA______Mem smt__CONSTANT___S___ (smt__TLA______Subset smt__CONSTANT___Resource___)))
(assume a19 (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___))
(assume a20 (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___))
(assume a21 (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___))
(assume a22 (and (= smt__STATE___TypeInvariant___ smt__TLA______Tt___Idv) (= smt__STATE___Mutex___ smt__TLA______Tt___Idv) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))))
(assume a23 (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime (smt__TLA______FunExcept smt__VARIABLE___alloc___ smt__CONSTANT___clt___ (smt__TLA______Cup (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___clt___) smt__CONSTANT___S___))))
(assume a24 (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime (smt__TLA______FunExcept smt__VARIABLE___unsat___ smt__CONSTANT___clt___ (smt__TLA______SetMinus (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___) smt__CONSTANT___S___))))
(assume a25 (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))
(assume a26 (not (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___)))
(assume a27 (not (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___))))
(step t1 (cl (not (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) :rule equiv_pos2)
(step t2 (cl (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule reordering :premises (t1))
(step t3 (cl (not (or (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) :rule or_pos)
(step t4 (cl (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (not (or (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule reordering :premises (t3))
(step t5 (cl (not (= (not (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___))) (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___))) (not (not (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)))) (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) :rule equiv_pos2)
(step t6 (cl (= (not (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___))) (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___))) :rule all_simplify)
(step t7 (cl (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) :rule resolution :premises (t5 t6 a27))
(step t8 (cl (not (= (and (= smt__STATE___TypeInvariant___ smt__TLA______Tt___Idv) (= smt__STATE___Mutex___ smt__TLA______Tt___Idv) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) (not (and (= smt__STATE___TypeInvariant___ smt__TLA______Tt___Idv) (= smt__STATE___Mutex___ smt__TLA______Tt___Idv) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule equiv_pos2)
(step t9 (cl (= (and (= smt__STATE___TypeInvariant___ smt__TLA______Tt___Idv) (= smt__STATE___Mutex___ smt__TLA______Tt___Idv) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) (and (= smt__STATE___TypeInvariant___ smt__TLA______Tt___Idv) (= smt__STATE___Mutex___ smt__TLA______Tt___Idv) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule all_simplify)
(step t10 (cl (= (= smt__STATE___TypeInvariant___ smt__TLA______Tt___Idv) (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___))) :rule all_simplify)
(step t11 (cl (= (= smt__STATE___Mutex___ smt__TLA______Tt___Idv) (= smt__TLA______Tt___Idv smt__STATE___Mutex___))) :rule all_simplify)
(step t12 (cl (= (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)))) :rule refl)
(step t13 (cl (= (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule refl)
(step t14 (cl (= (and (= smt__STATE___TypeInvariant___ smt__TLA______Tt___Idv) (= smt__STATE___Mutex___ smt__TLA______Tt___Idv) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (and (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___) (= smt__TLA______Tt___Idv smt__STATE___Mutex___) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule cong :premises (t10 t11 t12 t13))
(step t15 (cl (= (and (= smt__STATE___TypeInvariant___ smt__TLA______Tt___Idv) (= smt__STATE___Mutex___ smt__TLA______Tt___Idv) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) (and (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___) (= smt__TLA______Tt___Idv smt__STATE___Mutex___) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule trans :premises (t9 t14))
(step t16 (cl (and (= smt__STATE___TypeInvariant___ smt__STATE___Mutex___) (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___)) (not (= smt__STATE___TypeInvariant___ smt__STATE___Mutex___)) (not (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___))) :rule and_neg)
(step t17 (cl (not (= (= smt__TLA______Tt___Idv smt__STATE___Mutex___) (= smt__STATE___TypeInvariant___ smt__STATE___Mutex___))) (not (= smt__TLA______Tt___Idv smt__STATE___Mutex___)) (= smt__STATE___TypeInvariant___ smt__STATE___Mutex___)) :rule equiv_pos2)
(step t18 (cl (not (= (and (= smt__STATE___TypeInvariant___ smt__TLA______Tt___Idv) (= smt__STATE___Mutex___ smt__TLA______Tt___Idv) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) (and (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___) (= smt__TLA______Tt___Idv smt__STATE___Mutex___) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) (not (and (= smt__STATE___TypeInvariant___ smt__TLA______Tt___Idv) (= smt__STATE___Mutex___ smt__TLA______Tt___Idv) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) (and (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___) (= smt__TLA______Tt___Idv smt__STATE___Mutex___) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule equiv_pos2)
(step t19 (cl (and (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___) (= smt__TLA______Tt___Idv smt__STATE___Mutex___) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule resolution :premises (t18 t15 a22))
(step t20 (cl (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___)) :rule and :premises (t19))
(step t21 (cl (= smt__STATE___Mutex___ smt__STATE___Mutex___)) :rule refl)
(step t22 (cl (= (= smt__TLA______Tt___Idv smt__STATE___Mutex___) (= smt__STATE___TypeInvariant___ smt__STATE___Mutex___))) :rule cong :premises (t20 t21))
(step t23 (cl (not (= (and (= smt__STATE___TypeInvariant___ smt__TLA______Tt___Idv) (= smt__STATE___Mutex___ smt__TLA______Tt___Idv) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) (and (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___) (= smt__TLA______Tt___Idv smt__STATE___Mutex___) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) (not (and (= smt__STATE___TypeInvariant___ smt__TLA______Tt___Idv) (= smt__STATE___Mutex___ smt__TLA______Tt___Idv) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) (and (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___) (= smt__TLA______Tt___Idv smt__STATE___Mutex___) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule equiv_pos2)
(step t24 (cl (and (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___) (= smt__TLA______Tt___Idv smt__STATE___Mutex___) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule resolution :premises (t23 t15 a22))
(step t25 (cl (= smt__TLA______Tt___Idv smt__STATE___Mutex___)) :rule and :premises (t24))
(step t26 (cl (= smt__STATE___TypeInvariant___ smt__STATE___Mutex___)) :rule resolution :premises (t17 t22 t25))
(step t27 (cl (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___)) :rule and :premises (t19))
(step t28 (cl (and (= smt__STATE___TypeInvariant___ smt__STATE___Mutex___) (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___))) :rule resolution :premises (t16 t26 t27))
(step t29 (cl (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___)) :rule and :premises (t28))
(step t30 (cl (= smt__STATE___TypeInvariant___ smt__STATE___Mutex___)) :rule and :premises (t28))
(step t31 (cl (= smt__TLA______Tt___Idv smt__STATE___Mutex___)) :rule trans :premises (t29 t30))
(step t32 (cl (= (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___) (= smt__STATE___Mutex___ smt__STATE___Mutex___))) :rule cong :premises (t31 t30))
(step t33 (cl (= smt__STATE___Mutex___ smt__STATE___Mutex___)) :rule refl)
(step t34 (cl (= (= smt__TLA______Tt___Idv smt__STATE___Mutex___) (= smt__STATE___Mutex___ smt__STATE___Mutex___))) :rule cong :premises (t31 t33))
(step t35 (cl (= (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)))) :rule refl)
(step t36 (cl (= (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule refl)
(step t37 (cl (= (and (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___) (= smt__TLA______Tt___Idv smt__STATE___Mutex___) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (and (= smt__STATE___Mutex___ smt__STATE___Mutex___) (= smt__STATE___Mutex___ smt__STATE___Mutex___) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule cong :premises (t32 t34 t35 t36))
(step t38 (cl (= (= smt__STATE___Mutex___ smt__STATE___Mutex___) true)) :rule all_simplify)
(step t39 (cl (= (and (= smt__STATE___Mutex___ smt__STATE___Mutex___) (= smt__STATE___Mutex___ smt__STATE___Mutex___) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (and true true (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule cong :premises (t38 t38 t12 t13))
(step t40 (cl (= (and true true (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule all_simplify)
(step t41 (cl (= (and (= smt__STATE___Mutex___ smt__STATE___Mutex___) (= smt__STATE___Mutex___ smt__STATE___Mutex___) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule trans :premises (t39 t40))
(step t42 (cl (= (and (= smt__TLA______Tt___Idv smt__STATE___TypeInvariant___) (= smt__TLA______Tt___Idv smt__STATE___Mutex___) (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule trans :premises (t37 t41))
(step t43 (cl (= (and (= smt__STATE___TypeInvariant___ smt__TLA______Tt___Idv) (= smt__STATE___Mutex___ smt__TLA______Tt___Idv) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule trans :premises (t15 t42))
(step t44 (cl (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule resolution :premises (t8 t43 a22))
(step t45 (cl (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) :rule and :premises (t44))
(step t46 (cl (=> (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______SubsetEq smt__x smt__y)) (not (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y))) (or (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______SubsetEq smt__x smt__y)) (not (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y)))) :rule implies_neg1)
(anchor :step t47)
(assume t47.a0 (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______SubsetEq smt__x smt__y)) (not (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y))))
(step t47.t1 (cl (or (not (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______SubsetEq smt__x smt__y)) (not (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y)))) (or (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule forall_inst :args ((:= smt__x smt__CONSTANT___S___) (:= smt__y (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (:= smt__z smt__CONSTANT___r___)))
(step t47.t2 (cl (not (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______SubsetEq smt__x smt__y)) (not (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y)))) (or (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule or :premises (t47.t1))
(step t47.t3 (cl (or (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule resolution :premises (t47.t2 t47.a0))
(step t47 (cl (not (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______SubsetEq smt__x smt__y)) (not (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y)))) (or (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule subproof :discharge (t47.a0))
(step t48 (cl (=> (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______SubsetEq smt__x smt__y)) (not (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y))) (or (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) (or (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule resolution :premises (t46 t47))
(step t49 (cl (=> (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______SubsetEq smt__x smt__y)) (not (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y))) (or (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) (not (or (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule implies_neg2)
(step t50 (cl (=> (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______SubsetEq smt__x smt__y)) (not (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y))) (or (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) (=> (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______SubsetEq smt__x smt__y)) (not (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y))) (or (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule resolution :premises (t48 t49))
(step t51 (cl (=> (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______SubsetEq smt__x smt__y)) (not (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y))) (or (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule contraction :premises (t50))
(step t52 (cl (not (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______SubsetEq smt__x smt__y)) (not (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y)))) (or (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule implies :premises (t51))
(step t53 (cl (not (= (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (and (smt__TLA______SubsetEq smt__x smt__y) (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y))) (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______SubsetEq smt__x smt__y)) (not (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y))))) (not (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (and (smt__TLA______SubsetEq smt__x smt__y) (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y)))) (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______SubsetEq smt__x smt__y)) (not (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y)))) :rule equiv_pos2)
(step t54 (cl (= (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (and (smt__TLA______SubsetEq smt__x smt__y) (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y))) (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______SubsetEq smt__x smt__y)) (not (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y))))) :rule all_simplify)
(step t55 (cl (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______SubsetEq smt__x smt__y)) (not (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y)))) :rule resolution :premises (t53 t54 a2))
(step t56 (cl (or (not (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule resolution :premises (t52 t55))
(step t57 (cl (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) :rule resolution :premises (t4 t7 t45 t56))
(step t58 (cl (not (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))) (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___)) :rule and_pos)
(step t59 (cl (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (not (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule reordering :premises (t58))
(step t60 (cl (not (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule resolution :premises (t59 a26))
(step t61 (cl (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) :rule implies_neg1)
(anchor :step t62)
(assume t62.a0 (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))))
(step t62.t1 (cl (or (not (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule forall_inst :args ((:= smt__a smt__STATE___available___) (:= smt__b (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)) (:= smt__x smt__CONSTANT___r___)))
(step t62.t2 (cl (not (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule or :premises (t62.t1))
(step t62.t3 (cl (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule resolution :premises (t62.t2 t62.a0))
(step t62 (cl (not (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule subproof :discharge (t62.a0))
(step t63 (cl (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule resolution :premises (t61 t62))
(step t64 (cl (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) (not (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule implies_neg2)
(step t65 (cl (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule resolution :premises (t63 t64))
(step t66 (cl (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___)))))) :rule contraction :premises (t65))
(step t67 (cl (not (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule implies :premises (t66))
(step t68 (cl (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap smt__STATE___available___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))) (and (smt__TLA______Mem smt__CONSTANT___r___ smt__STATE___available___) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___))))) :rule resolution :premises (t67 a5))
(step t69 (cl) :rule resolution :premises (t2 t57 t60 t68))

