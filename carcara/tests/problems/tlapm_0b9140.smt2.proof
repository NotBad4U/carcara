(assume a0 (forall ((smt__x Idv) (smt__y Idv)) (! (=> (forall ((smt__z Idv)) (= (smt__TLA______Mem smt__z smt__x) (smt__TLA______Mem smt__z smt__y))) (= smt__x smt__y)) :pattern ((smt__TLA______SetExtTrigger smt__x smt__y)))))
(assume a1 (forall ((smt__x Idv) (smt__y Idv)) (! (=> (forall ((smt__z Idv)) (=> (smt__TLA______Mem smt__z smt__x) (smt__TLA______Mem smt__z smt__y))) (smt__TLA______SubsetEq smt__x smt__y)) :pattern ((smt__TLA______SubsetEq smt__x smt__y)))))
(assume a2 (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (! (=> (and (smt__TLA______SubsetEq smt__x smt__y) (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y)) :pattern ((smt__TLA______SubsetEq smt__x smt__y) (smt__TLA______Mem smt__z smt__x)))))
(assume a3 (forall ((smt__a Idv) (smt__x Idv)) (! (= (smt__TLA______Mem smt__x (smt__TLA______Subset smt__a)) (smt__TLA______SubsetEq smt__x smt__a)) :pattern ((smt__TLA______Mem smt__x (smt__TLA______Subset smt__a))) :pattern ((smt__TLA______SubsetEq smt__x smt__a) (smt__TLA______Subset smt__a)))))
(assume a4 (forall ((smt__x Idv) (smt__y Idv)) (! (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)) :pattern ((smt__TLA______TrigEq___Idv smt__x smt__y)))))
(assume a5 (smt__TLA______Mem smt__CONSTANT___clt___ smt__CONSTANT___Client___))
(assume a6 (smt__TLA______Mem smt__CONSTANT___S___ (smt__TLA______Subset smt__CONSTANT___Resource___)))
(assume a7 (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___))
(assume a8 (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___))
(assume a9 (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___))
(assume a10 (=> (not (or (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___clt___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___clt___))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)))
(assume a11 (=> (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___clt___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)))
(assume a12 (=> (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___clt___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)))
(assume a13 (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)))
(step t1 (cl (not (not (not (or (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___clt___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___clt___))))) (or (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___clt___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___clt___))) :rule not_not)
(step t2 (cl (not (not (or (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___clt___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___clt___)))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)) :rule implies :premises (a10))
(step t3 (cl (not (not (or (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___clt___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___clt___))))) :rule resolution :premises (t2 a13))
(step t4 (cl (or (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___clt___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___clt___))) :rule resolution :premises (t1 t3))
(step t5 (cl (not (or (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___clt___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___clt___))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___clt___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___clt___)) :rule or_pos)
(step t6 (cl (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___clt___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)) :rule implies :premises (a11))
(step t7 (cl (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___clt___))) :rule resolution :premises (t6 a13))
(step t8 (cl (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___clt___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)) :rule implies :premises (a12))
(step t9 (cl (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___clt___))) :rule resolution :premises (t8 a13))
(step t10 (cl (not (or (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___clt___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___clt___)))) :rule resolution :premises (t5 t7 t9))
(step t11 (cl) :rule resolution :premises (t4 t10))

