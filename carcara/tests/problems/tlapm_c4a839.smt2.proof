(assume a0 (forall ((smt__x Idv) (smt__y Idv)) (! (=> (forall ((smt__z Idv)) (= (smt__TLA__Mem smt__z smt__x) (smt__TLA__Mem smt__z smt__y))) (= smt__x smt__y)) :pattern ((smt__TLA__SetExtTrigger smt__x smt__y)))))
(assume a1 (forall ((smt__x Idv) (smt__y Idv)) (! (=> (forall ((smt__z Idv)) (=> (smt__TLA__Mem smt__z smt__x) (smt__TLA__Mem smt__z smt__y))) (smt__TLA__SubsetEq smt__x smt__y)) :pattern ((smt__TLA__SubsetEq smt__x smt__y)))))
(assume a2 (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (! (=> (and (smt__TLA__SubsetEq smt__x smt__y) (smt__TLA__Mem smt__z smt__x)) (smt__TLA__Mem smt__z smt__y)) :pattern ((smt__TLA__SubsetEq smt__x smt__y) (smt__TLA__Mem smt__z smt__x)))))
(assume a3 (forall ((smt__a Idv) (smt__x Idv)) (! (= (smt__TLA__Mem smt__x (smt__TLA__Subset smt__a)) (smt__TLA__SubsetEq smt__x smt__a)) :pattern ((smt__TLA__Mem smt__x (smt__TLA__Subset smt__a))) :pattern ((smt__TLA__SubsetEq smt__x smt__a) (smt__TLA__Subset smt__a)))))
(assume a4 (forall ((smt__f Idv) (smt__g Idv)) (! (=> (and (smt__TLA__FunIsafcn smt__f) (smt__TLA__FunIsafcn smt__g) (= (smt__TLA__FunDom smt__f) (smt__TLA__FunDom smt__g)) (forall ((smt__x Idv)) (=> (smt__TLA__Mem smt__x (smt__TLA__FunDom smt__f)) (= (smt__TLA__FunApp smt__f smt__x) (smt__TLA__FunApp smt__g smt__x))))) (= smt__f smt__g)) :pattern ((smt__TLA__FunIsafcn smt__f) (smt__TLA__FunIsafcn smt__g)))))
(assume a5 (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (! (=> (and (smt__TLA__FunIsafcn smt__f) (= (smt__TLA__FunDom smt__f) smt__a) (forall ((smt__x Idv)) (=> (smt__TLA__Mem smt__x smt__a) (smt__TLA__Mem (smt__TLA__FunApp smt__f smt__x) smt__b)))) (smt__TLA__Mem smt__f (smt__TLA__FunSet smt__a smt__b))) :pattern ((smt__TLA__Mem smt__f (smt__TLA__FunSet smt__a smt__b))))))
(assume a6 (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (! (=> (smt__TLA__Mem smt__f (smt__TLA__FunSet smt__a smt__b)) (and (smt__TLA__FunIsafcn smt__f) (= (smt__TLA__FunDom smt__f) smt__a))) :pattern ((smt__TLA__Mem smt__f (smt__TLA__FunSet smt__a smt__b))))))
(assume a7 (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv) (smt__x Idv)) (! (=> (and (smt__TLA__Mem smt__f (smt__TLA__FunSet smt__a smt__b)) (smt__TLA__Mem smt__x smt__a)) (smt__TLA__Mem (smt__TLA__FunApp smt__f smt__x) smt__b)) :pattern ((smt__TLA__Mem smt__f (smt__TLA__FunSet smt__a smt__b)) (smt__TLA__Mem smt__x smt__a)) :pattern ((smt__TLA__Mem smt__f (smt__TLA__FunSet smt__a smt__b)) (smt__TLA__FunApp smt__f smt__x)))))
(assume a8 (forall ((smt__x Idv)) (! (not (smt__TLA__Mem smt__x smt__TLA__SetEnum_0)) :pattern ((smt__TLA__Mem smt__x smt__TLA__SetEnum_0)))))
(assume a9 (smt__TLA__Mem smt__CONSTANT_f_ (smt__TLA__FunSet smt__CONSTANT_S_ (smt__TLA__Subset smt__CONSTANT_S_))))
(assume a10 (smt__TLA__Mem smt__CONSTANT_x_ smt__CONSTANT_S_))
(assume a11 (forall ((smt__a Idv) (smt__x Idv)) (! (= (smt__TLA__Mem smt__x (smt__TLA__SetSt_flatnd_1 smt__a)) (and (smt__TLA__Mem smt__x smt__a) (not (smt__TLA__Mem smt__x (smt__TLA__FunApp smt__CONSTANT_f_ smt__x))))) :pattern ((smt__TLA__Mem smt__x (smt__TLA__SetSt_flatnd_1 smt__a))) :pattern ((smt__TLA__Mem smt__x smt__a) (smt__TLA__SetSt_flatnd_1 smt__a)))))
(assume a12 (not (or (smt__TLA__Mem smt__CONSTANT_x_ (smt__TLA__SetSt_flatnd_1 smt__CONSTANT_S_)) (not (smt__TLA__Mem smt__CONSTANT_x_ (smt__TLA__SetSt_flatnd_1 smt__CONSTANT_S_))))))
(step t1 (cl (not (not (not (smt__TLA__Mem smt__CONSTANT_x_ (smt__TLA__SetSt_flatnd_1 smt__CONSTANT_S_))))) (smt__TLA__Mem smt__CONSTANT_x_ (smt__TLA__SetSt_flatnd_1 smt__CONSTANT_S_))) :rule not_not)
(step t2 (cl (not (not (smt__TLA__Mem smt__CONSTANT_x_ (smt__TLA__SetSt_flatnd_1 smt__CONSTANT_S_))))) :rule not_or :premises (a12))
(step t3 (cl (smt__TLA__Mem smt__CONSTANT_x_ (smt__TLA__SetSt_flatnd_1 smt__CONSTANT_S_))) :rule resolution :premises (t1 t2))
(step t4 (cl (not (smt__TLA__Mem smt__CONSTANT_x_ (smt__TLA__SetSt_flatnd_1 smt__CONSTANT_S_)))) :rule not_or :premises (a12))
(step t5 (cl) :rule resolution :premises (t3 t4))

