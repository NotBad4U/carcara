(assume a0 (forall ((smt__x Idv) (smt__y Idv)) (! (=> (forall ((smt__z Idv)) (= (smt__TLA______Mem smt__z smt__x) (smt__TLA______Mem smt__z smt__y))) (= smt__x smt__y)) :pattern ((smt__TLA______SetExtTrigger smt__x smt__y)))))
(assume a1 (forall ((smt__x Idv) (smt__y Idv)) (! (=> (forall ((smt__z Idv)) (=> (smt__TLA______Mem smt__z smt__x) (smt__TLA______Mem smt__z smt__y))) (smt__TLA______SubsetEq smt__x smt__y)) :pattern ((smt__TLA______SubsetEq smt__x smt__y)))))
(assume a2 (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (! (=> (and (smt__TLA______SubsetEq smt__x smt__y) (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y)) :pattern ((smt__TLA______SubsetEq smt__x smt__y) (smt__TLA______Mem smt__z smt__x)))))
(assume a3 (forall ((smt__a Idv) (smt__x Idv)) (! (= (smt__TLA______Mem smt__x (smt__TLA______Subset smt__a)) (smt__TLA______SubsetEq smt__x smt__a)) :pattern ((smt__TLA______Mem smt__x (smt__TLA______Subset smt__a))) :pattern ((smt__TLA______SubsetEq smt__x smt__a) (smt__TLA______Subset smt__a)))))
(assume a4 (forall ((smt__x Idv) (smt__y Idv)) (! (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)) :pattern ((smt__TLA______TrigEq___Idv smt__x smt__y)))))
(assume a5 (smt__TLA______Mem smt__CONSTANT___clt___ smt__CONSTANT___Client___))
(assume a6 (smt__TLA______Mem smt__CONSTANT___S___ (smt__TLA______Subset smt__CONSTANT___Resource___)))
(assume a7 (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___))
(assume a8 (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___))
(assume a9 (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___))
(assume a10 (=> (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)) false))
(assume a11 (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)))
(step t1 (cl (not (= (=> (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)) false) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___))) (not (=> (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)) false)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)) :rule equiv_pos2)
(step t2 (cl (= (=> (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)) false) (not (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___))))) :rule rare_rewrite :args ("bool-impl-false1" (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___))))
(step t3 (cl (= (not (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___))) :rule rare_rewrite :args ("bool-double-not-elim" (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)))
(step t4 (cl (= (=> (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)) false) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___))) :rule trans :premises (t2 t3))
(step t5 (cl (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)) :rule resolution :premises (t1 t4 a10))
(step t6 (cl) :rule resolution :premises (t5 a11))

