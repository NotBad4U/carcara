unsat
(assume SetExt (forall ((smt__x Idv) (smt__y Idv)) (=> (forall ((smt__z Idv)) (= (smt__TLA______Mem smt__z smt__x) (smt__TLA______Mem smt__z smt__y))) (= smt__x smt__y))))
(assume SubsetEqIntro (forall ((smt__x Idv) (smt__y Idv)) (=> (forall ((smt__z Idv)) (=> (smt__TLA______Mem smt__z smt__x) (smt__TLA______Mem smt__z smt__y))) (smt__TLA______SubsetEq smt__x smt__y))))
(assume SubsetEqElim (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (and (smt__TLA______SubsetEq smt__x smt__y) (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y))))
(assume SubsetDefAlt (forall ((smt__a Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Subset smt__a)) (smt__TLA______SubsetEq smt__x smt__a))))
(assume CupDef (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cup smt__a smt__b)) (or (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))))
(assume CapDef (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))))
(assume SetMinusDef (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______SetMinus smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (not (smt__TLA______Mem smt__x smt__b))))))
(assume FunExt (forall ((smt__f Idv) (smt__g Idv)) (=> (and (smt__TLA______FunIsafcn smt__f) (smt__TLA______FunIsafcn smt__g) (= (smt__TLA______FunDom smt__f) (smt__TLA______FunDom smt__g)) (forall ((smt__x Idv)) (=> (smt__TLA______Mem smt__x (smt__TLA______FunDom smt__f)) (= (smt__TLA______FunApp smt__f smt__x) (smt__TLA______FunApp smt__g smt__x))))) (= smt__f smt__g))))
(assume FunSetIntro (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (=> (and (smt__TLA______FunIsafcn smt__f) (= (smt__TLA______FunDom smt__f) smt__a) (forall ((smt__x Idv)) (=> (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem (smt__TLA______FunApp smt__f smt__x) smt__b)))) (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)))))
(assume FunSetElim1 (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (=> (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (and (smt__TLA______FunIsafcn smt__f) (= (smt__TLA______FunDom smt__f) smt__a)))))
(assume FunSetElim2 (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv) (smt__x Idv)) (=> (and (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (smt__TLA______Mem smt__x smt__a)) (smt__TLA______Mem (smt__TLA______FunApp smt__f smt__x) smt__b))))
(assume FunExceptIsafcn (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv)) (smt__TLA______FunIsafcn (smt__TLA______FunExcept smt__f smt__x smt__y))))
(assume FunExceptDomDef (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv)) (= (smt__TLA______FunDom (smt__TLA______FunExcept smt__f smt__x smt__y)) (smt__TLA______FunDom smt__f))))
(assume FunExceptAppDef1 (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv)) (=> (smt__TLA______Mem smt__x (smt__TLA______FunDom smt__f)) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__x) smt__y))))
(assume FunExceptAppDef2 (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) smt__y)) (=> (distinct smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))))
(assume DisjointTrigger (forall ((smt__x Idv) (smt__y Idv)) (smt__TLA______SetExtTrigger (smt__TLA______Cap smt__x smt__y) smt__TLA______SetEnum___0)))
(assume |EnumDefElim 0| (forall ((smt__x Idv)) (not (smt__TLA______Mem smt__x smt__TLA______SetEnum___0))))
(assume |ExtTrigEqDef Idv| (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))))
(assume |ExtTrigEqDef Set$Idv$| (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__x smt__y) (= smt__x smt__y))))
(assume |ExtTrigEqTrigger Idv| (forall ((smt__x Idv) (smt__y Idv)) (smt__TLA______SetExtTrigger smt__x smt__y)))
(assume a20 (smt__TLA______Mem smt__CONSTANT___clt___ smt__CONSTANT___Client___))
(assume a21 (smt__TLA______Mem smt__CONSTANT___S___ (! (smt__TLA______Subset smt__CONSTANT___Resource___) :named @p_1)))
(assume a22 (! (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___) :named @p_2))
(assume a23 (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___))
(assume a24 (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___))
(assume a25 (! (and (! (and (smt__TLA______Mem smt__VARIABLE___unsat___ (! (smt__TLA______FunSet smt__CONSTANT___Client___ @p_1) :named @p_4)) (! (smt__TLA______Mem smt__VARIABLE___alloc___ @p_4) :named @p_5)) :named @p_6) (= smt__STATE___Mutex___ smt__TLA______Tt___Idv) (and (not (smt__TLA______TrigEq___Setdollarsign___Idvdollarsign___ smt__CONSTANT___S___ smt__TLA______SetEnum___0)) (smt__TLA______SubsetEq smt__CONSTANT___S___ (smt__TLA______Cap smt__STATE___available___ (! (smt__TLA______FunApp smt__VARIABLE___unsat___ smt__CONSTANT___clt___) :named @p_3))))) :named @p_7))
(assume a26 (! (smt__TLA______TrigEq___Idv smt__VARIABLE___alloc______prime (! (smt__TLA______FunExcept smt__VARIABLE___alloc___ smt__CONSTANT___clt___ (! (smt__TLA______Cup (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___clt___) smt__CONSTANT___S___) :named @p_8)) :named @p_9)) :named @p_10))
(assume a27 (smt__TLA______TrigEq___Idv smt__VARIABLE___unsat______prime (smt__TLA______FunExcept smt__VARIABLE___unsat___ smt__CONSTANT___clt___ (smt__TLA______SetMinus @p_3 smt__CONSTANT___S___))))
(assume a28 (! (=> (! (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___clt___) :named @p_12) (! (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) :named @p_11)) :named @p_13))
(assume a29 (! (not @p_11) :named @p_14))
(assume Goal (! (not (! (smt__TLA______TrigEq___Idv (! (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) :named @p_16) (! (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___) :named @p_15)) :named @p_17)) :named @p_18))
(step t0 (cl (! (and (! (= smt__VARIABLE___alloc______prime @p_9) :named @p_19) (! (= @p_15 (! (smt__TLA______FunApp @p_9 smt__CONSTANT___c1___) :named @p_28)) :named @p_29)) :named @p_94) (! (not @p_19) :named @p_92) (! (not @p_29) :named @p_93)) :rule and_neg)
(step t1 (cl (! (=> @p_94 (! (= @p_16 @p_15) :named @p_24)) :named @p_96) @p_94) :rule implies_neg1)
(anchor :step t2)
(assume t2.a0 @p_19)
(assume t2.a1 @p_29)
(step t2.t0 (cl (! (not (! (= @p_10 @p_19) :named @p_20)) :named @p_23) (! (not @p_10) :named @p_22) @p_19) :rule equiv_pos2)
(step t2.t1 (cl @p_22 @p_19 @p_23) :rule reordering :premises (t2.t0))
(step t2.t2 (cl (or (! (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) :named @p_21) @p_20)) :rule forall_inst :args ((:= smt__x smt__VARIABLE___alloc______prime) (:= smt__y @p_9)))
(step t2.t3 (cl @p_21 @p_20) :rule or :premises (t2.t2))
(step t2.t4 (cl @p_20) :rule resolution :premises (t2.t3 |ExtTrigEqDef Idv|))
(step t2.t5 (cl @p_19) :rule resolution :premises (t2.t1 a26 t2.t4))
(step t2.t6 (cl (= smt__CONSTANT___c1___ smt__CONSTANT___c1___)) :rule refl)
(step t2.t7 (cl (= @p_16 @p_28)) :rule cong :premises (t2.t5 t2.t6))
(step t2.t8 (cl (! (not (! (or (! (= smt__CONSTANT___clt___ smt__CONSTANT___c1___) :named @p_30) @p_29) :named @p_31)) :named @p_91) @p_30 @p_29) :rule or_pos)
(step t2.t9 (cl @p_30 @p_29 @p_91) :rule reordering :premises (t2.t8))
(step t2.t10 (cl (! (not (! (= @p_12 @p_30) :named @p_83)) :named @p_90) @p_12 (! (not @p_30) :named @p_32)) :rule equiv_pos1)
(step t2.t11 (cl @p_12 @p_32 @p_90) :rule reordering :premises (t2.t10))
(step t2.t12 (cl (! (not @p_12) :named @p_89) @p_11) :rule implies :premises (a28))
(step t2.t13 (cl @p_11 @p_89) :rule reordering :premises (t2.t12))
(step t2.t14 (cl @p_89) :rule resolution :premises (t2.t13 a29))
(step t2.t15 (cl (not (! (= (! (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (! (= @p_12 (! (= smt__CONSTANT___c1___ smt__CONSTANT___clt___) :named @p_85)) :named @p_86)) :named @p_87) (! (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) @p_83) :named @p_84)) :named @p_88)) (not @p_87) @p_84) :rule equiv_pos2)
(step t2.t16 (cl (= (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))))) :rule refl)
(step t2.t17 (cl (= @p_12 @p_12)) :rule refl)
(step t2.t18 (cl (= @p_85 @p_30)) :rule rare_rewrite :args ("eq-symm" smt__CONSTANT___c1___ smt__CONSTANT___clt___))
(step t2.t19 (cl (= @p_86 @p_83)) :rule cong :premises (t2.t17 t2.t18))
(step t2.t20 (cl @p_88) :rule cong :premises (t2.t16 t2.t19))
(step t2.t21 (cl @p_87 (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) :rule implies_neg1)
(anchor :step t2.t22)
(assume t2.t22.a0 (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))))
(step t2.t22.t0 (cl (or @p_21 @p_86)) :rule forall_inst :args ((:= smt__x smt__CONSTANT___c1___) (:= smt__y smt__CONSTANT___clt___)))
(step t2.t22.t1 (cl @p_21 @p_86) :rule or :premises (t2.t22.t0))
(step t2.t22.t2 (cl @p_86) :rule resolution :premises (t2.t22.t1 t2.t22.a0))
(step t2.t22 (cl @p_21 @p_86) :rule subproof :discharge (t2.t22.a0))
(step t2.t23 (cl @p_87 @p_86) :rule resolution :premises (t2.t21 t2.t22))
(step t2.t24 (cl @p_87 (not @p_86)) :rule implies_neg2)
(step t2.t25 (cl @p_87 @p_87) :rule resolution :premises (t2.t23 t2.t24))
(step t2.t26 (cl @p_87) :rule contraction :premises (t2.t25))
(step t2.t27 (cl @p_84) :rule resolution :premises (t2.t15 t2.t20 t2.t26))
(step t2.t28 (cl @p_21 @p_83) :rule implies :premises (t2.t27))
(step t2.t29 (cl @p_83) :rule resolution :premises (t2.t28 |ExtTrigEqDef Idv|))
(step t2.t30 (cl @p_32) :rule resolution :premises (t2.t11 t2.t14 t2.t29))
(step t2.t31 (cl (! (not (! (and (! (or @p_32 (= @p_8 @p_28)) :named @p_33) @p_31) :named @p_34)) :named @p_82) @p_31) :rule and_pos)
(step t2.t32 (cl @p_31 @p_82) :rule reordering :premises (t2.t31))
(step t2.t33 (cl (! (not (! (or (! (not (! (smt__TLA______Mem smt__CONSTANT___c1___ (! (smt__TLA______FunDom smt__VARIABLE___alloc___) :named @p_35)) :named @p_36)) :named @p_37) @p_34) :named @p_38)) :named @p_81) @p_37 @p_34) :rule or_pos)
(step t2.t34 (cl @p_37 @p_34 @p_81) :rule reordering :premises (t2.t33))
(step t2.t35 (cl (= (! (= @p_36 true) :named @p_64) @p_36)) :rule equiv_simplify)
(step t2.t36 (cl (not @p_64) @p_36) :rule equiv1 :premises (t2.t35))
(step t2.t37 (cl (! (not (! (and (smt__TLA______FunIsafcn smt__VARIABLE___alloc___) (! (= smt__CONSTANT___Client___ @p_35) :named @p_66)) :named @p_67)) :named @p_80) @p_66) :rule and_pos)
(step t2.t38 (cl @p_66 @p_80) :rule reordering :premises (t2.t37))
(step t2.t39 (cl (! (not (! (or (! (not @p_5) :named @p_68) @p_67) :named @p_69)) :named @p_79) @p_68 @p_67) :rule or_pos)
(step t2.t40 (cl @p_68 @p_67 @p_79) :rule reordering :premises (t2.t39))
(step t2.t41 (cl @p_6) :rule and :premises (a25))
(step t2.t42 (cl @p_5) :rule and :premises (t2.t41))
(step t2.t43 (cl (or (! (not (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (or (not (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))) (and (smt__TLA______FunIsafcn smt__f) (= smt__a (smt__TLA______FunDom smt__f)))))) :named @p_78) @p_69)) :rule forall_inst :args ((:= smt__a smt__CONSTANT___Client___) (:= smt__b @p_1) (:= smt__f smt__VARIABLE___alloc___)))
(step t2.t44 (cl @p_78 @p_69) :rule or :premises (t2.t43))
(step t2.t45 (cl (not (! (= (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (=> (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (and (smt__TLA______FunIsafcn smt__f) (= (smt__TLA______FunDom smt__f) smt__a)))) (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (or (not (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))) (and (smt__TLA______FunIsafcn smt__f) (= smt__a (smt__TLA______FunDom smt__f)))))) :named @p_70)) (not (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (=> (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (and (smt__TLA______FunIsafcn smt__f) (= (smt__TLA______FunDom smt__f) smt__a))))) (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (or (not (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))) (and (smt__TLA______FunIsafcn smt__f) (= smt__a (smt__TLA______FunDom smt__f)))))) :rule equiv_pos2)
(anchor :step t2.t46 :args ((smt__a Idv) (smt__b Idv) (smt__f Idv) (:= smt__a smt__a) (:= smt__b smt__b) (:= smt__f smt__f)))
(step t2.t46.t0 (cl (= (! (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) :named @p_75) @p_75)) :rule refl)
(step t2.t46.t1 (cl (= (! (smt__TLA______FunIsafcn smt__f) :named @p_73) @p_73)) :rule refl)
(step t2.t46.t2 (cl (= (! (= (! (smt__TLA______FunDom smt__f) :named @p_71) smt__a) :named @p_76) (! (= smt__a @p_71) :named @p_72))) :rule rare_rewrite :args ("eq-symm" @p_71 smt__a))
(step t2.t46.t3 (cl (= (! (and @p_73 @p_76) :named @p_77) (! (and @p_73 @p_72) :named @p_74))) :rule cong :premises (t2.t46.t1 t2.t46.t2))
(step t2.t46.t4 (cl (= (=> @p_75 @p_77) (=> @p_75 @p_74))) :rule cong :premises (t2.t46.t0 t2.t46.t3))
(step t2.t46 (cl (= (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (=> (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (and (smt__TLA______FunIsafcn smt__f) (= (smt__TLA______FunDom smt__f) smt__a)))) (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (=> (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (and (smt__TLA______FunIsafcn smt__f) (= smt__a (smt__TLA______FunDom smt__f))))))) :rule bind)
(step t2.t47 (cl (= (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (=> (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (and (smt__TLA______FunIsafcn smt__f) (= smt__a (smt__TLA______FunDom smt__f))))) (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (or (not (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))) (and (smt__TLA______FunIsafcn smt__f) (= smt__a (smt__TLA______FunDom smt__f))))))) :rule all_simplify)
(step t2.t48 (cl @p_70) :rule trans :premises (t2.t46 t2.t47))
(step t2.t49 (cl (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (or (not (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))) (and (smt__TLA______FunIsafcn smt__f) (= smt__a (smt__TLA______FunDom smt__f)))))) :rule resolution :premises (t2.t45 t2.t48 FunSetElim1))
(step t2.t50 (cl @p_69) :rule resolution :premises (t2.t44 t2.t49))
(step t2.t51 (cl @p_67) :rule resolution :premises (t2.t40 t2.t42 t2.t50))
(step t2.t52 (cl @p_66) :rule resolution :premises (t2.t38 t2.t51))
(step t2.t53 (cl (= @p_35 smt__CONSTANT___Client___)) :rule symm :premises (t2.t52))
(step t2.t54 (cl (= @p_36 @p_2)) :rule cong :premises (t2.t6 t2.t53))
(step t2.t55 (cl (= (! (= @p_2 true) :named @p_65) @p_2)) :rule equiv_simplify)
(step t2.t56 (cl @p_65 (not @p_2)) :rule equiv2 :premises (t2.t55))
(step t2.t57 (cl @p_65) :rule resolution :premises (t2.t56 a22))
(step t2.t58 (cl @p_64) :rule trans :premises (t2.t54 t2.t57))
(step t2.t59 (cl @p_36) :rule resolution :premises (t2.t36 t2.t58))
(step t2.t60 (cl (not (! (= (! (=> (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))) (! (or @p_37 (! (and @p_33 (! (or @p_30 (! (= @p_28 @p_15) :named @p_58)) :named @p_59)) :named @p_60)) :named @p_61)) :named @p_62) (! (=> (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))) @p_38) :named @p_57)) :named @p_63)) (not @p_62) @p_57) :rule equiv_pos2)
(step t2.t61 (cl (= (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))) (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))))) :rule refl)
(step t2.t62 (cl (= @p_37 @p_37)) :rule refl)
(step t2.t63 (cl (= @p_33 @p_33)) :rule refl)
(step t2.t64 (cl (= @p_30 @p_30)) :rule refl)
(step t2.t65 (cl (= @p_58 @p_29)) :rule rare_rewrite :args ("eq-symm" @p_28 @p_15))
(step t2.t66 (cl (= @p_59 @p_31)) :rule cong :premises (t2.t64 t2.t65))
(step t2.t67 (cl (= @p_60 @p_34)) :rule cong :premises (t2.t63 t2.t66))
(step t2.t68 (cl (= @p_61 @p_38)) :rule cong :premises (t2.t62 t2.t67))
(step t2.t69 (cl @p_63) :rule cong :premises (t2.t61 t2.t68))
(step t2.t70 (cl @p_62 (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))))) :rule implies_neg1)
(anchor :step t2.t71)
(assume t2.t71.a0 (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))))
(step t2.t71.t0 (cl (or (! (not (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))))) :named @p_56) @p_61)) :rule forall_inst :args ((:= smt__f smt__VARIABLE___alloc___) (:= smt__x smt__CONSTANT___clt___) (:= smt__y @p_8) (:= smt__z smt__CONSTANT___c1___)))
(step t2.t71.t1 (cl @p_56 @p_61) :rule or :premises (t2.t71.t0))
(step t2.t71.t2 (cl (not (! (= (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) smt__y)) (=> (distinct smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))) (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))))) :named @p_39)) (not (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) smt__y)) (=> (distinct smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))))) (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))))) :rule equiv_pos2)
(anchor :step t2.t71.t3 :args ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv) (:= smt__f smt__f) (:= smt__x smt__x) (:= smt__y smt__y) (:= smt__z smt__z)))
(step t2.t71.t3.t0 (cl (= (! (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) :named @p_48) @p_48)) :rule refl)
(step t2.t71.t3.t1 (cl (= (! (= smt__z smt__x) :named @p_52) (! (= smt__x smt__z) :named @p_42))) :rule rare_rewrite :args ("eq-symm" smt__z smt__x))
(step t2.t71.t3.t2 (cl (= (! (= (! (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) :named @p_40) smt__y) :named @p_51) (! (= smt__y @p_40) :named @p_45))) :rule rare_rewrite :args ("eq-symm" @p_40 smt__y))
(step t2.t71.t3.t3 (cl (= (! (=> @p_52 @p_51) :named @p_53) (! (=> @p_42 @p_45) :named @p_46))) :rule cong :premises (t2.t71.t3.t1 t2.t71.t3.t2))
(step t2.t71.t3.t4 (cl (= (! (distinct smt__z smt__x) :named @p_49) (! (not @p_52) :named @p_55))) :rule rare_rewrite :args ("distinct-binary-elim" smt__z smt__x))
(step t2.t71.t3.t5 (cl (= @p_55 (! (not @p_42) :named @p_43))) :rule cong :premises (t2.t71.t3.t1))
(step t2.t71.t3.t6 (cl (= @p_49 @p_43)) :rule trans :premises (t2.t71.t3.t4 t2.t71.t3.t5))
(step t2.t71.t3.t7 (cl (= (! (= @p_40 (smt__TLA______FunApp smt__f smt__z)) :named @p_41) @p_41)) :rule refl)
(step t2.t71.t3.t8 (cl (= (! (=> @p_49 @p_41) :named @p_50) (! (=> @p_43 @p_41) :named @p_44))) :rule cong :premises (t2.t71.t3.t6 t2.t71.t3.t7))
(step t2.t71.t3.t9 (cl (= (! (and @p_53 @p_50) :named @p_54) (! (and @p_46 @p_44) :named @p_47))) :rule cong :premises (t2.t71.t3.t3 t2.t71.t3.t8))
(step t2.t71.t3.t10 (cl (= (=> @p_48 @p_54) (=> @p_48 @p_47))) :rule cong :premises (t2.t71.t3.t0 t2.t71.t3.t9))
(step t2.t71.t3 (cl (= (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) smt__y)) (=> (distinct smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))) (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__x smt__z) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (=> (not (= smt__x smt__z)) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))))) :rule bind)
(step t2.t71.t4 (cl (= (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__x smt__z) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (=> (not (= smt__x smt__z)) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))) (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))))) :rule all_simplify)
(step t2.t71.t5 (cl @p_39) :rule trans :premises (t2.t71.t3 t2.t71.t4))
(step t2.t71.t6 (cl (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))))) :rule resolution :premises (t2.t71.t2 t2.t71.t5 FunExceptAppDef2))
(step t2.t71.t7 (cl @p_61) :rule resolution :premises (t2.t71.t1 t2.t71.t6))
(step t2.t71 (cl @p_56 @p_61) :rule subproof :discharge (t2.t71.a0))
(step t2.t72 (cl @p_62 @p_61) :rule resolution :premises (t2.t70 t2.t71))
(step t2.t73 (cl @p_62 (not @p_61)) :rule implies_neg2)
(step t2.t74 (cl @p_62 @p_62) :rule resolution :premises (t2.t72 t2.t73))
(step t2.t75 (cl @p_62) :rule contraction :premises (t2.t74))
(step t2.t76 (cl @p_57) :rule resolution :premises (t2.t60 t2.t69 t2.t75))
(step t2.t77 (cl @p_56 @p_38) :rule implies :premises (t2.t76))
(step t2.t78 (cl (not @p_39) (not (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) smt__y)) (=> (distinct smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))))) (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))))) :rule equiv_pos2)
(anchor :step t2.t79 :args ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv) (:= smt__f smt__f) (:= smt__x smt__x) (:= smt__y smt__y) (:= smt__z smt__z)))
(step t2.t79.t0 (cl (= @p_48 @p_48)) :rule refl)
(step t2.t79.t1 (cl (= @p_52 @p_42)) :rule rare_rewrite :args ("eq-symm" smt__z smt__x))
(step t2.t79.t2 (cl (= @p_51 @p_45)) :rule rare_rewrite :args ("eq-symm" @p_40 smt__y))
(step t2.t79.t3 (cl (= @p_53 @p_46)) :rule cong :premises (t2.t79.t1 t2.t79.t2))
(step t2.t79.t4 (cl (= @p_49 @p_55)) :rule rare_rewrite :args ("distinct-binary-elim" smt__z smt__x))
(step t2.t79.t5 (cl (= @p_55 @p_43)) :rule cong :premises (t2.t79.t1))
(step t2.t79.t6 (cl (= @p_49 @p_43)) :rule trans :premises (t2.t79.t4 t2.t79.t5))
(step t2.t79.t7 (cl (= @p_41 @p_41)) :rule refl)
(step t2.t79.t8 (cl (= @p_50 @p_44)) :rule cong :premises (t2.t79.t6 t2.t79.t7))
(step t2.t79.t9 (cl (= @p_54 @p_47)) :rule cong :premises (t2.t79.t3 t2.t79.t8))
(step t2.t79.t10 (cl (= (=> @p_48 @p_54) (=> @p_48 @p_47))) :rule cong :premises (t2.t79.t0 t2.t79.t9))
(step t2.t79 (cl (= (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) smt__y)) (=> (distinct smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))) (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__x smt__z) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (=> (not (= smt__x smt__z)) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))))) :rule bind)
(step t2.t80 (cl (= (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__x smt__z) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (=> (not (= smt__x smt__z)) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))) (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))))) :rule all_simplify)
(step t2.t81 (cl @p_39) :rule trans :premises (t2.t79 t2.t80))
(step t2.t82 (cl (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))))) :rule resolution :premises (t2.t78 t2.t81 FunExceptAppDef2))
(step t2.t83 (cl @p_38) :rule resolution :premises (t2.t77 t2.t82))
(step t2.t84 (cl @p_34) :rule resolution :premises (t2.t34 t2.t59 t2.t83))
(step t2.t85 (cl @p_31) :rule resolution :premises (t2.t32 t2.t84))
(step t2.t86 (cl @p_29) :rule resolution :premises (t2.t9 t2.t30 t2.t85))
(step t2.t87 (cl @p_58) :rule symm :premises (t2.t86))
(step t2.t88 (cl @p_24) :rule trans :premises (t2.t7 t2.t87))
(step t2 (cl @p_92 @p_93 @p_24) :rule subproof :discharge (t2.a0 t2.a1))
(step t3 (cl (! (not @p_94) :named @p_95) @p_19) :rule and_pos)
(step t4 (cl @p_95 @p_29) :rule and_pos)
(step t5 (cl @p_24 @p_95 @p_95) :rule resolution :premises (t2 t3 t4))
(step t6 (cl @p_95 @p_95 @p_24) :rule reordering :premises (t5))
(step t7 (cl @p_95 @p_24) :rule contraction :premises (t6))
(step t8 (cl @p_96 @p_24) :rule resolution :premises (t1 t7))
(step t9 (cl @p_96 (! (not @p_24) :named @p_25)) :rule implies_neg2)
(step t10 (cl @p_96 @p_96) :rule resolution :premises (t8 t9))
(step t11 (cl @p_96) :rule contraction :premises (t10))
(step t12 (cl @p_95 @p_24) :rule implies :premises (t11))
(step t13 (cl @p_92 @p_93 @p_24) :rule resolution :premises (t0 t12))
(step t14 (cl @p_92 @p_24 @p_93) :rule reordering :premises (t13))
(step t15 (cl @p_91 @p_30 @p_29) :rule or_pos)
(step t16 (cl @p_30 @p_29 @p_91) :rule reordering :premises (t15))
(step t17 (cl @p_90 @p_12 @p_32) :rule equiv_pos1)
(step t18 (cl @p_12 @p_32 @p_90) :rule reordering :premises (t17))
(step t19 (cl @p_89 @p_11) :rule implies :premises (a28))
(step t20 (cl @p_11 @p_89) :rule reordering :premises (t19))
(step t21 (cl @p_89) :rule resolution :premises (t20 a29))
(step t22 (cl (not @p_88) (not @p_87) @p_84) :rule equiv_pos2)
(step t23 (cl (= (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))))) :rule refl)
(step t24 (cl (= @p_12 @p_12)) :rule refl)
(step t25 (cl (= @p_85 @p_30)) :rule rare_rewrite :args ("eq-symm" smt__CONSTANT___c1___ smt__CONSTANT___clt___))
(step t26 (cl (= @p_86 @p_83)) :rule cong :premises (t24 t25))
(step t27 (cl @p_88) :rule cong :premises (t23 t26))
(step t28 (cl @p_87 (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) :rule implies_neg1)
(anchor :step t29)
(assume t29.a0 (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))))
(step t29.t0 (cl (or @p_21 @p_86)) :rule forall_inst :args ((:= smt__x smt__CONSTANT___c1___) (:= smt__y smt__CONSTANT___clt___)))
(step t29.t1 (cl @p_21 @p_86) :rule or :premises (t29.t0))
(step t29.t2 (cl @p_86) :rule resolution :premises (t29.t1 t29.a0))
(step t29 (cl @p_21 @p_86) :rule subproof :discharge (t29.a0))
(step t30 (cl @p_87 @p_86) :rule resolution :premises (t28 t29))
(step t31 (cl @p_87 (not @p_86)) :rule implies_neg2)
(step t32 (cl @p_87 @p_87) :rule resolution :premises (t30 t31))
(step t33 (cl @p_87) :rule contraction :premises (t32))
(step t34 (cl @p_84) :rule resolution :premises (t22 t27 t33))
(step t35 (cl @p_21 @p_83) :rule implies :premises (t34))
(step t36 (cl @p_83) :rule resolution :premises (t35 |ExtTrigEqDef Idv|))
(step t37 (cl @p_32) :rule resolution :premises (t18 t21 t36))
(step t38 (cl @p_82 @p_31) :rule and_pos)
(step t39 (cl @p_31 @p_82) :rule reordering :premises (t38))
(step t40 (cl @p_81 @p_37 @p_34) :rule or_pos)
(step t41 (cl @p_37 @p_34 @p_81) :rule reordering :premises (t40))
(step t42 (cl (= @p_64 @p_36)) :rule equiv_simplify)
(step t43 (cl (not @p_64) @p_36) :rule equiv1 :premises (t42))
(step t44 (cl (= smt__CONSTANT___c1___ smt__CONSTANT___c1___)) :rule refl)
(step t45 (cl @p_80 @p_66) :rule and_pos)
(step t46 (cl @p_66 @p_80) :rule reordering :premises (t45))
(step t47 (cl @p_79 @p_68 @p_67) :rule or_pos)
(step t48 (cl @p_68 @p_67 @p_79) :rule reordering :premises (t47))
(step t49 (cl @p_6) :rule and :premises (a25))
(step t50 (cl @p_5) :rule and :premises (t49))
(step t51 (cl (or @p_78 @p_69)) :rule forall_inst :args ((:= smt__a smt__CONSTANT___Client___) (:= smt__b @p_1) (:= smt__f smt__VARIABLE___alloc___)))
(step t52 (cl @p_78 @p_69) :rule or :premises (t51))
(step t53 (cl (not @p_70) (not (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (=> (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (and (smt__TLA______FunIsafcn smt__f) (= (smt__TLA______FunDom smt__f) smt__a))))) (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (or (not (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))) (and (smt__TLA______FunIsafcn smt__f) (= smt__a (smt__TLA______FunDom smt__f)))))) :rule equiv_pos2)
(anchor :step t54 :args ((smt__a Idv) (smt__b Idv) (smt__f Idv) (:= smt__a smt__a) (:= smt__b smt__b) (:= smt__f smt__f)))
(step t54.t0 (cl (= @p_75 @p_75)) :rule refl)
(step t54.t1 (cl (= @p_73 @p_73)) :rule refl)
(step t54.t2 (cl (= @p_76 @p_72)) :rule rare_rewrite :args ("eq-symm" @p_71 smt__a))
(step t54.t3 (cl (= @p_77 @p_74)) :rule cong :premises (t54.t1 t54.t2))
(step t54.t4 (cl (= (=> @p_75 @p_77) (=> @p_75 @p_74))) :rule cong :premises (t54.t0 t54.t3))
(step t54 (cl (= (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (=> (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (and (smt__TLA______FunIsafcn smt__f) (= (smt__TLA______FunDom smt__f) smt__a)))) (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (=> (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (and (smt__TLA______FunIsafcn smt__f) (= smt__a (smt__TLA______FunDom smt__f))))))) :rule bind)
(step t55 (cl (= (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (=> (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (and (smt__TLA______FunIsafcn smt__f) (= smt__a (smt__TLA______FunDom smt__f))))) (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (or (not (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))) (and (smt__TLA______FunIsafcn smt__f) (= smt__a (smt__TLA______FunDom smt__f))))))) :rule all_simplify)
(step t56 (cl @p_70) :rule trans :premises (t54 t55))
(step t57 (cl (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (or (not (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))) (and (smt__TLA______FunIsafcn smt__f) (= smt__a (smt__TLA______FunDom smt__f)))))) :rule resolution :premises (t53 t56 FunSetElim1))
(step t58 (cl @p_69) :rule resolution :premises (t52 t57))
(step t59 (cl @p_67) :rule resolution :premises (t48 t50 t58))
(step t60 (cl @p_66) :rule resolution :premises (t46 t59))
(step t61 (cl (= @p_35 smt__CONSTANT___Client___)) :rule symm :premises (t60))
(step t62 (cl (= @p_36 @p_2)) :rule cong :premises (t44 t61))
(step t63 (cl (= @p_65 @p_2)) :rule equiv_simplify)
(step t64 (cl @p_65 (not @p_2)) :rule equiv2 :premises (t63))
(step t65 (cl @p_65) :rule resolution :premises (t64 a22))
(step t66 (cl @p_64) :rule trans :premises (t62 t65))
(step t67 (cl @p_36) :rule resolution :premises (t43 t66))
(step t68 (cl (not @p_63) (not @p_62) @p_57) :rule equiv_pos2)
(step t69 (cl (= (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))) (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))))) :rule refl)
(step t70 (cl (= @p_37 @p_37)) :rule refl)
(step t71 (cl (= @p_33 @p_33)) :rule refl)
(step t72 (cl (= @p_30 @p_30)) :rule refl)
(step t73 (cl (= @p_58 @p_29)) :rule rare_rewrite :args ("eq-symm" @p_28 @p_15))
(step t74 (cl (= @p_59 @p_31)) :rule cong :premises (t72 t73))
(step t75 (cl (= @p_60 @p_34)) :rule cong :premises (t71 t74))
(step t76 (cl (= @p_61 @p_38)) :rule cong :premises (t70 t75))
(step t77 (cl @p_63) :rule cong :premises (t69 t76))
(step t78 (cl @p_62 (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))))) :rule implies_neg1)
(anchor :step t79)
(assume t79.a0 (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))))
(step t79.t0 (cl (or @p_56 @p_61)) :rule forall_inst :args ((:= smt__f smt__VARIABLE___alloc___) (:= smt__x smt__CONSTANT___clt___) (:= smt__y @p_8) (:= smt__z smt__CONSTANT___c1___)))
(step t79.t1 (cl @p_56 @p_61) :rule or :premises (t79.t0))
(step t79.t2 (cl (not @p_39) (not (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) smt__y)) (=> (distinct smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))))) (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))))) :rule equiv_pos2)
(anchor :step t79.t3 :args ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv) (:= smt__f smt__f) (:= smt__x smt__x) (:= smt__y smt__y) (:= smt__z smt__z)))
(step t79.t3.t0 (cl (= @p_48 @p_48)) :rule refl)
(step t79.t3.t1 (cl (= @p_52 @p_42)) :rule rare_rewrite :args ("eq-symm" smt__z smt__x))
(step t79.t3.t2 (cl (= @p_51 @p_45)) :rule rare_rewrite :args ("eq-symm" @p_40 smt__y))
(step t79.t3.t3 (cl (= @p_53 @p_46)) :rule cong :premises (t79.t3.t1 t79.t3.t2))
(step t79.t3.t4 (cl (= @p_49 @p_55)) :rule rare_rewrite :args ("distinct-binary-elim" smt__z smt__x))
(step t79.t3.t5 (cl (= @p_55 @p_43)) :rule cong :premises (t79.t3.t1))
(step t79.t3.t6 (cl (= @p_49 @p_43)) :rule trans :premises (t79.t3.t4 t79.t3.t5))
(step t79.t3.t7 (cl (= @p_41 @p_41)) :rule refl)
(step t79.t3.t8 (cl (= @p_50 @p_44)) :rule cong :premises (t79.t3.t6 t79.t3.t7))
(step t79.t3.t9 (cl (= @p_54 @p_47)) :rule cong :premises (t79.t3.t3 t79.t3.t8))
(step t79.t3.t10 (cl (= (=> @p_48 @p_54) (=> @p_48 @p_47))) :rule cong :premises (t79.t3.t0 t79.t3.t9))
(step t79.t3 (cl (= (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) smt__y)) (=> (distinct smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))) (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__x smt__z) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (=> (not (= smt__x smt__z)) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))))) :rule bind)
(step t79.t4 (cl (= (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__x smt__z) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (=> (not (= smt__x smt__z)) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))) (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))))) :rule all_simplify)
(step t79.t5 (cl @p_39) :rule trans :premises (t79.t3 t79.t4))
(step t79.t6 (cl (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))))) :rule resolution :premises (t79.t2 t79.t5 FunExceptAppDef2))
(step t79.t7 (cl @p_61) :rule resolution :premises (t79.t1 t79.t6))
(step t79 (cl @p_56 @p_61) :rule subproof :discharge (t79.a0))
(step t80 (cl @p_62 @p_61) :rule resolution :premises (t78 t79))
(step t81 (cl @p_62 (not @p_61)) :rule implies_neg2)
(step t82 (cl @p_62 @p_62) :rule resolution :premises (t80 t81))
(step t83 (cl @p_62) :rule contraction :premises (t82))
(step t84 (cl @p_57) :rule resolution :premises (t68 t77 t83))
(step t85 (cl @p_56 @p_38) :rule implies :premises (t84))
(step t86 (cl (not @p_39) (not (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) smt__y)) (=> (distinct smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))))) (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))))) :rule equiv_pos2)
(anchor :step t87 :args ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv) (:= smt__f smt__f) (:= smt__x smt__x) (:= smt__y smt__y) (:= smt__z smt__z)))
(step t87.t0 (cl (= @p_48 @p_48)) :rule refl)
(step t87.t1 (cl (= @p_52 @p_42)) :rule rare_rewrite :args ("eq-symm" smt__z smt__x))
(step t87.t2 (cl (= @p_51 @p_45)) :rule rare_rewrite :args ("eq-symm" @p_40 smt__y))
(step t87.t3 (cl (= @p_53 @p_46)) :rule cong :premises (t87.t1 t87.t2))
(step t87.t4 (cl (= @p_49 @p_55)) :rule rare_rewrite :args ("distinct-binary-elim" smt__z smt__x))
(step t87.t5 (cl (= @p_55 @p_43)) :rule cong :premises (t87.t1))
(step t87.t6 (cl (= @p_49 @p_43)) :rule trans :premises (t87.t4 t87.t5))
(step t87.t7 (cl (= @p_41 @p_41)) :rule refl)
(step t87.t8 (cl (= @p_50 @p_44)) :rule cong :premises (t87.t6 t87.t7))
(step t87.t9 (cl (= @p_54 @p_47)) :rule cong :premises (t87.t3 t87.t8))
(step t87.t10 (cl (= (=> @p_48 @p_54) (=> @p_48 @p_47))) :rule cong :premises (t87.t0 t87.t9))
(step t87 (cl (= (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) smt__y)) (=> (distinct smt__z smt__x) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))) (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__x smt__z) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (=> (not (= smt__x smt__z)) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))))) :rule bind)
(step t88 (cl (= (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (=> (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f)) (and (=> (= smt__x smt__z) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (=> (not (= smt__x smt__z)) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))) (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z)))))))) :rule all_simplify)
(step t89 (cl @p_39) :rule trans :premises (t87 t88))
(step t90 (cl (forall ((smt__f Idv) (smt__x Idv) (smt__y Idv) (smt__z Idv)) (or (not (smt__TLA______Mem smt__z (smt__TLA______FunDom smt__f))) (and (or (not (= smt__x smt__z)) (= smt__y (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z))) (or (= smt__x smt__z) (= (smt__TLA______FunApp (smt__TLA______FunExcept smt__f smt__x smt__y) smt__z) (smt__TLA______FunApp smt__f smt__z))))))) :rule resolution :premises (t86 t89 FunExceptAppDef2))
(step t91 (cl @p_38) :rule resolution :premises (t85 t90))
(step t92 (cl @p_34) :rule resolution :premises (t41 t67 t91))
(step t93 (cl @p_31) :rule resolution :premises (t39 t92))
(step t94 (cl @p_29) :rule resolution :premises (t16 t37 t93))
(step t95 (cl (! (not (! (= @p_17 @p_24) :named @p_26)) :named @p_27) @p_17 @p_25) :rule equiv_pos1)
(step t96 (cl @p_17 @p_25 @p_27) :rule reordering :premises (t95))
(step t97 (cl (or @p_21 @p_26)) :rule forall_inst :args ((:= smt__x @p_16) (:= smt__y @p_15)))
(step t98 (cl @p_21 @p_26) :rule or :premises (t97))
(step t99 (cl @p_26) :rule resolution :premises (t98 |ExtTrigEqDef Idv|))
(step t100 (cl @p_25) :rule resolution :premises (t96 Goal t99))
(step t101 (cl @p_23 @p_22 @p_19) :rule equiv_pos2)
(step t102 (cl @p_22 @p_19 @p_23) :rule reordering :premises (t101))
(step t103 (cl (or @p_21 @p_20)) :rule forall_inst :args ((:= smt__x smt__VARIABLE___alloc______prime) (:= smt__y @p_9)))
(step t104 (cl @p_21 @p_20) :rule or :premises (t103))
(step t105 (cl @p_20) :rule resolution :premises (t104 |ExtTrigEqDef Idv|))
(step t106 (cl @p_19) :rule resolution :premises (t102 a26 t105))
(step t107 (cl) :rule resolution :premises (t14 t94 t100 t106))

