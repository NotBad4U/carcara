(assume a0 (forall ((smt__x Idv) (smt__y Idv)) (! (=> (forall ((smt__z Idv)) (= (smt__TLA______Mem smt__z smt__x) (smt__TLA______Mem smt__z smt__y))) (= smt__x smt__y)) :pattern ((smt__TLA______SetExtTrigger smt__x smt__y)))))
(assume a1 (forall ((smt__x Idv) (smt__y Idv)) (! (=> (forall ((smt__z Idv)) (=> (smt__TLA______Mem smt__z smt__x) (smt__TLA______Mem smt__z smt__y))) (smt__TLA______SubsetEq smt__x smt__y)) :pattern ((smt__TLA______SubsetEq smt__x smt__y)))))
(assume a2 (forall ((smt__x Idv) (smt__y Idv) (smt__z Idv)) (! (=> (and (smt__TLA______SubsetEq smt__x smt__y) (smt__TLA______Mem smt__z smt__x)) (smt__TLA______Mem smt__z smt__y)) :pattern ((smt__TLA______SubsetEq smt__x smt__y) (smt__TLA______Mem smt__z smt__x)))))
(assume a3 (forall ((smt__a Idv) (smt__x Idv)) (! (= (smt__TLA______Mem smt__x (smt__TLA______Subset smt__a)) (smt__TLA______SubsetEq smt__x smt__a)) :pattern ((smt__TLA______Mem smt__x (smt__TLA______Subset smt__a))) :pattern ((smt__TLA______SubsetEq smt__x smt__a) (smt__TLA______Subset smt__a)))))
(assume a4 (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))))
(assume a5 (forall ((smt__f Idv) (smt__g Idv)) (! (=> (and (smt__TLA______FunIsafcn smt__f) (smt__TLA______FunIsafcn smt__g) (= (smt__TLA______FunDom smt__f) (smt__TLA______FunDom smt__g)) (forall ((smt__x Idv)) (=> (smt__TLA______Mem smt__x (smt__TLA______FunDom smt__f)) (= (smt__TLA______FunApp smt__f smt__x) (smt__TLA______FunApp smt__g smt__x))))) (= smt__f smt__g)) :pattern ((smt__TLA______FunIsafcn smt__f) (smt__TLA______FunIsafcn smt__g)))))
(assume a6 (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (! (=> (and (smt__TLA______FunIsafcn smt__f) (= (smt__TLA______FunDom smt__f) smt__a) (forall ((smt__x Idv)) (=> (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem (smt__TLA______FunApp smt__f smt__x) smt__b)))) (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))) :pattern ((smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))))))
(assume a7 (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv)) (! (=> (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (and (smt__TLA______FunIsafcn smt__f) (= (smt__TLA______FunDom smt__f) smt__a))) :pattern ((smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b))))))
(assume a8 (forall ((smt__a Idv) (smt__b Idv) (smt__f Idv) (smt__x Idv)) (! (=> (and (smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (smt__TLA______Mem smt__x smt__a)) (smt__TLA______Mem (smt__TLA______FunApp smt__f smt__x) smt__b)) :pattern ((smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (smt__TLA______Mem smt__x smt__a)) :pattern ((smt__TLA______Mem smt__f (smt__TLA______FunSet smt__a smt__b)) (smt__TLA______FunApp smt__f smt__x)))))
(assume a9 (forall ((smt__x Idv) (smt__y Idv)) (! (smt__TLA______SetExtTrigger (smt__TLA______Cap smt__x smt__y) smt__TLA______SetEnum___0) :pattern ((smt__TLA______Cap smt__x smt__y)))))
(assume a10 (forall ((smt__x Idv)) (! (not (smt__TLA______Mem smt__x smt__TLA______SetEnum___0)) :pattern ((smt__TLA______Mem smt__x smt__TLA______SetEnum___0)))))
(assume a11 (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))))
(assume a12 (smt__TLA______Mem smt__CONSTANT___clt___ smt__CONSTANT___Client___))
(assume a13 (smt__TLA______Mem smt__CONSTANT___S___ (smt__TLA______Subset smt__CONSTANT___Resource___)))
(assume a14 (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___))
(assume a15 (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___))
(assume a16 (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___))
(assume a17 (and (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (forall ((smt__CONSTANT___r____1 Idv)) (=> (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___) (=> (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1)))))) (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) smt__TLA______Tt___Idv)))
(assume a18 (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))
(assume a19 (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___)))
(assume a20 (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))
(assume a21 (not (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))))
(step t1 (cl (=> (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (or (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))))))) :rule implies_neg1)
(anchor :step t2)
(assume t2.a0 (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))))
(step t2.t1 (cl (or (not (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))))))) (or (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))))) :rule forall_inst :args ((:= smt__CONSTANT___c1____1 smt__CONSTANT___c2___) (:= smt__CONSTANT___c2____1 smt__CONSTANT___c1___) (:= BOUND_VARIABLE_898 smt__CONSTANT___r___)))
(step t2.t2 (cl (not (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))))))) (or (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))))) :rule or :premises (t2.t1))
(step t2.t3 (cl (or (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))))) :rule resolution :premises (t2.t2 t2.a0))
(step t2 (cl (not (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))))))) (or (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))))) :rule subproof :discharge (t2.a0))
(step t3 (cl (=> (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (or (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))))) (or (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))))) :rule resolution :premises (t1 t2))
(step t4 (cl (=> (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (or (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))))) (not (or (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))))) :rule implies_neg2)
(step t5 (cl (=> (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (or (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))))) (=> (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (or (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))))) :rule resolution :premises (t3 t4))
(step t6 (cl (=> (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (or (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))))) :rule contraction :premises (t5))
(step t7 (cl (not (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))))))) (or (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))))) :rule implies :premises (t6))
(step t8 (cl (not (or (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))))) (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))) :rule or_pos)
(step t9 (cl (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))) (not (or (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))))) :rule reordering :premises (t8))
(step t10 (cl (not (= (= smt__CONSTANT___c1___ smt__CONSTANT___c2___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___))) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___) (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___))) :rule equiv_pos1)
(step t11 (cl (= smt__CONSTANT___c1___ smt__CONSTANT___c2___) (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___)) (not (= (= smt__CONSTANT___c1___ smt__CONSTANT___c2___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___)))) :rule reordering :premises (t10))
(step t12 (cl (not (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (not (= smt__CONSTANT___c1___ smt__CONSTANT___c2___))) :rule equiv_pos1)
(step t13 (cl (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (not (= smt__CONSTANT___c1___ smt__CONSTANT___c2___)) (not (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___)))) :rule reordering :premises (t12))
(step t14 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___))) (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) :rule implies_neg1)
(anchor :step t15)
(assume t15.a0 (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))))
(step t15.t1 (cl (or (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___)))) :rule forall_inst :args ((:= smt__x smt__CONSTANT___c1___) (:= smt__y smt__CONSTANT___c2___)))
(step t15.t2 (cl (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___))) :rule or :premises (t15.t1))
(step t15.t3 (cl (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___))) :rule resolution :premises (t15.t2 t15.a0))
(step t15 (cl (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___))) :rule subproof :discharge (t15.a0))
(step t16 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___))) :rule resolution :premises (t14 t15))
(step t17 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___))) (not (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___)))) :rule implies_neg2)
(step t18 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___))) (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___)))) :rule resolution :premises (t16 t17))
(step t19 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___)))) :rule contraction :premises (t18))
(step t20 (cl (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___))) :rule implies :premises (t19))
(step t21 (cl (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c1___ smt__CONSTANT___c2___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___))) :rule resolution :premises (t20 a11))
(step t22 (cl (not (= smt__CONSTANT___c1___ smt__CONSTANT___c2___))) :rule resolution :premises (t13 a19 t21))
(step t23 (cl (not (= (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___))) (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (= smt__CONSTANT___c1___ smt__CONSTANT___c2___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___))))) (not (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___)))) (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (= smt__CONSTANT___c1___ smt__CONSTANT___c2___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___)))) :rule equiv_pos2)
(step t24 (cl (= (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))))) :rule refl)
(step t25 (cl (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___))) :rule refl)
(step t26 (cl (= (= smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___))) :rule all_simplify)
(step t27 (cl (= (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___)) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___)))) :rule cong :premises (t25 t26))
(step t28 (cl (= (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c1___ smt__CONSTANT___c2___)) (= (= smt__CONSTANT___c1___ smt__CONSTANT___c2___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___)))) :rule all_simplify)
(step t29 (cl (= (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___)) (= (= smt__CONSTANT___c1___ smt__CONSTANT___c2___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___)))) :rule trans :premises (t27 t28))
(step t30 (cl (= (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___))) (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (= smt__CONSTANT___c1___ smt__CONSTANT___c2___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___))))) :rule cong :premises (t24 t29))
(step t31 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___))) (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) :rule implies_neg1)
(anchor :step t32)
(assume t32.a0 (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))))
(step t32.t1 (cl (or (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___)))) :rule forall_inst :args ((:= smt__x smt__CONSTANT___c2___) (:= smt__y smt__CONSTANT___c1___)))
(step t32.t2 (cl (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___))) :rule or :premises (t32.t1))
(step t32.t3 (cl (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___))) :rule resolution :premises (t32.t2 t32.a0))
(step t32 (cl (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___))) :rule subproof :discharge (t32.a0))
(step t33 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___))) :rule resolution :premises (t31 t32))
(step t34 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___))) (not (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___)))) :rule implies_neg2)
(step t35 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___))) (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___)))) :rule resolution :premises (t33 t34))
(step t36 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (= smt__CONSTANT___c2___ smt__CONSTANT___c1___)))) :rule contraction :premises (t35))
(step t37 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (= smt__CONSTANT___c1___ smt__CONSTANT___c2___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___)))) :rule resolution :premises (t23 t30 t36))
(step t38 (cl (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (= smt__CONSTANT___c1___ smt__CONSTANT___c2___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___))) :rule implies :premises (t37))
(step t39 (cl (= (= smt__CONSTANT___c1___ smt__CONSTANT___c2___) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___))) :rule resolution :premises (t38 a11))
(step t40 (cl (not (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___))) :rule resolution :premises (t11 t22 t39))
(step t41 (cl (not (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (not (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))) :rule equiv_pos1)
(step t42 (cl (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (not (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))) (not (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))))) :rule reordering :premises (t41))
(step t43 (cl (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))) :rule and_neg)
(step t44 (cl (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))) :rule reordering :premises (t43))
(step t45 (cl (not (= (not (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))) (not (not (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) :rule equiv_pos2)
(step t46 (cl (= (not (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))) :rule all_simplify)
(step t47 (cl (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) :rule resolution :premises (t45 t46 a21))
(step t48 (cl (and (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (not (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) :rule and_neg)
(step t49 (cl (=> (and (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (and (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) :rule implies_neg1)
(anchor :step t50)
(assume t50.a0 (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))
(assume t50.a1 (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))
(step t50.t1 (cl (=> (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) :rule implies_neg1)
(anchor :step t50.t2)
(assume t50.t2.a0 (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))
(assume t50.t2.a1 (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))
(step t50.t2.t1 (cl (= (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) true) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) :rule equiv_simplify)
(step t50.t2.t2 (cl (not (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) true)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule equiv1 :premises (t50.t2.t1))
(step t50.t2.t3 (cl (= smt__CONSTANT___r___ smt__CONSTANT___r___)) :rule refl)
(step t50.t2.t4 (cl (= (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) :rule symm :premises (t50.t2.a1))
(step t50.t2.t5 (cl (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) :rule cong :premises (t50.t2.t3 t50.t2.t4))
(step t50.t2.t6 (cl (= (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) true) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) :rule equiv_simplify)
(step t50.t2.t7 (cl (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) true) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) :rule equiv2 :premises (t50.t2.t6))
(step t50.t2.t8 (cl (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) true)) :rule resolution :premises (t50.t2.t7 t50.t2.a0))
(step t50.t2.t9 (cl (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) true)) :rule trans :premises (t50.t2.t5 t50.t2.t8))
(step t50.t2.t10 (cl (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule resolution :premises (t50.t2.t2 t50.t2.t9))
(step t50.t2 (cl (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (not (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule subproof :discharge (t50.t2.a0 t50.t2.a1))
(step t50.t3 (cl (not (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) :rule and_pos)
(step t50.t4 (cl (not (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule and_pos)
(step t50.t5 (cl (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (not (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) (not (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))))) :rule resolution :premises (t50.t2 t50.t3 t50.t4))
(step t50.t6 (cl (not (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) (not (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule reordering :premises (t50.t5))
(step t50.t7 (cl (not (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule contraction :premises (t50.t6))
(step t50.t8 (cl (=> (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule resolution :premises (t50.t1 t50.t7))
(step t50.t9 (cl (=> (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) :rule implies_neg2)
(step t50.t10 (cl (=> (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (=> (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) :rule resolution :premises (t50.t8 t50.t9))
(step t50.t11 (cl (=> (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) :rule contraction :premises (t50.t10))
(step t50.t12 (cl (not (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule implies :premises (t50.t11))
(step t50.t13 (cl (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (not (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) :rule and_neg)
(step t50.t14 (cl (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) :rule resolution :premises (t50.t13 t50.a1 t50.a0))
(step t50.t15 (cl (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule resolution :premises (t50.t12 t50.t14))
(step t50 (cl (not (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule subproof :discharge (t50.a0 t50.a1))
(step t51 (cl (not (and (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule and_pos)
(step t52 (cl (not (and (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) :rule and_pos)
(step t53 (cl (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (not (and (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) (not (and (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) :rule resolution :premises (t50 t51 t52))
(step t54 (cl (not (and (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) (not (and (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule reordering :premises (t53))
(step t55 (cl (not (and (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule contraction :premises (t54))
(step t56 (cl (=> (and (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule resolution :premises (t49 t55))
(step t57 (cl (=> (and (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) :rule implies_neg2)
(step t58 (cl (=> (and (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (=> (and (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) :rule resolution :premises (t56 t57))
(step t59 (cl (=> (and (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) :rule contraction :premises (t58))
(step t60 (cl (not (and (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule implies :premises (t59))
(step t61 (cl (not (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule resolution :premises (t48 t60))
(step t62 (cl (not (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) (not (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule equiv_pos2)
(step t63 (cl (not (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (not (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))))) :rule reordering :premises (t62))
(step t64 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) :rule implies_neg1)
(anchor :step t65)
(assume t65.a0 (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))))
(step t65.t1 (cl (or (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))))) :rule forall_inst :args ((:= smt__x (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (:= smt__y (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))))
(step t65.t2 (cl (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) :rule or :premises (t65.t1))
(step t65.t3 (cl (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) :rule resolution :premises (t65.t2 t65.a0))
(step t65 (cl (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) :rule subproof :discharge (t65.a0))
(step t66 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) :rule resolution :premises (t64 t65))
(step t67 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) (not (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))))) :rule implies_neg2)
(step t68 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))))) :rule resolution :premises (t66 t67))
(step t69 (cl (=> (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y))) (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))))) :rule contraction :premises (t68))
(step t70 (cl (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA______TrigEq___Idv smt__x smt__y) (= smt__x smt__y)))) (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) :rule implies :premises (t69))
(step t71 (cl (= (smt__TLA______TrigEq___Idv (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)))) :rule resolution :premises (t70 a11))
(step t72 (cl (= (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule resolution :premises (t63 a20 t71))
(step t73 (cl (not (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) :rule and_pos)
(step t74 (cl (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (not (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) :rule reordering :premises (t73))
(step t75 (cl (not (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) :rule equiv_pos2)
(step t76 (cl (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (not (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))))) :rule reordering :premises (t75))
(step t77 (cl (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) :rule implies_neg1)
(anchor :step t78)
(assume t78.a0 (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))))
(step t78.t1 (cl (or (not (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))))) :rule forall_inst :args ((:= smt__a (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (:= smt__b (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)) (:= smt__x smt__CONSTANT___r___)))
(step t78.t2 (cl (not (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) :rule or :premises (t78.t1))
(step t78.t3 (cl (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) :rule resolution :premises (t78.t2 t78.a0))
(step t78 (cl (not (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) :rule subproof :discharge (t78.a0))
(step t79 (cl (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) :rule resolution :premises (t77 t78))
(step t80 (cl (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) (not (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))))) :rule implies_neg2)
(step t81 (cl (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))))) :rule resolution :premises (t79 t80))
(step t82 (cl (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))))) :rule contraction :premises (t81))
(step t83 (cl (not (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) :rule implies :premises (t82))
(step t84 (cl (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___) (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))))) :rule resolution :premises (t83 a4))
(step t85 (cl (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c1___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___)))) :rule resolution :premises (t76 a18 t84))
(step t86 (cl (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc______prime smt__CONSTANT___c2___))) :rule resolution :premises (t74 t85))
(step t87 (cl (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___))) :rule resolution :premises (t61 t72 t86))
(step t88 (cl (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))) :rule resolution :premises (t44 t47 t87))
(step t89 (cl (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))) (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) :rule implies_neg1)
(anchor :step t90)
(assume t90.a0 (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))))
(step t90.t1 (cl (or (not (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))))) :rule forall_inst :args ((:= smt__a (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (:= smt__b (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)) (:= smt__x smt__CONSTANT___r___)))
(step t90.t2 (cl (not (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))) :rule or :premises (t90.t1))
(step t90.t3 (cl (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))) :rule resolution :premises (t90.t2 t90.a0))
(step t90 (cl (not (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))) :rule subproof :discharge (t90.a0))
(step t91 (cl (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))) :rule resolution :premises (t89 t90))
(step t92 (cl (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))) (not (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))))) :rule implies_neg2)
(step t93 (cl (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))) (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))))) :rule resolution :premises (t91 t92))
(step t94 (cl (=> (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b)))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))))) :rule contraction :premises (t93))
(step t95 (cl (not (forall ((smt__a Idv) (smt__b Idv) (smt__x Idv)) (= (smt__TLA______Mem smt__x (smt__TLA______Cap smt__a smt__b)) (and (smt__TLA______Mem smt__x smt__a) (smt__TLA______Mem smt__x smt__b))))) (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))) :rule implies :premises (t94))
(step t96 (cl (= (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))) (and (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___)) (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))) :rule resolution :premises (t95 a4))
(step t97 (cl (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___)))) :rule resolution :premises (t42 t88 t96))
(step t98 (cl (not (or (not (smt__TLA______Mem smt__CONSTANT___c2___ smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c1___ smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c2___ smt__CONSTANT___c1___) (not (smt__TLA______Mem smt__CONSTANT___r___ smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r___ (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2___) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1___))))))) :rule resolution :premises (t9 a14 a15 a16 t40 t97))
(step t99 (cl (not (= (and (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (forall ((smt__CONSTANT___r____1 Idv)) (=> (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___) (=> (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1)))))) (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) smt__TLA______Tt___Idv)) (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))) (not (and (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (forall ((smt__CONSTANT___r____1 Idv)) (=> (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___) (=> (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1)))))) (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) smt__TLA______Tt___Idv))) (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule equiv_pos2)
(step t100 (cl (= (and (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (forall ((smt__CONSTANT___r____1 Idv)) (=> (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___) (=> (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1)))))) (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) smt__TLA______Tt___Idv)) (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (forall ((smt__CONSTANT___r____1 Idv)) (=> (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___) (=> (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1)))))) (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) smt__TLA______Tt___Idv) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))) :rule all_simplify)
(anchor :step t101 :args ((smt__CONSTANT___c1____1 Idv) (:= smt__CONSTANT___c1____1 smt__CONSTANT___c1____1) (smt__CONSTANT___c2____1 Idv) (:= smt__CONSTANT___c2____1 smt__CONSTANT___c2____1)))
(step t101.t1 (cl (= smt__CONSTANT___c1____1 smt__CONSTANT___c1____1)) :rule refl)
(step t101.t2 (cl (= smt__CONSTANT___c2____1 smt__CONSTANT___c2____1)) :rule refl)
(step t101.t3 (cl (= (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)))) :rule refl)
(step t101.t4 (cl (= (forall ((smt__CONSTANT___r____1 Idv)) (=> (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___) (=> (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1)))) (forall ((smt__CONSTANT___r____1 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1))))) :rule all_simplify)
(step t101.t5 (cl (= (forall ((smt__CONSTANT___r____1 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1))) (or (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (forall ((smt__CONSTANT___r____1 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))))))))) :rule all_simplify)
(step t101.t6 (cl (= (forall ((smt__CONSTANT___r____1 Idv)) (=> (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___) (=> (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1)))) (or (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (forall ((smt__CONSTANT___r____1 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))))))))) :rule trans :premises (t101.t4 t101.t5))
(step t101.t7 (cl (= (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (forall ((smt__CONSTANT___r____1 Idv)) (=> (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___) (=> (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1))))) (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (or (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (forall ((smt__CONSTANT___r____1 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))))))) :rule cong :premises (t101.t3 t101.t6))
(step t101 (cl (= (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (forall ((smt__CONSTANT___r____1 Idv)) (=> (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___) (=> (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1)))))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (or (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (forall ((smt__CONSTANT___r____1 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))))))))))) :rule bind)
(step t102 (cl (= (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (or (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (forall ((smt__CONSTANT___r____1 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))))))))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (forall ((smt__CONSTANT___r____1 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))))))) :rule all_simplify)
(step t103 (cl (= (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (forall ((smt__CONSTANT___r____1 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (or (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))))))))) :rule all_simplify)
(anchor :step t104 :args ((smt__CONSTANT___c1____1 Idv) (:= smt__CONSTANT___c1____1 smt__CONSTANT___c1____1) (smt__CONSTANT___c2____1 Idv) (:= smt__CONSTANT___c2____1 smt__CONSTANT___c2____1) (BOUND_VARIABLE_898 Idv) (:= BOUND_VARIABLE_898 BOUND_VARIABLE_898)))
(step t104.t1 (cl (= smt__CONSTANT___c1____1 smt__CONSTANT___c1____1)) :rule refl)
(step t104.t2 (cl (= smt__CONSTANT___c2____1 smt__CONSTANT___c2____1)) :rule refl)
(step t104.t3 (cl (= BOUND_VARIABLE_898 BOUND_VARIABLE_898)) :rule refl)
(step t104.t4 (cl (= (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (or (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))))))) :rule all_simplify)
(step t104 (cl (= (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (or (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))))))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))))) :rule bind)
(step t105 (cl (= (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (forall ((smt__CONSTANT___r____1 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))))) :rule trans :premises (t103 t104))
(step t106 (cl (= (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (or (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (forall ((smt__CONSTANT___r____1 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))))))))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))))) :rule trans :premises (t102 t105))
(step t107 (cl (= (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (forall ((smt__CONSTANT___r____1 Idv)) (=> (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___) (=> (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1)))))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))))) :rule trans :premises (t101 t106))
(step t108 (cl (= (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) smt__TLA______Tt___Idv) (= smt__TLA______Tt___Idv (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___)))) :rule all_simplify)
(step t109 (cl (= (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule refl)
(step t110 (cl (= (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule refl)
(step t111 (cl (= (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (forall ((smt__CONSTANT___r____1 Idv)) (=> (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___) (=> (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1)))))) (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) smt__TLA______Tt___Idv) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (= smt__TLA______Tt___Idv (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))) :rule cong :premises (t107 t108 t109 t110))
(step t112 (cl (= (and (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (forall ((smt__CONSTANT___r____1 Idv)) (=> (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___) (=> (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1)))))) (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) smt__TLA______Tt___Idv)) (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (= smt__TLA______Tt___Idv (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))) :rule trans :premises (t100 t111))
(step t113 (cl (= (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))))) :rule refl)
(step t114 (cl (not (= (and (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (forall ((smt__CONSTANT___r____1 Idv)) (=> (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___) (=> (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1)))))) (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) smt__TLA______Tt___Idv)) (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (= smt__TLA______Tt___Idv (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))) (not (and (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (forall ((smt__CONSTANT___r____1 Idv)) (=> (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___) (=> (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1)))))) (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) smt__TLA______Tt___Idv))) (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (= smt__TLA______Tt___Idv (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule equiv_pos2)
(step t115 (cl (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (= smt__TLA______Tt___Idv (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule resolution :premises (t114 t112 a17))
(step t116 (cl (= smt__TLA______Tt___Idv (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___))) :rule and :premises (t115))
(step t117 (cl (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___))) :rule refl)
(step t118 (cl (= (= smt__TLA______Tt___Idv (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___)) (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___)))) :rule cong :premises (t116 t117))
(step t119 (cl (= (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule refl)
(step t120 (cl (= (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule refl)
(step t121 (cl (= (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (= smt__TLA______Tt___Idv (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))) :rule cong :premises (t113 t118 t119 t120))
(step t122 (cl (= (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))))) :rule refl)
(step t123 (cl (= (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___)) true)) :rule all_simplify)
(step t124 (cl (= (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) true (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))) :rule cong :premises (t122 t123 t109 t110))
(step t125 (cl (= (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) true (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))) :rule all_simplify)
(step t126 (cl (= (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))) :rule trans :premises (t124 t125))
(step t127 (cl (= (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (= smt__TLA______Tt___Idv (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___)) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))) :rule trans :premises (t121 t126))
(step t128 (cl (= (and (and (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))) (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv)) (=> (and (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___) (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (forall ((smt__CONSTANT___r____1 Idv)) (=> (smt__TLA______Mem smt__CONSTANT___r____1 smt__CONSTANT___Resource___) (=> (smt__TLA______Mem smt__CONSTANT___r____1 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1)))))) (= (smt__ACTION___Allocate___ smt__CONSTANT___clt___ smt__CONSTANT___S___) smt__TLA______Tt___Idv)) (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___)))))) :rule trans :premises (t112 t127))
(step t129 (cl (and (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1)))))) (smt__TLA______Mem smt__VARIABLE___unsat___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))) (smt__TLA______Mem smt__VARIABLE___alloc___ (smt__TLA______FunSet smt__CONSTANT___Client___ (smt__TLA______Subset smt__CONSTANT___Resource___))))) :rule resolution :premises (t99 t128 a17))
(step t130 (cl (forall ((smt__CONSTANT___c1____1 Idv) (smt__CONSTANT___c2____1 Idv) (BOUND_VARIABLE_898 Idv)) (or (not (smt__TLA______Mem smt__CONSTANT___c1____1 smt__CONSTANT___Client___)) (not (smt__TLA______Mem smt__CONSTANT___c2____1 smt__CONSTANT___Client___)) (smt__TLA______TrigEq___Idv smt__CONSTANT___c1____1 smt__CONSTANT___c2____1) (not (smt__TLA______Mem BOUND_VARIABLE_898 smt__CONSTANT___Resource___)) (not (smt__TLA______Mem BOUND_VARIABLE_898 (smt__TLA______Cap (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c1____1) (smt__TLA______FunApp smt__VARIABLE___alloc___ smt__CONSTANT___c2____1))))))) :rule and :premises (t129))
(step t131 (cl) :rule resolution :premises (t7 t98 t130))

